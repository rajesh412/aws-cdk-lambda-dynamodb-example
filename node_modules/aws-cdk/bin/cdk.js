#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("source-map-support/register");
const colors = require("colors/safe");
const fs = require("fs-extra");
const util = require("util");
const yargs = require("yargs");
const lib_1 = require("../lib");
const environments_1 = require("../lib/api/cxapp/environments");
const stacks_1 = require("../lib/api/cxapp/stacks");
const diff_1 = require("../lib/diff");
const init_1 = require("../lib/init");
const interactive_1 = require("../lib/interactive");
const logging_1 = require("../lib/logging");
const plugin_1 = require("../lib/plugin");
const renames_1 = require("../lib/renames");
const serialize_1 = require("../lib/serialize");
const settings_1 = require("../lib/settings");
const version_1 = require("../lib/version");
// tslint:disable-next-line:no-var-requires
const promptly = require('promptly');
const confirm = util.promisify(promptly.confirm);
const DEFAULT_TOOLKIT_STACK_NAME = 'CDKToolkit';
// tslint:disable:no-shadowed-variable max-line-length
async function parseCommandLineArguments() {
    const initTemplateLanuages = await init_1.availableInitLanguages;
    return yargs
        .usage('Usage: cdk -a <cdk-app> COMMAND')
        .option('app', { type: 'string', alias: 'a', desc: 'REQUIRED: Command-line for executing your CDK app (e.g. "node bin/my-app.js")' })
        .option('context', { type: 'array', alias: 'c', desc: 'Add contextual string parameter.', nargs: 1, requiresArg: 'KEY=VALUE' })
        .option('plugin', { type: 'array', alias: 'p', desc: 'Name or path of a node package that extend the CDK features. Can be specified multiple times', nargs: 1 })
        .option('rename', { type: 'string', desc: 'Rename stack name if different then the one defined in the cloud executable', requiresArg: '[ORIGINAL:]RENAMED' })
        .option('trace', { type: 'boolean', desc: 'Print trace for stack warnings' })
        .option('strict', { type: 'boolean', desc: 'Do not construct stacks with warnings' })
        .option('ignore-errors', { type: 'boolean', default: false, desc: 'Ignores synthesis errors, which will likely produce an invalid output' })
        .option('json', { type: 'boolean', alias: 'j', desc: 'Use JSON output instead of YAML' })
        .option('verbose', { type: 'boolean', alias: 'v', desc: 'Show debug logs' })
        .option('profile', { type: 'string', desc: 'Use the indicated AWS profile as the default environment' })
        .option('proxy', { type: 'string', desc: 'Use the indicated proxy. Will read from HTTPS_PROXY environment variable if not specified.' })
        .option('ec2creds', { type: 'boolean', alias: 'i', default: undefined, desc: 'Force trying to fetch EC2 instance credentials. Default: guess EC2 instance status.' })
        .option('version-reporting', { type: 'boolean', desc: 'Include the "AWS::CDK::Metadata" resource in synthesized templates (enabled by default)', default: undefined })
        .option('path-metadata', { type: 'boolean', desc: 'Include "aws:cdk:path" CloudFormation metadata for each resource (enabled by default)', default: true })
        .option('role-arn', { type: 'string', alias: 'r', desc: 'ARN of Role to use when invoking CloudFormation', default: undefined })
        .command(['list', 'ls'], 'Lists all stacks in the app', yargs => yargs
        .option('long', { type: 'boolean', default: false, alias: 'l', desc: 'display environment information for each stack' }))
        .command(['synthesize [STACKS..]', 'synth [STACKS..]'], 'Synthesizes and prints the CloudFormation template for this stack', yargs => yargs
        .option('interactive', { type: 'boolean', alias: 'i', desc: 'interactively watch and show template updates' })
        .option('output', { type: 'string', alias: 'o', desc: 'write CloudFormation template for requested stacks to the given directory' }))
        .command('bootstrap [ENVIRONMENTS..]', 'Deploys the CDK toolkit stack into an AWS environment', yargs => yargs
        .option('toolkit-stack-name', { type: 'string', desc: 'the name of the CDK toolkit stack' }))
        .command('deploy [STACKS..]', 'Deploys the stack(s) named STACKS into your AWS account', yargs => yargs
        .option('require-approval', { type: 'string', choices: [diff_1.RequireApproval.Never, diff_1.RequireApproval.AnyChange, diff_1.RequireApproval.Broadening], desc: 'what security-sensitive changes need manual approval' })
        .option('toolkit-stack-name', { type: 'string', desc: 'the name of the CDK toolkit stack' }))
        .command('destroy [STACKS..]', 'Destroy the stack(s) named STACKS', yargs => yargs
        .option('force', { type: 'boolean', alias: 'f', desc: 'Do not ask for confirmation before destroying the stacks' }))
        .command('diff [STACK]', 'Compares the specified stack with the deployed stack or a local template file', yargs => yargs
        .option('template', { type: 'string', desc: 'the path to the CloudFormation template to compare with' })
        .option('strict', { type: 'boolean', desc: 'do not filter out AWS::CDK::Metadata resources', default: false }))
        .command('metadata [STACK]', 'Returns all metadata associated with this stack')
        .command('init [TEMPLATE]', 'Create a new, empty CDK project from a template. Invoked without TEMPLATE, the app template will be used.', yargs => yargs
        .option('language', { type: 'string', alias: 'l', desc: 'the language to be used for the new project (default can be configured in ~/.cdk.json)', choices: initTemplateLanuages })
        .option('list', { type: 'boolean', desc: 'list the available templates' }))
        .commandDir('../lib/commands', { exclude: /^_.*/ })
        .version(version_1.VERSION)
        .demandCommand(1, '') // just print help
        .help()
        .alias('h', 'help')
        .epilogue([
        'If your app has a single stack, there is no need to specify the stack name',
        'If one of cdk.json or ~/.cdk.json exists, options specified there will be used as defaults. Settings in cdk.json take precedence.'
    ].join('\n\n'))
        .argv;
}
// tslint:enable:no-shadowed-variable max-line-length
async function initCommandLine() {
    const argv = await parseCommandLineArguments();
    if (argv.verbose) {
        logging_1.setVerbose();
    }
    logging_1.debug('CDK toolkit version:', version_1.VERSION);
    logging_1.debug('Command line arguments:', argv);
    const aws = new lib_1.SDK({
        profile: argv.profile,
        proxyAddress: argv.proxy,
        ec2creds: argv.ec2creds,
    });
    const configuration = new settings_1.Configuration(argv);
    await configuration.load();
    configuration.logDefaults();
    const appStacks = new stacks_1.AppStacks(argv, configuration, aws);
    const renames = renames_1.parseRenames(argv.rename);
    /** Function to load plug-ins, using configurations additively. */
    function loadPlugins(...settings) {
        const loaded = new Set();
        for (const source of settings) {
            const plugins = source.get(['plugin']) || [];
            for (const plugin of plugins) {
                const resolved = tryResolve(plugin);
                if (loaded.has(resolved)) {
                    continue;
                }
                logging_1.debug(`Loading plug-in: ${colors.green(plugin)} from ${colors.blue(resolved)}`);
                plugin_1.PluginHost.instance.load(plugin);
                loaded.add(resolved);
            }
        }
        function tryResolve(plugin) {
            try {
                return require.resolve(plugin);
            }
            catch (e) {
                logging_1.error(`Unable to resolve plugin ${colors.green(plugin)}: ${e.stack}`);
                throw new Error(`Unable to resolve plug-in: ${plugin}`);
            }
        }
    }
    loadPlugins(configuration.combined);
    const cmd = argv._[0];
    // Bundle up global objects so the commands have access to them
    const commandOptions = { args: argv, appStacks, configuration, aws };
    const returnValue = argv.commandHandler ? await argv.commandHandler(commandOptions) : await main(cmd, argv);
    if (typeof returnValue === 'object') {
        return toJsonOrYaml(returnValue);
    }
    else if (typeof returnValue === 'string') {
        return returnValue;
    }
    else {
        return returnValue;
    }
    async function main(command, args) {
        const toolkitStackName = configuration.combined.get(['toolkitStackName']) || DEFAULT_TOOLKIT_STACK_NAME;
        args.STACKS = args.STACKS || [];
        args.ENVIRONMENTS = args.ENVIRONMENTS || [];
        switch (command) {
            case 'ls':
            case 'list':
                return await cliList({ long: args.long });
            case 'diff':
                return await diffStack(await findStack(args.STACK), args.template, args.strict);
            case 'bootstrap':
                return await cliBootstrap(args.ENVIRONMENTS, toolkitStackName, args.roleArn);
            case 'deploy':
                return await cliDeploy(args.STACKS, toolkitStackName, args.roleArn, configuration.combined.get(['requireApproval']));
            case 'destroy':
                return await cliDestroy(args.STACKS, args.force, args.roleArn);
            case 'synthesize':
            case 'synth':
                return await cliSynthesize(args.STACKS, args.interactive, args.output, args.json);
            case 'metadata':
                return await cliMetadata(await findStack(args.STACK));
            case 'init':
                const language = configuration.combined.get(['language']);
                if (args.list) {
                    return await init_1.printAvailableTemplates(language);
                }
                else {
                    return await init_1.cliInit(args.TEMPLATE, language);
                }
            default:
                throw new Error('Unknown command: ' + command);
        }
    }
    async function cliMetadata(stackName) {
        const s = await appStacks.synthesizeStack(stackName);
        return s.metadata;
    }
    /**
     * Bootstrap the CDK Toolkit stack in the accounts used by the specified stack(s).
     *
     * @param environmentGlobs environment names that need to have toolkit support
     *             provisioned, as a glob filter. If none is provided,
     *             all stacks are implicitly selected.
     * @param toolkitStackName the name to be used for the CDK Toolkit stack.
     */
    async function cliBootstrap(environmentGlobs, toolkitStackName, roleArn) {
        // Two modes of operation.
        //
        // If there is an '--app' argument, we select the environments from the app. Otherwise we just take the user
        // at their word that they know the name of the environment.
        const app = configuration.combined.get(['app']);
        const environments = app ? await environments_1.globEnvironmentsFromStacks(appStacks, environmentGlobs) : environments_1.environmentsFromDescriptors(environmentGlobs);
        await Promise.all(environments.map(async (environment) => {
            logging_1.success(' ⏳  Bootstrapping environment %s...', colors.blue(environment.name));
            try {
                const result = await lib_1.bootstrapEnvironment(environment, aws, toolkitStackName, roleArn);
                const message = result.noOp ? ' ✅  Environment %s bootstrapped (no changes).'
                    : ' ✅  Environment %s bootstrapped.';
                logging_1.success(message, colors.blue(environment.name));
            }
            catch (e) {
                logging_1.error(' ❌  Environment %s failed bootstrapping: %s', colors.blue(environment.name), e);
                throw e;
            }
        }));
    }
    /**
     * Synthesize the given set of stacks (called when the user runs 'cdk synth')
     *
     * INPUT: Stack names can be supplied using a glob filter. If no stacks are
     * given, all stacks from the application are implictly selected.
     *
     * OUTPUT: If more than one stack ends up being selected, an output directory
     * should be supplied, where the templates will be written.
     */
    async function cliSynthesize(stackNames, doInteractive, outputDir, json) {
        const stacks = await appStacks.selectStacks(...stackNames);
        renames.validateSelectedStacks(stacks);
        if (doInteractive) {
            if (stacks.length !== 1) {
                throw new Error(`When using interactive synthesis, must select exactly one stack. Got: ${stacks_1.listStackNames(stacks)}`);
            }
            return await interactive_1.interactive(stacks[0], argv.verbose, (stack) => appStacks.synthesizeStack(stack));
        }
        if (stacks.length > 1 && outputDir == null) {
            // tslint:disable-next-line:max-line-length
            throw new Error(`Multiple stacks selected (${stacks_1.listStackNames(stacks)}), but output is directed to stdout. Either select one stack, or use --output to send templates to a directory.`);
        }
        if (outputDir == null) {
            return stacks[0].template; // Will be printed in main()
        }
        fs.mkdirpSync(outputDir);
        for (const stack of stacks) {
            const finalName = renames.finalName(stack.name);
            const fileName = `${outputDir}/${finalName}.template.${json ? 'json' : 'yaml'}`;
            logging_1.highlight(fileName);
            await fs.writeFile(fileName, toJsonOrYaml(stack.template));
        }
        return undefined; // Nothing to print
    }
    async function cliList(options = {}) {
        const stacks = await appStacks.listStacks();
        // if we are in "long" mode, emit the array as-is (JSON/YAML)
        if (options.long) {
            const long = [];
            for (const stack of stacks) {
                long.push({
                    name: stack.name,
                    environment: stack.environment
                });
            }
            return long; // will be YAML formatted output
        }
        // just print stack names
        for (const stack of stacks) {
            logging_1.data(stack.name);
        }
        return 0; // exit-code
    }
    async function cliDeploy(stackNames, toolkitStackName, roleArn, requireApproval) {
        if (requireApproval === undefined) {
            requireApproval = diff_1.RequireApproval.Broadening;
        }
        const stacks = await appStacks.selectStacks(...stackNames);
        renames.validateSelectedStacks(stacks);
        for (const stack of stacks) {
            if (stacks.length !== 1) {
                logging_1.highlight(stack.name);
            }
            if (!stack.environment) {
                // tslint:disable-next-line:max-line-length
                throw new Error(`Stack ${stack.name} does not define an environment, and AWS credentials could not be obtained from standard locations or no region was configured.`);
            }
            const toolkitInfo = await lib_1.loadToolkitInfo(stack.environment, aws, toolkitStackName);
            const deployName = renames.finalName(stack.name);
            if (requireApproval !== diff_1.RequireApproval.Never) {
                const currentTemplate = await readCurrentTemplate(stack);
                if (diff_1.printSecurityDiff(currentTemplate, stack, requireApproval)) {
                    // only talk to user if we STDIN is a terminal (otherwise, fail)
                    if (!process.stdin.isTTY) {
                        throw new Error('"--require-approval" is enabled and stack includes security-sensitive updates, ' +
                            'but terminal (TTY) is not attached so we are unable to get a confirmation from the user');
                    }
                    const confirmed = await confirm(`Do you wish to deploy these changes (y/n)?`);
                    if (!confirmed) {
                        throw new Error('Aborted by user');
                    }
                }
            }
            if (deployName !== stack.name) {
                logging_1.print('%s: deploying... (was %s)', colors.bold(deployName), colors.bold(stack.name));
            }
            else {
                logging_1.print('%s: deploying...', colors.bold(stack.name));
            }
            try {
                const result = await lib_1.deployStack({ stack, sdk: aws, toolkitInfo, deployName, roleArn });
                const message = result.noOp
                    ? ` ✅  %s (no changes)`
                    : ` ✅  %s`;
                logging_1.success('\n' + message, stack.name);
                if (Object.keys(result.outputs).length > 0) {
                    logging_1.print('\nOutputs:');
                }
                for (const name of Object.keys(result.outputs)) {
                    const value = result.outputs[name];
                    logging_1.print('%s.%s = %s', colors.cyan(deployName), colors.cyan(name), colors.underline(colors.cyan(value)));
                }
                logging_1.print('\nStack ARN:');
                logging_1.data(result.stackArn);
            }
            catch (e) {
                logging_1.error('\n ❌  %s failed: %s', colors.bold(stack.name), e);
                throw e;
            }
        }
    }
    async function cliDestroy(stackNames, force, roleArn) {
        const stacks = await appStacks.selectStacks(...stackNames);
        renames.validateSelectedStacks(stacks);
        if (!force) {
            // tslint:disable-next-line:max-line-length
            const confirmed = await confirm(`Are you sure you want to delete: ${colors.blue(stacks.map(s => s.name).join(', '))} (y/n)?`);
            if (!confirmed) {
                return;
            }
        }
        for (const stack of stacks) {
            const deployName = renames.finalName(stack.name);
            logging_1.success('%s: destroying...', colors.blue(deployName));
            try {
                await lib_1.destroyStack({ stack, sdk: aws, deployName, roleArn });
                logging_1.success('\n ✅  %s: destroyed', colors.blue(deployName));
            }
            catch (e) {
                logging_1.error('\n ❌  %s: destroy failed', colors.blue(deployName), e);
                throw e;
            }
        }
    }
    async function diffStack(stackName, templatePath, strict) {
        const stack = await appStacks.synthesizeStack(stackName);
        const currentTemplate = await readCurrentTemplate(stack, templatePath);
        if (diff_1.printStackDiff(currentTemplate, stack, strict) === 0) {
            return 0;
        }
        else {
            return 1;
        }
    }
    async function readCurrentTemplate(stack, templatePath) {
        if (templatePath) {
            if (!await fs.pathExists(templatePath)) {
                throw new Error(`There is no file at ${templatePath}`);
            }
            const fileContent = await fs.readFile(templatePath, { encoding: 'UTF-8' });
            return parseTemplate(fileContent);
        }
        else {
            const stackName = renames.finalName(stack.name);
            logging_1.debug(`Reading existing template for stack ${stackName}.`);
            const cfn = await aws.cloudFormation(stack.environment, lib_1.Mode.ForReading);
            try {
                const response = await cfn.getTemplate({ StackName: stackName }).promise();
                return (response.TemplateBody && parseTemplate(response.TemplateBody)) || {};
            }
            catch (e) {
                if (e.code === 'ValidationError' && e.message === `Stack with id ${stackName} does not exist`) {
                    return {};
                }
                else {
                    throw e;
                }
            }
        }
        /* Attempt to parse YAML, fall back to JSON. */
        function parseTemplate(text) {
            return serialize_1.deserializeStructure(text);
        }
    }
    /**
     * Match a single stack from the list of available stacks
     */
    async function findStack(name) {
        const stacks = await appStacks.selectStacks(name);
        // Could have been a glob so check that we evaluated to exactly one
        if (stacks.length > 1) {
            throw new Error(`This command requires exactly one stack and we matched more than one: ${stacks.map(x => x.name)}`);
        }
        return stacks[0].name;
    }
    function toJsonOrYaml(object) {
        return serialize_1.serializeStructure(object, argv.json);
    }
}
initCommandLine()
    .then(value => {
    if (value == null) {
        return;
    }
    if (typeof value === 'string') {
        logging_1.data(value);
    }
    else if (typeof value === 'number') {
        process.exit(value);
    }
})
    .catch(err => {
    logging_1.error(err.message);
    logging_1.debug(err.stack);
    process.exit(1);
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2RrLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY2RrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUNBLHVDQUFxQztBQUdyQyxzQ0FBdUM7QUFDdkMsK0JBQWdDO0FBQ2hDLDZCQUE4QjtBQUM5QiwrQkFBZ0M7QUFFaEMsZ0NBQXFHO0FBQ3JHLGdFQUF3RztBQUN4RyxvREFBb0U7QUFDcEUsc0NBQWlGO0FBQ2pGLHNDQUF1RjtBQUN2RixvREFBaUQ7QUFDakQsNENBQTJGO0FBQzNGLDBDQUEyQztBQUMzQyw0Q0FBOEM7QUFDOUMsZ0RBQTRFO0FBQzVFLDhDQUEwRDtBQUMxRCw0Q0FBeUM7QUFFekMsMkNBQTJDO0FBQzNDLE1BQU0sUUFBUSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUNyQyxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUVqRCxNQUFNLDBCQUEwQixHQUFHLFlBQVksQ0FBQztBQUVoRCxzREFBc0Q7QUFDdEQsS0FBSyxVQUFVLHlCQUF5QjtJQUN0QyxNQUFNLG9CQUFvQixHQUFHLE1BQU0sNkJBQXNCLENBQUM7SUFDMUQsT0FBTyxLQUFLO1NBQ1QsS0FBSyxDQUFDLGlDQUFpQyxDQUFDO1NBQ3hDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLCtFQUErRSxFQUFFLENBQUM7U0FDcEksTUFBTSxDQUFDLFNBQVMsRUFBRSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsa0NBQWtDLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFFLENBQUM7U0FDOUgsTUFBTSxDQUFDLFFBQVEsRUFBRSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxJQUFJ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SUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2xCLENBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiIyEvdXNyL2Jpbi9lbnYgbm9kZVxuaW1wb3J0ICdzb3VyY2UtbWFwLXN1cHBvcnQvcmVnaXN0ZXInO1xuXG5pbXBvcnQgY3hhcGkgPSByZXF1aXJlKCdAYXdzLWNkay9jeC1hcGknKTtcbmltcG9ydCBjb2xvcnMgPSByZXF1aXJlKCdjb2xvcnMvc2FmZScpO1xuaW1wb3J0IGZzID0gcmVxdWlyZSgnZnMtZXh0cmEnKTtcbmltcG9ydCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuaW1wb3J0IHlhcmdzID0gcmVxdWlyZSgneWFyZ3MnKTtcblxuaW1wb3J0IHsgYm9vdHN0cmFwRW52aXJvbm1lbnQsIGRlcGxveVN0YWNrLCBkZXN0cm95U3RhY2ssIGxvYWRUb29sa2l0SW5mbywgTW9kZSwgU0RLIH0gZnJvbSAnLi4vbGliJztcbmltcG9ydCB7IGVudmlyb25tZW50c0Zyb21EZXNjcmlwdG9ycywgZ2xvYkVudmlyb25tZW50c0Zyb21TdGFja3MgfSBmcm9tICcuLi9saWIvYXBpL2N4YXBwL2Vudmlyb25tZW50cyc7XG5pbXBvcnQgeyBBcHBTdGFja3MsIGxpc3RTdGFja05hbWVzIH0gZnJvbSAnLi4vbGliL2FwaS9jeGFwcC9zdGFja3MnO1xuaW1wb3J0IHsgcHJpbnRTZWN1cml0eURpZmYsIHByaW50U3RhY2tEaWZmLCBSZXF1aXJlQXBwcm92YWwgfSBmcm9tICcuLi9saWIvZGlmZic7XG5pbXBvcnQgeyBhdmFpbGFibGVJbml0TGFuZ3VhZ2VzLCBjbGlJbml0LCBwcmludEF2YWlsYWJsZVRlbXBsYXRlcyB9IGZyb20gJy4uL2xpYi9pbml0JztcbmltcG9ydCB7IGludGVyYWN0aXZlIH0gZnJvbSAnLi4vbGliL2ludGVyYWN0aXZlJztcbmltcG9ydCB7IGRhdGEsIGRlYnVnLCBlcnJvciwgaGlnaGxpZ2h0LCBwcmludCwgc2V0VmVyYm9zZSwgc3VjY2VzcyB9IGZyb20gJy4uL2xpYi9sb2dnaW5nJztcbmltcG9ydCB7IFBsdWdpbkhvc3QgfSBmcm9tICcuLi9saWIvcGx1Z2luJztcbmltcG9ydCB7IHBhcnNlUmVuYW1lcyB9IGZyb20gJy4uL2xpYi9yZW5hbWVzJztcbmltcG9ydCB7IGRlc2VyaWFsaXplU3RydWN0dXJlLCBzZXJpYWxpemVTdHJ1Y3R1cmUgfSBmcm9tICcuLi9saWIvc2VyaWFsaXplJztcbmltcG9ydCB7IENvbmZpZ3VyYXRpb24sIFNldHRpbmdzIH0gZnJvbSAnLi4vbGliL3NldHRpbmdzJztcbmltcG9ydCB7IFZFUlNJT04gfSBmcm9tICcuLi9saWIvdmVyc2lvbic7XG5cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby12YXItcmVxdWlyZXNcbmNvbnN0IHByb21wdGx5ID0gcmVxdWlyZSgncHJvbXB0bHknKTtcbmNvbnN0IGNvbmZpcm0gPSB1dGlsLnByb21pc2lmeShwcm9tcHRseS5jb25maXJtKTtcblxuY29uc3QgREVGQVVMVF9UT09MS0lUX1NUQUNLX05BTUUgPSAnQ0RLVG9vbGtpdCc7XG5cbi8vIHRzbGludDpkaXNhYmxlOm5vLXNoYWRvd2VkLXZhcmlhYmxlIG1heC1saW5lLWxlbmd0aFxuYXN5bmMgZnVuY3Rpb24gcGFyc2VDb21tYW5kTGluZUFyZ3VtZW50cygpIHtcbiAgY29uc3QgaW5pdFRlbXBsYXRlTGFudWFnZXMgPSBhd2FpdCBhdmFpbGFibGVJbml0TGFuZ3VhZ2VzO1xuICByZXR1cm4geWFyZ3NcbiAgICAudXNhZ2UoJ1VzYWdlOiBjZGsgLWEgPGNkay1hcHA+IENPTU1BTkQnKVxuICAgIC5vcHRpb24oJ2FwcCcsIHsgdHlwZTogJ3N0cmluZycsIGFsaWFzOiAnYScsIGRlc2M6ICdSRVFVSVJFRDogQ29tbWFuZC1saW5lIGZvciBleGVjdXRpbmcgeW91ciBDREsgYXBwIChlLmcuIFwibm9kZSBiaW4vbXktYXBwLmpzXCIpJyB9KVxuICAgIC5vcHRpb24oJ2NvbnRleHQnLCB7IHR5cGU6ICdhcnJheScsIGFsaWFzOiAnYycsIGRlc2M6ICdBZGQgY29udGV4dHVhbCBzdHJpbmcgcGFyYW1ldGVyLicsIG5hcmdzOiAxLCByZXF1aXJlc0FyZzogJ0tFWT1WQUxVRScgfSlcbiAgICAub3B0aW9uKCdwbHVnaW4nLCB7IHR5cGU6ICdhcnJheScsIGFsaWFzOiAncCcsIGRlc2M6ICdOYW1lIG9yIHBhdGggb2YgYSBub2RlIHBhY2thZ2UgdGhhdCBleHRlbmQgdGhlIENESyBmZWF0dXJlcy4gQ2FuIGJlIHNwZWNpZmllZCBtdWx0aXBsZSB0aW1lcycsIG5hcmdzOiAxIH0pXG4gICAgLm9wdGlvbigncmVuYW1lJywgeyB0eXBlOiAnc3RyaW5nJywgZGVzYzogJ1JlbmFtZSBzdGFjayBuYW1lIGlmIGRpZmZlcmVudCB0aGVuIHRoZSBvbmUgZGVmaW5lZCBpbiB0aGUgY2xvdWQgZXhlY3V0YWJsZScsIHJlcXVpcmVzQXJnOiAnW09SSUdJTkFMOl1SRU5BTUVEJyB9KVxuICAgIC5vcHRpb24oJ3RyYWNlJywgeyB0eXBlOiAnYm9vbGVhbicsIGRlc2M6ICdQcmludCB0cmFjZSBmb3Igc3RhY2sgd2FybmluZ3MnIH0pXG4gICAgLm9wdGlvbignc3RyaWN0JywgeyB0eXBlOiAnYm9vbGVhbicsIGRlc2M6ICdEbyBub3QgY29uc3RydWN0IHN0YWNrcyB3aXRoIHdhcm5pbmdzJyB9KVxuICAgIC5vcHRpb24oJ2lnbm9yZS1lcnJvcnMnLCB7IHR5cGU6ICdib29sZWFuJywgZGVmYXVsdDogZmFsc2UsIGRlc2M6ICdJZ25vcmVzIHN5bnRoZXNpcyBlcnJvcnMsIHdoaWNoIHdpbGwgbGlrZWx5IHByb2R1Y2UgYW4gaW52YWxpZCBvdXRwdXQnIH0pXG4gICAgLm9wdGlvbignanNvbicsIHsgdHlwZTogJ2Jvb2xlYW4nLCBhbGlhczogJ2onLCBkZXNjOiAnVXNlIEpTT04gb3V0cHV0IGluc3RlYWQgb2YgWUFNTCcgfSlcbiAgICAub3B0aW9uKCd2ZXJib3NlJywgeyB0eXBlOiAnYm9vbGVhbicsIGFsaWFzOiAndicsIGRlc2M6ICdTaG93IGRlYnVnIGxvZ3MnIH0pXG4gICAgLm9wdGlvbigncHJvZmlsZScsIHsgdHlwZTogJ3N0cmluZycsIGRlc2M6ICdVc2UgdGhlIGluZGljYXRlZCBBV1MgcHJvZmlsZSBhcyB0aGUgZGVmYXVsdCBlbnZpcm9ubWVudCcgfSlcbiAgICAub3B0aW9uKCdwcm94eScsIHsgdHlwZTogJ3N0cmluZycsIGRlc2M6ICdVc2UgdGhlIGluZGljYXRlZCBwcm94eS4gV2lsbCByZWFkIGZyb20gSFRUUFNfUFJPWFkgZW52aXJvbm1lbnQgdmFyaWFibGUgaWYgbm90IHNwZWNpZmllZC4nIH0pXG4gICAgLm9wdGlvbignZWMyY3JlZHMnLCB7IHR5cGU6ICdib29sZWFuJywgYWxpYXM6ICdpJywgZGVmYXVsdDogdW5kZWZpbmVkLCBkZXNjOiAnRm9yY2UgdHJ5aW5nIHRvIGZldGNoIEVDMiBpbnN0YW5jZSBjcmVkZW50aWFscy4gRGVmYXVsdDogZ3Vlc3MgRUMyIGluc3RhbmNlIHN0YXR1cy4nIH0pXG4gICAgLm9wdGlvbigndmVyc2lvbi1yZXBvcnRpbmcnLCB7IHR5cGU6ICdib29sZWFuJywgZGVzYzogJ0luY2x1ZGUgdGhlIFwiQVdTOjpDREs6Ok1ldGFkYXRhXCIgcmVzb3VyY2UgaW4gc3ludGhlc2l6ZWQgdGVtcGxhdGVzIChlbmFibGVkIGJ5IGRlZmF1bHQpJywgZGVmYXVsdDogdW5kZWZpbmVkIH0pXG4gICAgLm9wdGlvbigncGF0aC1tZXRhZGF0YScsIHsgdHlwZTogJ2Jvb2xlYW4nLCBkZXNjOiAnSW5jbHVkZSBcImF3czpjZGs6cGF0aFwiIENsb3VkRm9ybWF0aW9uIG1ldGFkYXRhIGZvciBlYWNoIHJlc291cmNlIChlbmFibGVkIGJ5IGRlZmF1bHQpJywgZGVmYXVsdDogdHJ1ZSB9KVxuICAgIC5vcHRpb24oJ3JvbGUtYXJuJywgeyB0eXBlOiAnc3RyaW5nJywgYWxpYXM6ICdyJywgZGVzYzogJ0FSTiBvZiBSb2xlIHRvIHVzZSB3aGVuIGludm9raW5nIENsb3VkRm9ybWF0aW9uJywgZGVmYXVsdDogdW5kZWZpbmVkIH0pXG4gICAgLmNvbW1hbmQoWyAnbGlzdCcsICdscycgXSwgJ0xpc3RzIGFsbCBzdGFja3MgaW4gdGhlIGFwcCcsIHlhcmdzID0+IHlhcmdzXG4gICAgICAub3B0aW9uKCdsb25nJywgeyB0eXBlOiAnYm9vbGVhbicsIGRlZmF1bHQ6IGZhbHNlLCBhbGlhczogJ2wnLCBkZXNjOiAnZGlzcGxheSBlbnZpcm9ubWVudCBpbmZvcm1hdGlvbiBmb3IgZWFjaCBzdGFjaycgfSkpXG4gICAgLmNvbW1hbmQoWyAnc3ludGhlc2l6ZSBbU1RBQ0tTLi5dJywgJ3N5bnRoIFtTVEFDS1MuLl0nIF0sICdTeW50aGVzaXplcyBhbmQgcHJpbnRzIHRoZSBDbG91ZEZvcm1hdGlvbiB0ZW1wbGF0ZSBmb3IgdGhpcyBzdGFjaycsIHlhcmdzID0+IHlhcmdzXG4gICAgICAub3B0aW9uKCdpbnRlcmFjdGl2ZScsIHsgdHlwZTogJ2Jvb2xlYW4nLCBhbGlhczogJ2knLCBkZXNjOiAnaW50ZXJhY3RpdmVseSB3YXRjaCBhbmQgc2hvdyB0ZW1wbGF0ZSB1cGRhdGVzJyB9KVxuICAgICAgLm9wdGlvbignb3V0cHV0JywgeyB0eXBlOiAnc3RyaW5nJywgYWxpYXM6ICdvJywgZGVzYzogJ3dyaXRlIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlIGZvciByZXF1ZXN0ZWQgc3RhY2tzIHRvIHRoZSBnaXZlbiBkaXJlY3RvcnknIH0pKVxuICAgIC5jb21tYW5kKCdib290c3RyYXAgW0VOVklST05NRU5UUy4uXScsICdEZXBsb3lzIHRoZSBDREsgdG9vbGtpdCBzdGFjayBpbnRvIGFuIEFXUyBlbnZpcm9ubWVudCcsIHlhcmdzID0+IHlhcmdzXG4gICAgICAub3B0aW9uKCd0b29sa2l0LXN0YWNrLW5hbWUnLCB7IHR5cGU6ICdzdHJpbmcnLCBkZXNjOiAndGhlIG5hbWUgb2YgdGhlIENESyB0b29sa2l0IHN0YWNrJyB9KSlcbiAgICAuY29tbWFuZCgnZGVwbG95IFtTVEFDS1MuLl0nLCAnRGVwbG95cyB0aGUgc3RhY2socykgbmFtZWQgU1RBQ0tTIGludG8geW91ciBBV1MgYWNjb3VudCcsIHlhcmdzID0+IHlhcmdzXG4gICAgICAub3B0aW9uKCdyZXF1aXJlLWFwcHJvdmFsJywgeyB0eXBlOiAnc3RyaW5nJywgY2hvaWNlczogW1JlcXVpcmVBcHByb3ZhbC5OZXZlciwgUmVxdWlyZUFwcHJvdmFsLkFueUNoYW5nZSwgUmVxdWlyZUFwcHJvdmFsLkJyb2FkZW5pbmddLCBkZXNjOiAnd2hhdCBzZWN1cml0eS1zZW5zaXRpdmUgY2hhbmdlcyBuZWVkIG1hbnVhbCBhcHByb3ZhbCcgfSlcbiAgICAgIC5vcHRpb24oJ3Rvb2xraXQtc3RhY2stbmFtZScsIHsgdHlwZTogJ3N0cmluZycsIGRlc2M6ICd0aGUgbmFtZSBvZiB0aGUgQ0RLIHRvb2xraXQgc3RhY2snIH0pKVxuICAgIC5jb21tYW5kKCdkZXN0cm95IFtTVEFDS1MuLl0nLCAnRGVzdHJveSB0aGUgc3RhY2socykgbmFtZWQgU1RBQ0tTJywgeWFyZ3MgPT4geWFyZ3NcbiAgICAgIC5vcHRpb24oJ2ZvcmNlJywgeyB0eXBlOiAnYm9vbGVhbicsIGFsaWFzOiAnZicsIGRlc2M6ICdEbyBub3QgYXNrIGZvciBjb25maXJtYXRpb24gYmVmb3JlIGRlc3Ryb3lpbmcgdGhlIHN0YWNrcycgfSkpXG4gICAgLmNvbW1hbmQoJ2RpZmYgW1NUQUNLXScsICdDb21wYXJlcyB0aGUgc3BlY2lmaWVkIHN0YWNrIHdpdGggdGhlIGRlcGxveWVkIHN0YWNrIG9yIGEgbG9jYWwgdGVtcGxhdGUgZmlsZScsIHlhcmdzID0+IHlhcmdzXG4gICAgICAub3B0aW9uKCd0ZW1wbGF0ZScsIHsgdHlwZTogJ3N0cmluZycsIGRlc2M6ICd0aGUgcGF0aCB0byB0aGUgQ2xvdWRGb3JtYXRpb24gdGVtcGxhdGUgdG8gY29tcGFyZSB3aXRoJyB9KVxuICAgICAgLm9wdGlvbignc3RyaWN0JywgeyB0eXBlOiAnYm9vbGVhbicsIGRlc2M6ICdkbyBub3QgZmlsdGVyIG91dCBBV1M6OkNESzo6TWV0YWRhdGEgcmVzb3VyY2VzJywgZGVmYXVsdDogZmFsc2UgfSkpXG4gICAgLmNvbW1hbmQoJ21ldGFkYXRhIFtTVEFDS10nLCAnUmV0dXJucyBhbGwgbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoaXMgc3RhY2snKVxuICAgIC5jb21tYW5kKCdpbml0IFtURU1QTEFURV0nLCAnQ3JlYXRlIGEgbmV3LCBlbXB0eSBDREsgcHJvamVjdCBmcm9tIGEgdGVtcGxhdGUuIEludm9rZWQgd2l0aG91dCBURU1QTEFURSwgdGhlIGFwcCB0ZW1wbGF0ZSB3aWxsIGJlIHVzZWQuJywgeWFyZ3MgPT4geWFyZ3NcbiAgICAgIC5vcHRpb24oJ2xhbmd1YWdlJywgeyB0eXBlOiAnc3RyaW5nJywgYWxpYXM6ICdsJywgZGVzYzogJ3RoZSBsYW5ndWFnZSB0byBiZSB1c2VkIGZvciB0aGUgbmV3IHByb2plY3QgKGRlZmF1bHQgY2FuIGJlIGNvbmZpZ3VyZWQgaW4gfi8uY2RrLmpzb24pJywgY2hvaWNlczogaW5pdFRlbXBsYXRlTGFudWFnZXMgfSlcbiAgICAgIC5vcHRpb24oJ2xpc3QnLCB7IHR5cGU6ICdib29sZWFuJywgZGVzYzogJ2xpc3QgdGhlIGF2YWlsYWJsZSB0ZW1wbGF0ZXMnIH0pKVxuICAgIC5jb21tYW5kRGlyKCcuLi9saWIvY29tbWFuZHMnLCB7IGV4Y2x1ZGU6IC9eXy4qLyB9KVxuICAgIC52ZXJzaW9uKFZFUlNJT04pXG4gICAgLmRlbWFuZENvbW1hbmQoMSwgJycpIC8vIGp1c3QgcHJpbnQgaGVscFxuICAgIC5oZWxwKClcbiAgICAuYWxpYXMoJ2gnLCAnaGVscCcpXG4gICAgLmVwaWxvZ3VlKFtcbiAgICAgICdJZiB5b3VyIGFwcCBoYXMgYSBzaW5nbGUgc3RhY2ssIHRoZXJlIGlzIG5vIG5lZWQgdG8gc3BlY2lmeSB0aGUgc3RhY2sgbmFtZScsXG4gICAgICAnSWYgb25lIG9mIGNkay5qc29uIG9yIH4vLmNkay5qc29uIGV4aXN0cywgb3B0aW9ucyBzcGVjaWZpZWQgdGhlcmUgd2lsbCBiZSB1c2VkIGFzIGRlZmF1bHRzLiBTZXR0aW5ncyBpbiBjZGsuanNvbiB0YWtlIHByZWNlZGVuY2UuJ1xuICAgIF0uam9pbignXFxuXFxuJykpXG4gICAgLmFyZ3Y7XG59XG4vLyB0c2xpbnQ6ZW5hYmxlOm5vLXNoYWRvd2VkLXZhcmlhYmxlIG1heC1saW5lLWxlbmd0aFxuXG5hc3luYyBmdW5jdGlvbiBpbml0Q29tbWFuZExpbmUoKSB7XG4gIGNvbnN0IGFyZ3YgPSBhd2FpdCBwYXJzZUNvbW1hbmRMaW5lQXJndW1lbnRzKCk7XG4gIGlmIChhcmd2LnZlcmJvc2UpIHtcbiAgICBzZXRWZXJib3NlKCk7XG4gIH1cblxuICBkZWJ1ZygnQ0RLIHRvb2xraXQgdmVyc2lvbjonLCBWRVJTSU9OKTtcbiAgZGVidWcoJ0NvbW1hbmQgbGluZSBhcmd1bWVudHM6JywgYXJndik7XG5cbiAgY29uc3QgYXdzID0gbmV3IFNESyh7XG4gICAgcHJvZmlsZTogYXJndi5wcm9maWxlLFxuICAgIHByb3h5QWRkcmVzczogYXJndi5wcm94eSxcbiAgICBlYzJjcmVkczogYXJndi5lYzJjcmVkcyxcbiAgfSk7XG5cbiAgY29uc3QgY29uZmlndXJhdGlvbiA9IG5ldyBDb25maWd1cmF0aW9uKGFyZ3YpO1xuICBhd2FpdCBjb25maWd1cmF0aW9uLmxvYWQoKTtcbiAgY29uZmlndXJhdGlvbi5sb2dEZWZhdWx0cygpO1xuXG4gIGNvbnN0IGFwcFN0YWNrcyA9IG5ldyBBcHBTdGFja3MoYXJndiwgY29uZmlndXJhdGlvbiwgYXdzKTtcblxuICBjb25zdCByZW5hbWVzID0gcGFyc2VSZW5hbWVzKGFyZ3YucmVuYW1lKTtcblxuICAvKiogRnVuY3Rpb24gdG8gbG9hZCBwbHVnLWlucywgdXNpbmcgY29uZmlndXJhdGlvbnMgYWRkaXRpdmVseS4gKi9cbiAgZnVuY3Rpb24gbG9hZFBsdWdpbnMoLi4uc2V0dGluZ3M6IFNldHRpbmdzW10pIHtcbiAgICBjb25zdCBsb2FkZWQgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBzZXR0aW5ncykge1xuICAgICAgY29uc3QgcGx1Z2luczogc3RyaW5nW10gPSBzb3VyY2UuZ2V0KFsncGx1Z2luJ10pIHx8IFtdO1xuICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgICAgICBjb25zdCByZXNvbHZlZCA9IHRyeVJlc29sdmUocGx1Z2luKTtcbiAgICAgICAgaWYgKGxvYWRlZC5oYXMocmVzb2x2ZWQpKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIGRlYnVnKGBMb2FkaW5nIHBsdWctaW46ICR7Y29sb3JzLmdyZWVuKHBsdWdpbil9IGZyb20gJHtjb2xvcnMuYmx1ZShyZXNvbHZlZCl9YCk7XG4gICAgICAgIFBsdWdpbkhvc3QuaW5zdGFuY2UubG9hZChwbHVnaW4pO1xuICAgICAgICBsb2FkZWQuYWRkKHJlc29sdmVkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cnlSZXNvbHZlKHBsdWdpbjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlLnJlc29sdmUocGx1Z2luKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3IoYFVuYWJsZSB0byByZXNvbHZlIHBsdWdpbiAke2NvbG9ycy5ncmVlbihwbHVnaW4pfTogJHtlLnN0YWNrfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byByZXNvbHZlIHBsdWctaW46ICR7cGx1Z2lufWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxvYWRQbHVnaW5zKGNvbmZpZ3VyYXRpb24uY29tYmluZWQpO1xuXG4gIGNvbnN0IGNtZCA9IGFyZ3YuX1swXTtcblxuICAvLyBCdW5kbGUgdXAgZ2xvYmFsIG9iamVjdHMgc28gdGhlIGNvbW1hbmRzIGhhdmUgYWNjZXNzIHRvIHRoZW1cbiAgY29uc3QgY29tbWFuZE9wdGlvbnMgPSB7IGFyZ3M6IGFyZ3YsIGFwcFN0YWNrcywgY29uZmlndXJhdGlvbiwgYXdzIH07XG5cbiAgY29uc3QgcmV0dXJuVmFsdWUgPSBhcmd2LmNvbW1hbmRIYW5kbGVyID8gYXdhaXQgYXJndi5jb21tYW5kSGFuZGxlcihjb21tYW5kT3B0aW9ucykgOiBhd2FpdCBtYWluKGNtZCwgYXJndik7XG4gIGlmICh0eXBlb2YgcmV0dXJuVmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHRvSnNvbk9yWWFtbChyZXR1cm5WYWx1ZSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHJldHVyblZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBtYWluKGNvbW1hbmQ6IHN0cmluZywgYXJnczogYW55KTogUHJvbWlzZTxudW1iZXIgfCBzdHJpbmcgfCB7fSB8wqB2b2lkPiB7XG4gICAgY29uc3QgdG9vbGtpdFN0YWNrTmFtZTogc3RyaW5nID0gY29uZmlndXJhdGlvbi5jb21iaW5lZC5nZXQoWyd0b29sa2l0U3RhY2tOYW1lJ10pIHx8IERFRkFVTFRfVE9PTEtJVF9TVEFDS19OQU1FO1xuXG4gICAgYXJncy5TVEFDS1MgPSBhcmdzLlNUQUNLUyB8fCBbXTtcbiAgICBhcmdzLkVOVklST05NRU5UUyA9IGFyZ3MuRU5WSVJPTk1FTlRTIHx8IFtdO1xuXG4gICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICBjYXNlICdscyc6XG4gICAgICBjYXNlICdsaXN0JzpcbiAgICAgICAgcmV0dXJuIGF3YWl0IGNsaUxpc3QoeyBsb25nOiBhcmdzLmxvbmcgfSk7XG5cbiAgICAgIGNhc2UgJ2RpZmYnOlxuICAgICAgICByZXR1cm4gYXdhaXQgZGlmZlN0YWNrKGF3YWl0IGZpbmRTdGFjayhhcmdzLlNUQUNLKSwgYXJncy50ZW1wbGF0ZSwgYXJncy5zdHJpY3QpO1xuXG4gICAgICBjYXNlICdib290c3RyYXAnOlxuICAgICAgICByZXR1cm4gYXdhaXQgY2xpQm9vdHN0cmFwKGFyZ3MuRU5WSVJPTk1FTlRTLCB0b29sa2l0U3RhY2tOYW1lLCBhcmdzLnJvbGVBcm4pO1xuXG4gICAgICBjYXNlICdkZXBsb3knOlxuICAgICAgICByZXR1cm4gYXdhaXQgY2xpRGVwbG95KGFyZ3MuU1RBQ0tTLCB0b29sa2l0U3RhY2tOYW1lLCBhcmdzLnJvbGVBcm4sIGNvbmZpZ3VyYXRpb24uY29tYmluZWQuZ2V0KFsncmVxdWlyZUFwcHJvdmFsJ10pKTtcblxuICAgICAgY2FzZSAnZGVzdHJveSc6XG4gICAgICAgIHJldHVybiBhd2FpdCBjbGlEZXN0cm95KGFyZ3MuU1RBQ0tTLCBhcmdzLmZvcmNlLCBhcmdzLnJvbGVBcm4pO1xuXG4gICAgICBjYXNlICdzeW50aGVzaXplJzpcbiAgICAgIGNhc2UgJ3N5bnRoJzpcbiAgICAgICAgcmV0dXJuIGF3YWl0IGNsaVN5bnRoZXNpemUoYXJncy5TVEFDS1MsIGFyZ3MuaW50ZXJhY3RpdmUsIGFyZ3Mub3V0cHV0LCBhcmdzLmpzb24pO1xuXG4gICAgICBjYXNlICdtZXRhZGF0YSc6XG4gICAgICAgIHJldHVybiBhd2FpdCBjbGlNZXRhZGF0YShhd2FpdCBmaW5kU3RhY2soYXJncy5TVEFDSykpO1xuXG4gICAgICBjYXNlICdpbml0JzpcbiAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSBjb25maWd1cmF0aW9uLmNvbWJpbmVkLmdldChbJ2xhbmd1YWdlJ10pO1xuICAgICAgICBpZiAoYXJncy5saXN0KSB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHByaW50QXZhaWxhYmxlVGVtcGxhdGVzKGxhbmd1YWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgY2xpSW5pdChhcmdzLlRFTVBMQVRFLCBsYW5ndWFnZSk7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNvbW1hbmQ6ICcgKyBjb21tYW5kKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBjbGlNZXRhZGF0YShzdGFja05hbWU6IHN0cmluZykge1xuICAgIGNvbnN0IHMgPSBhd2FpdCBhcHBTdGFja3Muc3ludGhlc2l6ZVN0YWNrKHN0YWNrTmFtZSk7XG4gICAgcmV0dXJuIHMubWV0YWRhdGE7XG4gIH1cblxuICAvKipcbiAgICogQm9vdHN0cmFwIHRoZSBDREsgVG9vbGtpdCBzdGFjayBpbiB0aGUgYWNjb3VudHMgdXNlZCBieSB0aGUgc3BlY2lmaWVkIHN0YWNrKHMpLlxuICAgKlxuICAgKiBAcGFyYW0gZW52aXJvbm1lbnRHbG9icyBlbnZpcm9ubWVudCBuYW1lcyB0aGF0IG5lZWQgdG8gaGF2ZSB0b29sa2l0IHN1cHBvcnRcbiAgICogICAgICAgICAgICAgcHJvdmlzaW9uZWQsIGFzIGEgZ2xvYiBmaWx0ZXIuIElmIG5vbmUgaXMgcHJvdmlkZWQsXG4gICAqICAgICAgICAgICAgIGFsbCBzdGFja3MgYXJlIGltcGxpY2l0bHkgc2VsZWN0ZWQuXG4gICAqIEBwYXJhbSB0b29sa2l0U3RhY2tOYW1lIHRoZSBuYW1lIHRvIGJlIHVzZWQgZm9yIHRoZSBDREsgVG9vbGtpdCBzdGFjay5cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIGNsaUJvb3RzdHJhcChlbnZpcm9ubWVudEdsb2JzOiBzdHJpbmdbXSwgdG9vbGtpdFN0YWNrTmFtZTogc3RyaW5nLCByb2xlQXJuOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBUd28gbW9kZXMgb2Ygb3BlcmF0aW9uLlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gJy0tYXBwJyBhcmd1bWVudCwgd2Ugc2VsZWN0IHRoZSBlbnZpcm9ubWVudHMgZnJvbSB0aGUgYXBwLiBPdGhlcndpc2Ugd2UganVzdCB0YWtlIHRoZSB1c2VyXG4gICAgLy8gYXQgdGhlaXIgd29yZCB0aGF0IHRoZXkga25vdyB0aGUgbmFtZSBvZiB0aGUgZW52aXJvbm1lbnQuXG5cbiAgICBjb25zdCBhcHAgPSBjb25maWd1cmF0aW9uLmNvbWJpbmVkLmdldChbJ2FwcCddKTtcblxuICAgIGNvbnN0IGVudmlyb25tZW50cyA9IGFwcCA/IGF3YWl0IGdsb2JFbnZpcm9ubWVudHNGcm9tU3RhY2tzKGFwcFN0YWNrcywgZW52aXJvbm1lbnRHbG9icykgOiBlbnZpcm9ubWVudHNGcm9tRGVzY3JpcHRvcnMoZW52aXJvbm1lbnRHbG9icyk7XG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChlbnZpcm9ubWVudHMubWFwKGFzeW5jIChlbnZpcm9ubWVudCkgPT4ge1xuICAgICAgc3VjY2VzcygnIOKPsyAgQm9vdHN0cmFwcGluZyBlbnZpcm9ubWVudCAlcy4uLicsIGNvbG9ycy5ibHVlKGVudmlyb25tZW50Lm5hbWUpKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGJvb3RzdHJhcEVudmlyb25tZW50KGVudmlyb25tZW50LCBhd3MsIHRvb2xraXRTdGFja05hbWUsIHJvbGVBcm4pO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gcmVzdWx0Lm5vT3AgPyAnIOKchSAgRW52aXJvbm1lbnQgJXMgYm9vdHN0cmFwcGVkIChubyBjaGFuZ2VzKS4nXG4gICAgICAgICAgICAgICAgICAgICAgOiAnIOKchSAgRW52aXJvbm1lbnQgJXMgYm9vdHN0cmFwcGVkLic7XG4gICAgICAgIHN1Y2Nlc3MobWVzc2FnZSwgY29sb3JzLmJsdWUoZW52aXJvbm1lbnQubmFtZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvcignIOKdjCAgRW52aXJvbm1lbnQgJXMgZmFpbGVkIGJvb3RzdHJhcHBpbmc6ICVzJywgY29sb3JzLmJsdWUoZW52aXJvbm1lbnQubmFtZSksIGUpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTeW50aGVzaXplIHRoZSBnaXZlbiBzZXQgb2Ygc3RhY2tzIChjYWxsZWQgd2hlbiB0aGUgdXNlciBydW5zICdjZGsgc3ludGgnKVxuICAgKlxuICAgKiBJTlBVVDogU3RhY2sgbmFtZXMgY2FuIGJlIHN1cHBsaWVkIHVzaW5nIGEgZ2xvYiBmaWx0ZXIuIElmIG5vIHN0YWNrcyBhcmVcbiAgICogZ2l2ZW4sIGFsbCBzdGFja3MgZnJvbSB0aGUgYXBwbGljYXRpb24gYXJlIGltcGxpY3RseSBzZWxlY3RlZC5cbiAgICpcbiAgICogT1VUUFVUOiBJZiBtb3JlIHRoYW4gb25lIHN0YWNrIGVuZHMgdXAgYmVpbmcgc2VsZWN0ZWQsIGFuIG91dHB1dCBkaXJlY3RvcnlcbiAgICogc2hvdWxkIGJlIHN1cHBsaWVkLCB3aGVyZSB0aGUgdGVtcGxhdGVzIHdpbGwgYmUgd3JpdHRlbi5cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIGNsaVN5bnRoZXNpemUoc3RhY2tOYW1lczogc3RyaW5nW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9JbnRlcmFjdGl2ZTogYm9vbGVhbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXREaXI6IHN0cmluZ3x1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbjogYm9vbGVhbik6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHN0YWNrcyA9IGF3YWl0IGFwcFN0YWNrcy5zZWxlY3RTdGFja3MoLi4uc3RhY2tOYW1lcyk7XG4gICAgcmVuYW1lcy52YWxpZGF0ZVNlbGVjdGVkU3RhY2tzKHN0YWNrcyk7XG5cbiAgICBpZiAoZG9JbnRlcmFjdGl2ZSkge1xuICAgICAgaWYgKHN0YWNrcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXaGVuIHVzaW5nIGludGVyYWN0aXZlIHN5bnRoZXNpcywgbXVzdCBzZWxlY3QgZXhhY3RseSBvbmUgc3RhY2suIEdvdDogJHtsaXN0U3RhY2tOYW1lcyhzdGFja3MpfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF3YWl0IGludGVyYWN0aXZlKHN0YWNrc1swXSwgYXJndi52ZXJib3NlLCAoc3RhY2spID0+IGFwcFN0YWNrcy5zeW50aGVzaXplU3RhY2soc3RhY2spKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhY2tzLmxlbmd0aCA+IDEgJiYgb3V0cHV0RGlyID09IG51bGwpIHtcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTXVsdGlwbGUgc3RhY2tzIHNlbGVjdGVkICgke2xpc3RTdGFja05hbWVzKHN0YWNrcyl9KSwgYnV0IG91dHB1dCBpcyBkaXJlY3RlZCB0byBzdGRvdXQuIEVpdGhlciBzZWxlY3Qgb25lIHN0YWNrLCBvciB1c2UgLS1vdXRwdXQgdG8gc2VuZCB0ZW1wbGF0ZXMgdG8gYSBkaXJlY3RvcnkuYCk7XG4gICAgfVxuXG4gICAgaWYgKG91dHB1dERpciA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gc3RhY2tzWzBdLnRlbXBsYXRlOyAgLy8gV2lsbCBiZSBwcmludGVkIGluIG1haW4oKVxuICAgIH1cblxuICAgIGZzLm1rZGlycFN5bmMob3V0cHV0RGlyKTtcblxuICAgIGZvciAoY29uc3Qgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgICBjb25zdCBmaW5hbE5hbWUgPSByZW5hbWVzLmZpbmFsTmFtZShzdGFjay5uYW1lKTtcbiAgICAgIGNvbnN0IGZpbGVOYW1lID0gYCR7b3V0cHV0RGlyfS8ke2ZpbmFsTmFtZX0udGVtcGxhdGUuJHtqc29uID8gJ2pzb24nIDogJ3lhbWwnfWA7XG4gICAgICBoaWdobGlnaHQoZmlsZU5hbWUpO1xuICAgICAgYXdhaXQgZnMud3JpdGVGaWxlKGZpbGVOYW1lLCB0b0pzb25PcllhbWwoc3RhY2sudGVtcGxhdGUpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBOb3RoaW5nIHRvIHByaW50XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBjbGlMaXN0KG9wdGlvbnM6IHsgbG9uZz86IGJvb2xlYW4gfSA9IHsgfSkge1xuICAgIGNvbnN0IHN0YWNrcyA9IGF3YWl0IGFwcFN0YWNrcy5saXN0U3RhY2tzKCk7XG5cbiAgICAvLyBpZiB3ZSBhcmUgaW4gXCJsb25nXCIgbW9kZSwgZW1pdCB0aGUgYXJyYXkgYXMtaXMgKEpTT04vWUFNTClcbiAgICBpZiAob3B0aW9ucy5sb25nKSB7XG4gICAgICBjb25zdCBsb25nID0gW107XG4gICAgICBmb3IgKGNvbnN0IHN0YWNrIG9mIHN0YWNrcykge1xuICAgICAgICBsb25nLnB1c2goe1xuICAgICAgICAgIG5hbWU6IHN0YWNrLm5hbWUsXG4gICAgICAgICAgZW52aXJvbm1lbnQ6IHN0YWNrLmVudmlyb25tZW50XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxvbmc7IC8vIHdpbGwgYmUgWUFNTCBmb3JtYXR0ZWQgb3V0cHV0XG4gICAgfVxuXG4gICAgLy8ganVzdCBwcmludCBzdGFjayBuYW1lc1xuICAgIGZvciAoY29uc3Qgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgICBkYXRhKHN0YWNrLm5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiAwOyAvLyBleGl0LWNvZGVcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGNsaURlcGxveShzdGFja05hbWVzOiBzdHJpbmdbXSwgdG9vbGtpdFN0YWNrTmFtZTogc3RyaW5nLCByb2xlQXJuOiBzdHJpbmcgfCB1bmRlZmluZWQsIHJlcXVpcmVBcHByb3ZhbDogUmVxdWlyZUFwcHJvdmFsKSB7XG4gICAgaWYgKHJlcXVpcmVBcHByb3ZhbCA9PT0gdW5kZWZpbmVkKSB7IHJlcXVpcmVBcHByb3ZhbCA9IFJlcXVpcmVBcHByb3ZhbC5Ccm9hZGVuaW5nOyB9XG5cbiAgICBjb25zdCBzdGFja3MgPSBhd2FpdCBhcHBTdGFja3Muc2VsZWN0U3RhY2tzKC4uLnN0YWNrTmFtZXMpO1xuICAgIHJlbmFtZXMudmFsaWRhdGVTZWxlY3RlZFN0YWNrcyhzdGFja3MpO1xuXG4gICAgZm9yIChjb25zdCBzdGFjayBvZiBzdGFja3MpIHtcbiAgICAgIGlmIChzdGFja3MubGVuZ3RoICE9PSAxKSB7wqBoaWdobGlnaHQoc3RhY2submFtZSk7IH1cbiAgICAgIGlmICghc3RhY2suZW52aXJvbm1lbnQpIHtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1saW5lLWxlbmd0aFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0YWNrICR7c3RhY2submFtZX0gZG9lcyBub3QgZGVmaW5lIGFuIGVudmlyb25tZW50LCBhbmQgQVdTIGNyZWRlbnRpYWxzIGNvdWxkIG5vdCBiZSBvYnRhaW5lZCBmcm9tIHN0YW5kYXJkIGxvY2F0aW9ucyBvciBubyByZWdpb24gd2FzIGNvbmZpZ3VyZWQuYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB0b29sa2l0SW5mbyA9IGF3YWl0IGxvYWRUb29sa2l0SW5mbyhzdGFjay5lbnZpcm9ubWVudCwgYXdzLCB0b29sa2l0U3RhY2tOYW1lKTtcbiAgICAgIGNvbnN0IGRlcGxveU5hbWUgPSByZW5hbWVzLmZpbmFsTmFtZShzdGFjay5uYW1lKTtcblxuICAgICAgaWYgKHJlcXVpcmVBcHByb3ZhbCAhPT0gUmVxdWlyZUFwcHJvdmFsLk5ldmVyKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUZW1wbGF0ZSA9IGF3YWl0IHJlYWRDdXJyZW50VGVtcGxhdGUoc3RhY2spO1xuICAgICAgICBpZiAocHJpbnRTZWN1cml0eURpZmYoY3VycmVudFRlbXBsYXRlLCBzdGFjaywgcmVxdWlyZUFwcHJvdmFsKSkge1xuXG4gICAgICAgICAgLy8gb25seSB0YWxrIHRvIHVzZXIgaWYgd2UgU1RESU4gaXMgYSB0ZXJtaW5hbCAob3RoZXJ3aXNlLCBmYWlsKVxuICAgICAgICAgIGlmICghcHJvY2Vzcy5zdGRpbi5pc1RUWSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAnXCItLXJlcXVpcmUtYXBwcm92YWxcIiBpcyBlbmFibGVkIGFuZCBzdGFjayBpbmNsdWRlcyBzZWN1cml0eS1zZW5zaXRpdmUgdXBkYXRlcywgJyArXG4gICAgICAgICAgICAgICdidXQgdGVybWluYWwgKFRUWSkgaXMgbm90IGF0dGFjaGVkIHNvIHdlIGFyZSB1bmFibGUgdG8gZ2V0IGEgY29uZmlybWF0aW9uIGZyb20gdGhlIHVzZXInKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBjb25maXJtZWQgPSBhd2FpdCBjb25maXJtKGBEbyB5b3Ugd2lzaCB0byBkZXBsb3kgdGhlc2UgY2hhbmdlcyAoeS9uKT9gKTtcbiAgICAgICAgICBpZiAoIWNvbmZpcm1lZCkgeyB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0ZWQgYnkgdXNlcicpOyB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRlcGxveU5hbWUgIT09IHN0YWNrLm5hbWUpIHtcbiAgICAgICAgcHJpbnQoJyVzOiBkZXBsb3lpbmcuLi4gKHdhcyAlcyknLCBjb2xvcnMuYm9sZChkZXBsb3lOYW1lKSwgY29sb3JzLmJvbGQoc3RhY2submFtZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJpbnQoJyVzOiBkZXBsb3lpbmcuLi4nLCBjb2xvcnMuYm9sZChzdGFjay5uYW1lKSk7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRlcGxveVN0YWNrKHsgc3RhY2ssIHNkazogYXdzLCB0b29sa2l0SW5mbywgZGVwbG95TmFtZSwgcm9sZUFybiB9KTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHJlc3VsdC5ub09wXG4gICAgICAgICAgPyBgIOKchSAgJXMgKG5vIGNoYW5nZXMpYFxuICAgICAgICAgIDogYCDinIUgICVzYDtcblxuICAgICAgICBzdWNjZXNzKCdcXG4nICsgbWVzc2FnZSwgc3RhY2submFtZSk7XG5cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHJlc3VsdC5vdXRwdXRzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcHJpbnQoJ1xcbk91dHB1dHM6Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMocmVzdWx0Lm91dHB1dHMpKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSByZXN1bHQub3V0cHV0c1tuYW1lXTtcbiAgICAgICAgICBwcmludCgnJXMuJXMgPSAlcycsIGNvbG9ycy5jeWFuKGRlcGxveU5hbWUpLCBjb2xvcnMuY3lhbihuYW1lKSwgY29sb3JzLnVuZGVybGluZShjb2xvcnMuY3lhbih2YWx1ZSkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByaW50KCdcXG5TdGFjayBBUk46Jyk7XG5cbiAgICAgICAgZGF0YShyZXN1bHQuc3RhY2tBcm4pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvcignXFxuIOKdjCAgJXMgZmFpbGVkOiAlcycsIGNvbG9ycy5ib2xkKHN0YWNrLm5hbWUpLCBlKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBjbGlEZXN0cm95KHN0YWNrTmFtZXM6IHN0cmluZ1tdLCBmb3JjZTogYm9vbGVhbiwgcm9sZUFybjogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gICAgY29uc3Qgc3RhY2tzID0gYXdhaXQgYXBwU3RhY2tzLnNlbGVjdFN0YWNrcyguLi5zdGFja05hbWVzKTtcbiAgICByZW5hbWVzLnZhbGlkYXRlU2VsZWN0ZWRTdGFja3Moc3RhY2tzKTtcblxuICAgIGlmICghZm9yY2UpIHtcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbiAgICAgIGNvbnN0IGNvbmZpcm1lZCA9IGF3YWl0IGNvbmZpcm0oYEFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBkZWxldGU6ICR7Y29sb3JzLmJsdWUoc3RhY2tzLm1hcChzID0+IHMubmFtZSkuam9pbignLCAnKSl9ICh5L24pP2ApO1xuICAgICAgaWYgKCFjb25maXJtZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3Qgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgICBjb25zdCBkZXBsb3lOYW1lID0gcmVuYW1lcy5maW5hbE5hbWUoc3RhY2submFtZSk7XG5cbiAgICAgIHN1Y2Nlc3MoJyVzOiBkZXN0cm95aW5nLi4uJywgY29sb3JzLmJsdWUoZGVwbG95TmFtZSkpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZGVzdHJveVN0YWNrKHsgc3RhY2ssIHNkazogYXdzLCBkZXBsb3lOYW1lLCByb2xlQXJuIH0pO1xuICAgICAgICBzdWNjZXNzKCdcXG4g4pyFICAlczogZGVzdHJveWVkJywgY29sb3JzLmJsdWUoZGVwbG95TmFtZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvcignXFxuIOKdjCAgJXM6IGRlc3Ryb3kgZmFpbGVkJywgY29sb3JzLmJsdWUoZGVwbG95TmFtZSksIGUpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGRpZmZTdGFjayhzdGFja05hbWU6IHN0cmluZywgdGVtcGxhdGVQYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQsIHN0cmljdDogYm9vbGVhbik6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgY29uc3Qgc3RhY2sgPSBhd2FpdCBhcHBTdGFja3Muc3ludGhlc2l6ZVN0YWNrKHN0YWNrTmFtZSk7XG4gICAgY29uc3QgY3VycmVudFRlbXBsYXRlID0gYXdhaXQgcmVhZEN1cnJlbnRUZW1wbGF0ZShzdGFjaywgdGVtcGxhdGVQYXRoKTtcbiAgICBpZiAocHJpbnRTdGFja0RpZmYoY3VycmVudFRlbXBsYXRlLCBzdGFjaywgc3RyaWN0KSA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHJlYWRDdXJyZW50VGVtcGxhdGUoc3RhY2s6IGN4YXBpLlN5bnRoZXNpemVkU3RhY2ssIHRlbXBsYXRlUGF0aD86IHN0cmluZyk6IFByb21pc2U8eyBba2V5OiBzdHJpbmddOiBhbnkgfT4ge1xuICAgIGlmICh0ZW1wbGF0ZVBhdGgpIHtcbiAgICAgIGlmICghYXdhaXQgZnMucGF0aEV4aXN0cyh0ZW1wbGF0ZVBhdGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgaXMgbm8gZmlsZSBhdCAke3RlbXBsYXRlUGF0aH1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpbGVDb250ZW50ID0gYXdhaXQgZnMucmVhZEZpbGUodGVtcGxhdGVQYXRoLCB7IGVuY29kaW5nOiAnVVRGLTgnIH0pO1xuICAgICAgcmV0dXJuIHBhcnNlVGVtcGxhdGUoZmlsZUNvbnRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdGFja05hbWUgPSByZW5hbWVzLmZpbmFsTmFtZShzdGFjay5uYW1lKTtcbiAgICAgIGRlYnVnKGBSZWFkaW5nIGV4aXN0aW5nIHRlbXBsYXRlIGZvciBzdGFjayAke3N0YWNrTmFtZX0uYCk7XG5cbiAgICAgIGNvbnN0IGNmbiA9IGF3YWl0IGF3cy5jbG91ZEZvcm1hdGlvbihzdGFjay5lbnZpcm9ubWVudCwgTW9kZS5Gb3JSZWFkaW5nKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2ZuLmdldFRlbXBsYXRlKHsgU3RhY2tOYW1lOiBzdGFja05hbWUgfSkucHJvbWlzZSgpO1xuICAgICAgICByZXR1cm4gKHJlc3BvbnNlLlRlbXBsYXRlQm9keSAmJiBwYXJzZVRlbXBsYXRlKHJlc3BvbnNlLlRlbXBsYXRlQm9keSkpIHx8IHt9O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS5jb2RlID09PSAnVmFsaWRhdGlvbkVycm9yJyAmJiBlLm1lc3NhZ2UgPT09IGBTdGFjayB3aXRoIGlkICR7c3RhY2tOYW1lfSBkb2VzIG5vdCBleGlzdGApIHtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qIEF0dGVtcHQgdG8gcGFyc2UgWUFNTCwgZmFsbCBiYWNrIHRvIEpTT04uICovXG4gICAgZnVuY3Rpb24gcGFyc2VUZW1wbGF0ZSh0ZXh0OiBzdHJpbmcpOiBhbnkge1xuICAgICAgcmV0dXJuIGRlc2VyaWFsaXplU3RydWN0dXJlKHRleHQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYXRjaCBhIHNpbmdsZSBzdGFjayBmcm9tIHRoZSBsaXN0IG9mIGF2YWlsYWJsZSBzdGFja3NcbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIGZpbmRTdGFjayhuYW1lOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IHN0YWNrcyA9IGF3YWl0IGFwcFN0YWNrcy5zZWxlY3RTdGFja3MobmFtZSk7XG5cbiAgICAvLyBDb3VsZCBoYXZlIGJlZW4gYSBnbG9iIHNvIGNoZWNrIHRoYXQgd2UgZXZhbHVhdGVkIHRvIGV4YWN0bHkgb25lXG4gICAgaWYgKHN0YWNrcy5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgY29tbWFuZCByZXF1aXJlcyBleGFjdGx5IG9uZSBzdGFjayBhbmQgd2UgbWF0Y2hlZCBtb3JlIHRoYW4gb25lOiAke3N0YWNrcy5tYXAoeCA9PiB4Lm5hbWUpfWApO1xuICAgIH1cblxuICAgIHJldHVybiBzdGFja3NbMF0ubmFtZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvSnNvbk9yWWFtbChvYmplY3Q6IGFueSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZVN0cnVjdHVyZShvYmplY3QsIGFyZ3YuanNvbik7XG4gIH1cbn1cblxuaW5pdENvbW1hbmRMaW5lKClcbiAgLnRoZW4odmFsdWUgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7IHJldHVybjsgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBkYXRhKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHByb2Nlc3MuZXhpdCh2YWx1ZSk7XG4gICAgfVxuICB9KVxuICAuY2F0Y2goZXJyID0+IHtcbiAgICBlcnJvcihlcnIubWVzc2FnZSk7XG4gICAgZGVidWcoZXJyLnN0YWNrKTtcbiAgICBwcm9jZXNzLmV4aXQoMSk7XG4gIH0pO1xuIl19
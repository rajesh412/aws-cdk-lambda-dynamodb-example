"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("./types");
/**
 * Return a new object by adding missing keys into another object
 */
function applyDefaults(hash, defaults) {
    const result = {};
    Object.keys(hash).forEach(k => result[k] = hash[k]);
    Object.keys(defaults)
        .filter(k => !(k in result))
        .forEach(k => result[k] = defaults[k]);
    return result;
}
exports.applyDefaults = applyDefaults;
/**
 * Return whether the given parameter is an empty object or empty list.
 */
function isEmpty(x) {
    if (x == null) {
        return false;
    }
    if (types_1.isArray(x)) {
        return x.length === 0;
    }
    return Object.keys(x).length === 0;
}
exports.isEmpty = isEmpty;
/**
 * Deep clone a tree of objects, lists or scalars
 *
 * Does not support cycles.
 */
function deepClone(x) {
    if (typeof x === 'undefined') {
        return undefined;
    }
    if (x === null) {
        return null;
    }
    if (types_1.isArray(x)) {
        return x.map(deepClone);
    }
    if (types_1.isObject(x)) {
        return makeObject(mapObject(x, (k, v) => [k, deepClone(v)]));
    }
    return x;
}
exports.deepClone = deepClone;
/**
 * Map over an object, treating it as a dictionary
 */
function mapObject(x, fn) {
    const ret = [];
    Object.keys(x).forEach(key => {
        ret.push(fn(key, x[key]));
    });
    return ret;
}
exports.mapObject = mapObject;
/**
 * Construct an object from a list of (k, v) pairs
 */
function makeObject(pairs) {
    const ret = {};
    for (const pair of pairs) {
        ret[pair[0]] = pair[1];
    }
    return ret;
}
exports.makeObject = makeObject;
/**
 * Deep get a value from a tree of nested objects
 *
 * Returns undefined if any part of the path was unset or
 * not an object.
 */
function deepGet(x, path) {
    path = path.slice();
    while (path.length > 0 && types_1.isObject(x)) {
        const key = path.shift();
        x = x[key];
    }
    return path.length === 0 ? x : undefined;
}
exports.deepGet = deepGet;
/**
 * Deep set a value in a tree of nested objects
 *
 * Throws an error if any part of the path is not an object.
 */
function deepSet(x, path, value) {
    path = path.slice();
    if (path.length === 0) {
        throw new Error('Path may not be empty');
    }
    while (path.length > 1 && types_1.isObject(x)) {
        const key = path.shift();
        if (!(key in x)) {
            x[key] = {};
        }
        x = x[key];
    }
    if (!types_1.isObject(x)) {
        throw new Error(`Expected an object, got '${x}'`);
    }
    x[path[0]] = value;
}
exports.deepSet = deepSet;
/**
 * Recursively merge objects together
 *
 * The leftmost object is mutated and returned. Arrays are not merged
 * but overwritten just like scalars.
 *
 * If an object is merged into a non-object, the non-object is lost.
 */
function deepMerge(...objects) {
    function mergeOne(target, source) {
        for (const key of Object.keys(source)) {
            const value = source[key];
            if (types_1.isObject(value)) {
                if (!types_1.isObject(target[key])) {
                    target[key] = {};
                } // Overwrite on purpose
                mergeOne(target[key], value);
            }
            else if (typeof value !== 'undefined') {
                target[key] = value;
            }
        }
    }
    const others = objects.filter(x => x != null);
    if (others.length === 0) {
        return {};
    }
    const into = others.splice(0, 1)[0];
    others.forEach(other => mergeOne(into, other));
    return into;
}
exports.deepMerge = deepMerge;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2JqZWN0cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm9iamVjdHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxtQ0FBaUQ7QUFFakQ7O0dBRUc7QUFDSCxTQUFnQixhQUFhLENBQUMsSUFBUyxFQUFFLFFBQWE7SUFDcEQsTUFBTSxNQUFNLEdBQVEsRUFBRyxDQUFDO0lBRXhCLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRXBELE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDO1NBQ2xCLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLENBQUM7U0FDM0IsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRXpDLE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUM7QUFWRCxzQ0FVQztBQUVEOztHQUVHO0FBQ0gsU0FBZ0IsT0FBTyxDQUFDLENBQU07SUFDNUIsSUFBSSxDQUFDLElBQUksSUFBSSxFQUFFO1FBQUUsT0FBTyxLQUFLLENBQUM7S0FBRTtJQUNoQyxJQUFJLGVBQU8sQ0FBQyxDQUFDLENBQUMsRUFBRTtRQUFFLE9BQU8sQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUM7S0FBRTtJQUMxQyxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQztBQUNyQyxDQUFDO0FBSkQsMEJBSUM7QUFFRDs7OztHQUlHO0FBQ0gsU0FBZ0IsU0FBUyxDQUFDLENBQU07SUFDOUIsSUFBSSxPQUFPLENBQUMsS0FBSyxXQUFXLEVBQUU7UUFBRSxP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LENBQUM7QUFDZCxDQUFDO0FBckJELDhCQXFCQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzQXJyYXksIGlzT2JqZWN0LCBPYmogfSBmcm9tICcuL3R5cGVzJztcblxuLyoqXG4gKiBSZXR1cm4gYSBuZXcgb2JqZWN0IGJ5IGFkZGluZyBtaXNzaW5nIGtleXMgaW50byBhbm90aGVyIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlEZWZhdWx0cyhoYXNoOiBhbnksIGRlZmF1bHRzOiBhbnkpIHtcbiAgY29uc3QgcmVzdWx0OiBhbnkgPSB7IH07XG5cbiAgT2JqZWN0LmtleXMoaGFzaCkuZm9yRWFjaChrID0+IHJlc3VsdFtrXSA9IGhhc2hba10pO1xuXG4gIE9iamVjdC5rZXlzKGRlZmF1bHRzKVxuICAgIC5maWx0ZXIoayA9PiAhKGsgaW4gcmVzdWx0KSlcbiAgICAuZm9yRWFjaChrID0+IHJlc3VsdFtrXSA9IGRlZmF1bHRzW2tdKTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIHRoZSBnaXZlbiBwYXJhbWV0ZXIgaXMgYW4gZW1wdHkgb2JqZWN0IG9yIGVtcHR5IGxpc3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5KHg6IGFueSkge1xuICBpZiAoeCA9PSBudWxsKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoaXNBcnJheSh4KSkgeyByZXR1cm4geC5sZW5ndGggPT09IDA7IH1cbiAgcmV0dXJuIE9iamVjdC5rZXlzKHgpLmxlbmd0aCA9PT0gMDtcbn1cblxuLyoqXG4gKiBEZWVwIGNsb25lIGEgdHJlZSBvZiBvYmplY3RzLCBsaXN0cyBvciBzY2FsYXJzXG4gKlxuICogRG9lcyBub3Qgc3VwcG9ydCBjeWNsZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWVwQ2xvbmUoeDogYW55KTogYW55IHtcbiAgaWYgKHR5cGVvZiB4ID09PSAndW5kZWZpbmVkJykgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gIGlmICh4ID09PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG4gIGlmIChpc0FycmF5KHgpKSB7IHJldHVybiB4Lm1hcChkZWVwQ2xvbmUpOyB9XG4gIGlmIChpc09iamVjdCh4KSkgeyByZXR1cm4gbWFrZU9iamVjdChtYXBPYmplY3QoeCwgKGssIHYpID0+IFtrLCBkZWVwQ2xvbmUodildIGFzIFtzdHJpbmcsIGFueV0pKTsgfVxuICByZXR1cm4geDtcbn1cblxuLyoqXG4gKiBNYXAgb3ZlciBhbiBvYmplY3QsIHRyZWF0aW5nIGl0IGFzIGEgZGljdGlvbmFyeVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwT2JqZWN0PFQsIFU+KHg6IE9iajxUPiwgZm46IChrZXk6IHN0cmluZywgdmFsdWU6IFQpID0+IFUpOiBVW10ge1xuICBjb25zdCByZXQ6IFVbXSA9IFtdO1xuICBPYmplY3Qua2V5cyh4KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgcmV0LnB1c2goZm4oa2V5LCB4W2tleV0pKTtcbiAgfSk7XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogQ29uc3RydWN0IGFuIG9iamVjdCBmcm9tIGEgbGlzdCBvZiAoaywgdikgcGFpcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VPYmplY3Q8VD4ocGFpcnM6IEFycmF5PFtzdHJpbmcsIFRdPik6IE9iajxUPiB7XG4gIGNvbnN0IHJldDogT2JqPFQ+ID0ge307XG4gIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgIHJldFtwYWlyWzBdXSA9IHBhaXJbMV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBEZWVwIGdldCBhIHZhbHVlIGZyb20gYSB0cmVlIG9mIG5lc3RlZCBvYmplY3RzXG4gKlxuICogUmV0dXJucyB1bmRlZmluZWQgaWYgYW55IHBhcnQgb2YgdGhlIHBhdGggd2FzIHVuc2V0IG9yXG4gKiBub3QgYW4gb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVlcEdldCh4OiBhbnksIHBhdGg6IHN0cmluZ1tdKTogYW55IHtcbiAgcGF0aCA9IHBhdGguc2xpY2UoKTtcblxuICB3aGlsZSAocGF0aC5sZW5ndGggPiAwICYmIGlzT2JqZWN0KHgpKSB7XG4gICAgY29uc3Qga2V5ID0gcGF0aC5zaGlmdCgpITtcbiAgICB4ID0geFtrZXldO1xuICB9XG4gIHJldHVybiBwYXRoLmxlbmd0aCA9PT0gMCA/IHggOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogRGVlcCBzZXQgYSB2YWx1ZSBpbiBhIHRyZWUgb2YgbmVzdGVkIG9iamVjdHNcbiAqXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgYW55IHBhcnQgb2YgdGhlIHBhdGggaXMgbm90IGFuIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBTZXQoeDogYW55LCBwYXRoOiBzdHJpbmdbXSwgdmFsdWU6IGFueSkge1xuICBwYXRoID0gcGF0aC5zbGljZSgpO1xuXG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGF0aCBtYXkgbm90IGJlIGVtcHR5Jyk7XG4gIH1cblxuICB3aGlsZSAocGF0aC5sZW5ndGggPiAxICYmIGlzT2JqZWN0KHgpKSB7XG4gICAgY29uc3Qga2V5ID0gcGF0aC5zaGlmdCgpITtcbiAgICBpZiAoIShrZXkgaW4geCkpIHsgeFtrZXldID0ge307IH1cbiAgICB4ID0geFtrZXldO1xuICB9XG5cbiAgaWYgKCFpc09iamVjdCh4KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYW4gb2JqZWN0LCBnb3QgJyR7eH0nYCk7XG4gIH1cblxuICB4W3BhdGhbMF1dID0gdmFsdWU7XG59XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyB0b2dldGhlclxuICpcbiAqIFRoZSBsZWZ0bW9zdCBvYmplY3QgaXMgbXV0YXRlZCBhbmQgcmV0dXJuZWQuIEFycmF5cyBhcmUgbm90IG1lcmdlZFxuICogYnV0IG92ZXJ3cml0dGVuIGp1c3QgbGlrZSBzY2FsYXJzLlxuICpcbiAqIElmIGFuIG9iamVjdCBpcyBtZXJnZWQgaW50byBhIG5vbi1vYmplY3QsIHRoZSBub24tb2JqZWN0IGlzIGxvc3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWVwTWVyZ2UoLi4ub2JqZWN0czogQXJyYXk8T2JqPGFueT4gfCB1bmRlZmluZWQ+KSB7XG4gIGZ1bmN0aW9uIG1lcmdlT25lKHRhcmdldDogT2JqPGFueT4sIHNvdXJjZTogT2JqPGFueT4pIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzb3VyY2UpKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuXG4gICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIGlmICghaXNPYmplY3QodGFyZ2V0W2tleV0pKSB7IHRhcmdldFtrZXldID0ge307IH0gLy8gT3ZlcndyaXRlIG9uIHB1cnBvc2VcbiAgICAgICAgbWVyZ2VPbmUodGFyZ2V0W2tleV0sIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG90aGVycyA9IG9iamVjdHMuZmlsdGVyKHggPT4geCAhPSBudWxsKSBhcyBBcnJheTxPYmo8YW55Pj47XG5cbiAgaWYgKG90aGVycy5sZW5ndGggPT09IDApIHsgcmV0dXJuIHt9OyB9XG4gIGNvbnN0IGludG8gPSBvdGhlcnMuc3BsaWNlKDAsIDEpWzBdO1xuXG4gIG90aGVycy5mb3JFYWNoKG90aGVyID0+IG1lcmdlT25lKGludG8sIG90aGVyKSk7XG4gIHJldHVybiBpbnRvO1xufVxuIl19
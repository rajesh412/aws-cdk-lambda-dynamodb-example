"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto = require("crypto");
const logging_1 = require("./logging");
const os_1 = require("./os");
const please_hold_1 = require("./util/please-hold");
/**
 * Build and upload a Docker image
 *
 * Permanently identifying images is a bit of a bust. Newer Docker version use
 * a digest (sha256:xxxx) as an image identifier, which is pretty good to avoid
 * spurious rebuilds. However, this digest is calculated over a manifest that
 * includes metadata that is liable to change. For example, as soon as we
 * push the Docker image to a repository, the digest changes. This makes the
 * digest worthless to determe whether we already pushed an image, for example.
 *
 * As a workaround, we calculate our own digest over parts of the manifest that
 * are unlikely to change, and tag based on that.
 */
async function prepareContainerAsset(asset, toolkitInfo) {
    logging_1.debug(' ðŸ‘‘  Preparing Docker image asset:', asset.path);
    const buildHold = new please_hold_1.PleaseHold(` âŒ› Building Docker image for ${asset.path}; this may take a while.`);
    try {
        buildHold.start();
        const command = ['docker',
            'build',
            '--quiet',
            asset.path];
        const imageId = (await os_1.shell(command, { quiet: true })).trim();
        buildHold.stop();
        const tag = await calculateImageFingerprint(imageId);
        logging_1.debug(` âŒ›  Image has tag ${tag}, preparing ECR repository`);
        const ecr = await toolkitInfo.prepareEcrRepository(asset.id, tag);
        if (ecr.alreadyExists) {
            logging_1.debug(' ðŸ‘‘  Image already uploaded.');
        }
        else {
            // Login and push
            logging_1.debug(` âŒ›  Image needs to be uploaded first.`);
            await os_1.shell(['docker', 'login',
                '--username', ecr.username,
                '--password', ecr.password,
                ecr.endpoint]);
            const qualifiedImageName = `${ecr.repositoryUri}:${tag}`;
            await os_1.shell(['docker', 'tag', imageId, qualifiedImageName]);
            // There's no way to make this quiet, so we can't use a PleaseHold. Print a header message.
            logging_1.print(` âŒ› Pusing Docker image for ${asset.path}; this may take a while.`);
            await os_1.shell(['docker', 'push', qualifiedImageName]);
            logging_1.debug(` ðŸ‘‘  Docker image for ${asset.path} pushed.`);
        }
        return [
            { ParameterKey: asset.imageNameParameter, ParameterValue: `${ecr.repositoryName}:${tag}` },
        ];
    }
    catch (e) {
        if (e.code === 'ENOENT') {
            // tslint:disable-next-line:max-line-length
            throw new Error('Error building Docker image asset; you need to have Docker installed in order to be able to build image assets. Please install Docker and try again.');
        }
        throw e;
    }
    finally {
        buildHold.stop();
    }
}
exports.prepareContainerAsset = prepareContainerAsset;
/**
 * Calculate image fingerprint.
 *
 * The fingerprint has a high likelihood to be the same across repositories.
 * (As opposed to Docker's built-in image digest, which changes as soon
 * as the image is uploaded since it includes the tags that an image has).
 *
 * The fingerprint will be used as a tag to identify a particular image.
 */
async function calculateImageFingerprint(imageId) {
    const manifestString = await os_1.shell(['docker', 'inspect', imageId], { quiet: true });
    const manifest = JSON.parse(manifestString)[0];
    // Id can change
    delete manifest.Id;
    // Repository-based identifiers are out
    delete manifest.RepoTags;
    delete manifest.RepoDigests;
    // Metadata that has no bearing on the image contents
    delete manifest.Created;
    // We're interested in the image itself, not any running instaces of it
    delete manifest.Container;
    delete manifest.ContainerConfig;
    // We're not interested in the Docker version used to create this image
    delete manifest.DockerVersion;
    return crypto.createHash('sha256').update(JSON.stringify(manifest)).digest('hex');
}
/**
 * Example of a Docker manifest
 *
 * [
 *     {
 *         "Id": "sha256:3a90542991d03007fd1d8f3b3a6ab04ebb02386785430fe48a867768a048d828",
 *         "RepoTags": [
 *             "993655754359.dkr.ecr.us-east-1.amazonaws.com/cdk/awsecsintegimage7c15b8c6:latest"
 *         ],
 *         "RepoDigests": [
 *             "993655754359.dkr.ecr.us-east-1.amazo....5e50c0cfc3f2355191934b05df68cd3339a044959111ffec2e14765"
 *         ],
 *         "Parent": "sha256:465720f8f43c9c0aff5dcc731d4e368a3927cae4e885442d4ba0bf8a867b7561",
 *         "Comment": "",
 *         "Created": "2018-10-17T10:16:40.775888476Z",
 *         "Container": "20f145d2e7fbf126ca9f4422497b932bc96b5faa038dc032de1e246f64e03a66",
 *         "ContainerConfig": {
 *             "Hostname": "9b48b580a312",
 *             "Domainname": "",
 *             "User": "",
 *             "AttachStdin": false,
 *             "AttachStdout": false,
 *             "AttachStderr": false,
 *             "ExposedPorts": {
 *                 "8000/tcp": {}
 *             },
 *             "Tty": false,
 *             "OpenStdin": false,
 *             "StdinOnce": false,
 *             "Env": [
 *                 "PATH=/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
 *                 "LANG=C.UTF-8",
 *                 "GPG_KEY=0D96DF4D4110E5C43FBFB17F2D347EA6AA65421D",
 *                 "PYTHON_VERSION=3.6.6",
 *                 "PYTHON_PIP_VERSION=18.1"
 *             ],
 *             "Cmd": [
 *                 "/bin/sh",
 *                 "-c",
 *                 "#(nop) ",
 *                 "CMD [\"/bin/sh\" \"-c\" \"python3 index.py\"]"
 *             ],
 *             "ArgsEscaped": true,
 *             "Image": "sha256:465720f8f43c9c0aff5dcc731d4e368a3927cae4e885442d4ba0bf8a867b7561",
 *             "Volumes": null,
 *             "WorkingDir": "/code",
 *             "Entrypoint": null,
 *             "OnBuild": [],
 *             "Labels": {}
 *         },
 *         "DockerVersion": "17.03.2-ce",
 *         "Author": "",
 *         "Config": {
 *             "Hostname": "9b48b580a312",
 *             "Domainname": "",
 *             "User": "",
 *             "AttachStdin": false,
 *             "AttachStdout": false,
 *             "AttachStderr": false,
 *             "ExposedPorts": {
 *                 "8000/tcp": {}
 *             },
 *             "Tty": false,
 *             "OpenStdin": false,
 *             "StdinOnce": false,
 *             "Env": [
 *                 "PATH=/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
 *                 "LANG=C.UTF-8",
 *                 "GPG_KEY=0D96DF4D4110E5C43FBFB17F2D347EA6AA65421D",
 *                 "PYTHON_VERSION=3.6.6",
 *                 "PYTHON_PIP_VERSION=18.1"
 *             ],
 *             "Cmd": [
 *                 "/bin/sh",
 *                 "-c",
 *                 "python3 index.py"
 *             ],
 *             "ArgsEscaped": true,
 *             "Image": "sha256:465720f8f43c9c0aff5dcc731d4e368a3927cae4e885442d4ba0bf8a867b7561",
 *             "Volumes": null,
 *             "WorkingDir": "/code",
 *             "Entrypoint": null,
 *             "OnBuild": [],
 *             "Labels": {}
 *         },
 *         "Architecture": "amd64",
 *         "Os": "linux",
 *         "Size": 917730468,
 *         "VirtualSize": 917730468,
 *         "GraphDriver": {
 *             "Name": "aufs",
 *             "Data": null
 *         },
 *         "RootFS": {
 *             "Type": "layers",
 *             "Layers": [
 *                 "sha256:f715ed19c28b66943ac8bc12dbfb828e8394de2530bbaf1ecce906e748e4fdff",
 *                 "sha256:8bb25f9cdc41e7d085033af15a522973b44086d6eedd24c11cc61c9232324f77",
 *                 "sha256:08a01612ffca33483a1847c909836610610ce523fb7e1aca880140ee84df23e9",
 *                 "sha256:1191b3f5862aa9231858809b7ac8b91c0b727ce85c9b3279932f0baacc92967d",
 *                 "sha256:9978d084fd771e0b3d1acd7f3525d1b25288ababe9ad8ed259b36101e4e3addd",
 *                 "sha256:2f4f74d3821ecbdd60b5d932452ea9e30cecf902334165c4a19837f6ee636377",
 *                 "sha256:003bb6178bc3218242d73e51d5e9ab2f991dc607780194719c6bd4c8c412fe8c",
 *                 "sha256:15b32d849da2239b1af583f9381c7a75d7aceba12f5ddfffa7a059116cf05ab9",
 *                 "sha256:6e5c5f6bf043bc634378b1e4b61af09be74741f2ac80204d7a373713b1fd5a40",
 *                 "sha256:3260e00e353bfb765b25597d13868c2ef64cb3d509875abcfb58c4e9bf7f4ee2",
 *                 "sha256:f3274b75856311e92e14a1270c78737c86456d6353fe4a83bd2e81bcd2a996ea"
 *             ]
 *         }
 *     }
 * ]
 */
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG9ja2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZG9ja2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUEsaUNBQWtDO0FBRWxDLHVDQUF5QztBQUN6Qyw2QkFBNkI7QUFDN0Isb0RBQWdEO0FBRWhEOzs7Ozs7Ozs7Ozs7R0FZRztBQUNJLEtBQUssVUFBVSxxQkFBcUIsQ0FBQyxLQUF1QyxFQUFFLFdBQXdCO0lBQzNHLGVBQUssQ0FBQyxvQ0FBb0MsRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFeEQsTUFBTSxTQUFTLEdBQUcsSUFBSSx3QkFBVSxDQUFDLGdDQUFnQyxLQUFLLENBQUMsSUFBSSwwQkFBMEIsQ0FBQyxDQUFDO0lBQ3ZHLElBQUk7UUFDRixTQUFTLENBQUMsS0FBSyxFQUFFLENBQUM7UUFFbEIsTUFBTSxPQUFPLEdBQUcsQ0FBQyxRQUFRO1lBQ3ZCLE9BQU87WUFDUCxTQUFTO1lBQ1QsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2QsTUFBTSxPQUFPLEdBQUcsQ0FBQyxNQUFNLFVBQUssQ0FBQyxPQUFPLEVBQUUsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQy9ELFNBQVMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUVqQixNQUFNLEdBQUcsR0FBRyxNQUFNLHlCQUF5QixDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRXJELGVBQUssQ0FBQyxxQkFBcUIsR0FBRyw0QkFBNEIsQ0FBQyxDQUFDO1FBQzVELE1BQU0sR0FBRyxHQUFHLE1BQU0sV0FBVyxDQUFDLG9CQUFvQixDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFFbEUsSUFBSSxHQUFHLENBQUMsYUFBYSxFQUFFO1lBQ3JCLGVBQUssQ0FBQyw4QkFBOEIsQ0FBQyxDQUFDO1NBQ3ZDO2FBQU07WUFDTCxpQkFBaUI7WUFDakIsZUFBSyxDQUFDLHVDQUF1QyxDQUFDLENBQUM7WUFFL0MsTUFBTSxVQUFLLENBQUMsQ0FBQyxRQUFRLEVBQUUsT0FBTztnQkFDNUIsWUFBWSxFQUFFLEdBQUcsQ0FBQyxRQUFRO2dCQUMxQixZQUFZLEVBQUUsR0FBRyxDQUFDLFFBQVE7Z0JBQzFCLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBRWpCLE1BQU0sa0JBQWtCLEdBQUcsR0FBRyxHQUFHLENBQUMsYUFBYSxJQUFJLEdBQUcsRUFBRSxDQUFDO1lBQ3pELE1BQU0sVUFBSyxDQUFDLENBQUMsUUFBUSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsa0JBQWtCLENBQUMsQ0FBQyxDQUFDO1lBRTVELDJGQUEyRjtZQUMzRixlQUFLLENBQUMsOEJBQThCLEtBQUssQ0FBQyxJQUFJLDBCQUEwQixDQUFDLENBQUM7WUFDMUUsTUFBTSxVQUFLLENBQUMsQ0FBQyxRQUFRLEVBQUUsTUFBTSxFQUFFLGtCQUFrQixDQUFDLENBQUMsQ0FBQztZQUNwRCxlQUFLLENBQUMseUJBQXlCLEtBQUssQ0FBQyxJQUFJLFVBQVUsQ0FBQyxDQUFDO1NBQ3REO1FBRUQsT0FBTztZQUNMLEVBQUUsWUFBWSxFQUFFLEtBQUssQ0FBQyxrQkFBa0IsRUFBRSxjQUFjLEVBQUUsR0FBRyxHQUFHLENBQUMsY0FBYyxJQUFJLEdBQUcsRUFBRSxFQUFFO1NBQzNGLENBQUM7S0FDSDtJQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ1YsSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLFFBQVEsRUFBRTtZQUN2QiwyQ0FBMkM7WUFDM0MsTUFBTSxJQUFJLEtBQUssQ0FBQyxzSkFBc0osQ0FBQyxDQUFDO1NBQ3pLO1FBQ0QsTUFBTSxDQUFDLENBQUM7S0FDVDtZQUFTO1FBQ1IsU0FBUyxDQUFDLElBQUksRUFBRSxDQUFDO0tBQ2xCO0FBQ0gsQ0FBQztBQW5ERCxzREFtREM7QUFFRDs7Ozs7Ozs7R0FRRztBQUNILEtBQUssVUFBVSx5QkFBeUIsQ0FBQyxPQUFlO0lBQ3RELE1BQU0sY0FBYyxHQUFHLE1BQU0sVUFBSyxDQUFDLENBQUMsUUFBUSxFQUFFLFNBQVMsRUFBRSxPQUFPLENBQUMsRUFBRSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQ3BGLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFL0MsZ0JBQWdCO0lBQ2hCLE9BQU8sUUFBUSxDQUFDLEVBQUUsQ0FBQztJQUVuQix1Q0FBdUM7SUFDdkMsT0FBTyxRQUFRLENBQUMsUUFBUSxDQUFDO0lBQ3pCLE9BQU8sUUFBUSxDQUFDLFdBQVcsQ0FBQztJQUU1QixxREFBcUQ7SUFDckQsT0FBTyxRQUFRLENBQUMsT0FBTyxDQUFDO0lBRXhCLHVFQUF1RTtJQUN2RSxPQUFPLFFBQVEsQ0FBQyxTQUFTLENBQUM7SUFDMUIsT0FBTyxRQUFRLENBQUMsZUFBZSxDQUFDO0lBRWhDLHVFQUF1RTtJQUN2RSxPQUFPLFFBQVEsQ0FBQyxhQUFhLENBQUM7SUFFOUIsT0FBTyxNQUFNLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3BGLENBQUM7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBK0dHIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29udGFpbmVySW1hZ2VBc3NldE1ldGFkYXRhRW50cnkgfSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0IHsgQ2xvdWRGb3JtYXRpb24gfSBmcm9tICdhd3Mtc2RrJztcbmltcG9ydCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmltcG9ydCB7IFRvb2xraXRJbmZvIH0gZnJvbSAnLi9hcGkvdG9vbGtpdC1pbmZvJztcbmltcG9ydCB7IGRlYnVnLCBwcmludCB9IGZyb20gJy4vbG9nZ2luZyc7XG5pbXBvcnQgeyBzaGVsbCB9IGZyb20gJy4vb3MnO1xuaW1wb3J0IHsgUGxlYXNlSG9sZCB9IGZyb20gJy4vdXRpbC9wbGVhc2UtaG9sZCc7XG5cbi8qKlxuICogQnVpbGQgYW5kIHVwbG9hZCBhIERvY2tlciBpbWFnZVxuICpcbiAqIFBlcm1hbmVudGx5IGlkZW50aWZ5aW5nIGltYWdlcyBpcyBhIGJpdCBvZiBhIGJ1c3QuIE5ld2VyIERvY2tlciB2ZXJzaW9uIHVzZVxuICogYSBkaWdlc3QgKHNoYTI1Njp4eHh4KSBhcyBhbiBpbWFnZSBpZGVudGlmaWVyLCB3aGljaCBpcyBwcmV0dHkgZ29vZCB0byBhdm9pZFxuICogc3B1cmlvdXMgcmVidWlsZHMuIEhvd2V2ZXIsIHRoaXMgZGlnZXN0IGlzIGNhbGN1bGF0ZWQgb3ZlciBhIG1hbmlmZXN0IHRoYXRcbiAqIGluY2x1ZGVzIG1ldGFkYXRhIHRoYXQgaXMgbGlhYmxlIHRvIGNoYW5nZS4gRm9yIGV4YW1wbGUsIGFzIHNvb24gYXMgd2VcbiAqIHB1c2ggdGhlIERvY2tlciBpbWFnZSB0byBhIHJlcG9zaXRvcnksIHRoZSBkaWdlc3QgY2hhbmdlcy4gVGhpcyBtYWtlcyB0aGVcbiAqIGRpZ2VzdCB3b3J0aGxlc3MgdG8gZGV0ZXJtZSB3aGV0aGVyIHdlIGFscmVhZHkgcHVzaGVkIGFuIGltYWdlLCBmb3IgZXhhbXBsZS5cbiAqXG4gKiBBcyBhIHdvcmthcm91bmQsIHdlIGNhbGN1bGF0ZSBvdXIgb3duIGRpZ2VzdCBvdmVyIHBhcnRzIG9mIHRoZSBtYW5pZmVzdCB0aGF0XG4gKiBhcmUgdW5saWtlbHkgdG8gY2hhbmdlLCBhbmQgdGFnIGJhc2VkIG9uIHRoYXQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcmVwYXJlQ29udGFpbmVyQXNzZXQoYXNzZXQ6IENvbnRhaW5lckltYWdlQXNzZXRNZXRhZGF0YUVudHJ5LCB0b29sa2l0SW5mbzogVG9vbGtpdEluZm8pOiBQcm9taXNlPENsb3VkRm9ybWF0aW9uLlBhcmFtZXRlcltdPiB7XG4gIGRlYnVnKCcg8J+RkSAgUHJlcGFyaW5nIERvY2tlciBpbWFnZSBhc3NldDonLCBhc3NldC5wYXRoKTtcblxuICBjb25zdCBidWlsZEhvbGQgPSBuZXcgUGxlYXNlSG9sZChgIOKMmyBCdWlsZGluZyBEb2NrZXIgaW1hZ2UgZm9yICR7YXNzZXQucGF0aH07IHRoaXMgbWF5IHRha2UgYSB3aGlsZS5gKTtcbiAgdHJ5IHtcbiAgICBidWlsZEhvbGQuc3RhcnQoKTtcblxuICAgIGNvbnN0IGNvbW1hbmQgPSBbJ2RvY2tlcicsXG4gICAgICAnYnVpbGQnLFxuICAgICAgJy0tcXVpZXQnLFxuICAgICAgYXNzZXQucGF0aF07XG4gICAgY29uc3QgaW1hZ2VJZCA9IChhd2FpdCBzaGVsbChjb21tYW5kLCB7IHF1aWV0OiB0cnVlIH0pKS50cmltKCk7XG4gICAgYnVpbGRIb2xkLnN0b3AoKTtcblxuICAgIGNvbnN0IHRhZyA9IGF3YWl0IGNhbGN1bGF0ZUltYWdlRmluZ2VycHJpbnQoaW1hZ2VJZCk7XG5cbiAgICBkZWJ1ZyhgIOKMmyAgSW1hZ2UgaGFzIHRhZyAke3RhZ30sIHByZXBhcmluZyBFQ1IgcmVwb3NpdG9yeWApO1xuICAgIGNvbnN0IGVjciA9IGF3YWl0IHRvb2xraXRJbmZvLnByZXBhcmVFY3JSZXBvc2l0b3J5KGFzc2V0LmlkLCB0YWcpO1xuXG4gICAgaWYgKGVjci5hbHJlYWR5RXhpc3RzKSB7XG4gICAgICBkZWJ1ZygnIPCfkZEgIEltYWdlIGFscmVhZHkgdXBsb2FkZWQuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExvZ2luIGFuZCBwdXNoXG4gICAgICBkZWJ1ZyhgIOKMmyAgSW1hZ2UgbmVlZHMgdG8gYmUgdXBsb2FkZWQgZmlyc3QuYCk7XG5cbiAgICAgIGF3YWl0IHNoZWxsKFsnZG9ja2VyJywgJ2xvZ2luJyxcbiAgICAgICAgJy0tdXNlcm5hbWUnLCBlY3IudXNlcm5hbWUsXG4gICAgICAgICctLXBhc3N3b3JkJywgZWNyLnBhc3N3b3JkLFxuICAgICAgICBlY3IuZW5kcG9pbnRdKTtcblxuICAgICAgY29uc3QgcXVhbGlmaWVkSW1hZ2VOYW1lID0gYCR7ZWNyLnJlcG9zaXRvcnlVcml9OiR7dGFnfWA7XG4gICAgICBhd2FpdCBzaGVsbChbJ2RvY2tlcicsICd0YWcnLCBpbWFnZUlkLCBxdWFsaWZpZWRJbWFnZU5hbWVdKTtcblxuICAgICAgLy8gVGhlcmUncyBubyB3YXkgdG8gbWFrZSB0aGlzIHF1aWV0LCBzbyB3ZSBjYW4ndCB1c2UgYSBQbGVhc2VIb2xkLiBQcmludCBhIGhlYWRlciBtZXNzYWdlLlxuICAgICAgcHJpbnQoYCDijJsgUHVzaW5nIERvY2tlciBpbWFnZSBmb3IgJHthc3NldC5wYXRofTsgdGhpcyBtYXkgdGFrZSBhIHdoaWxlLmApO1xuICAgICAgYXdhaXQgc2hlbGwoWydkb2NrZXInLCAncHVzaCcsIHF1YWxpZmllZEltYWdlTmFtZV0pO1xuICAgICAgZGVidWcoYCDwn5GRICBEb2NrZXIgaW1hZ2UgZm9yICR7YXNzZXQucGF0aH0gcHVzaGVkLmApO1xuICAgIH1cblxuICAgIHJldHVybiBbXG4gICAgICB7IFBhcmFtZXRlcktleTogYXNzZXQuaW1hZ2VOYW1lUGFyYW1ldGVyLCBQYXJhbWV0ZXJWYWx1ZTogYCR7ZWNyLnJlcG9zaXRvcnlOYW1lfToke3RhZ31gIH0sXG4gICAgXTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGJ1aWxkaW5nIERvY2tlciBpbWFnZSBhc3NldDsgeW91IG5lZWQgdG8gaGF2ZSBEb2NrZXIgaW5zdGFsbGVkIGluIG9yZGVyIHRvIGJlIGFibGUgdG8gYnVpbGQgaW1hZ2UgYXNzZXRzLiBQbGVhc2UgaW5zdGFsbCBEb2NrZXIgYW5kIHRyeSBhZ2Fpbi4nKTtcbiAgICB9XG4gICAgdGhyb3cgZTtcbiAgfSBmaW5hbGx5IHtcbiAgICBidWlsZEhvbGQuc3RvcCgpO1xuICB9XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGltYWdlIGZpbmdlcnByaW50LlxuICpcbiAqIFRoZSBmaW5nZXJwcmludCBoYXMgYSBoaWdoIGxpa2VsaWhvb2QgdG8gYmUgdGhlIHNhbWUgYWNyb3NzIHJlcG9zaXRvcmllcy5cbiAqIChBcyBvcHBvc2VkIHRvIERvY2tlcidzIGJ1aWx0LWluIGltYWdlIGRpZ2VzdCwgd2hpY2ggY2hhbmdlcyBhcyBzb29uXG4gKiBhcyB0aGUgaW1hZ2UgaXMgdXBsb2FkZWQgc2luY2UgaXQgaW5jbHVkZXMgdGhlIHRhZ3MgdGhhdCBhbiBpbWFnZSBoYXMpLlxuICpcbiAqIFRoZSBmaW5nZXJwcmludCB3aWxsIGJlIHVzZWQgYXMgYSB0YWcgdG8gaWRlbnRpZnkgYSBwYXJ0aWN1bGFyIGltYWdlLlxuICovXG5hc3luYyBmdW5jdGlvbiBjYWxjdWxhdGVJbWFnZUZpbmdlcnByaW50KGltYWdlSWQ6IHN0cmluZykge1xuICBjb25zdCBtYW5pZmVzdFN0cmluZyA9IGF3YWl0IHNoZWxsKFsnZG9ja2VyJywgJ2luc3BlY3QnLCBpbWFnZUlkXSwgeyBxdWlldDogdHJ1ZSB9KTtcbiAgY29uc3QgbWFuaWZlc3QgPSBKU09OLnBhcnNlKG1hbmlmZXN0U3RyaW5nKVswXTtcblxuICAvLyBJZCBjYW4gY2hhbmdlXG4gIGRlbGV0ZSBtYW5pZmVzdC5JZDtcblxuICAvLyBSZXBvc2l0b3J5LWJhc2VkIGlkZW50aWZpZXJzIGFyZSBvdXRcbiAgZGVsZXRlIG1hbmlmZXN0LlJlcG9UYWdzO1xuICBkZWxldGUgbWFuaWZlc3QuUmVwb0RpZ2VzdHM7XG5cbiAgLy8gTWV0YWRhdGEgdGhhdCBoYXMgbm8gYmVhcmluZyBvbiB0aGUgaW1hZ2UgY29udGVudHNcbiAgZGVsZXRlIG1hbmlmZXN0LkNyZWF0ZWQ7XG5cbiAgLy8gV2UncmUgaW50ZXJlc3RlZCBpbiB0aGUgaW1hZ2UgaXRzZWxmLCBub3QgYW55IHJ1bm5pbmcgaW5zdGFjZXMgb2YgaXRcbiAgZGVsZXRlIG1hbmlmZXN0LkNvbnRhaW5lcjtcbiAgZGVsZXRlIG1hbmlmZXN0LkNvbnRhaW5lckNvbmZpZztcblxuICAvLyBXZSdyZSBub3QgaW50ZXJlc3RlZCBpbiB0aGUgRG9ja2VyIHZlcnNpb24gdXNlZCB0byBjcmVhdGUgdGhpcyBpbWFnZVxuICBkZWxldGUgbWFuaWZlc3QuRG9ja2VyVmVyc2lvbjtcblxuICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShKU09OLnN0cmluZ2lmeShtYW5pZmVzdCkpLmRpZ2VzdCgnaGV4Jyk7XG59XG5cbi8qKlxuICogRXhhbXBsZSBvZiBhIERvY2tlciBtYW5pZmVzdFxuICpcbiAqIFtcbiAqICAgICB7XG4gKiAgICAgICAgIFwiSWRcIjogXCJzaGEyNTY6M2E5MDU0Mjk5MWQwMzAwN2ZkMWQ4ZjNiM2E2YWIwNGViYjAyMzg2Nzg1NDMwZmU0OGE4Njc3NjhhMDQ4ZDgyOFwiLFxuICogICAgICAgICBcIlJlcG9UYWdzXCI6IFtcbiAqICAgICAgICAgICAgIFwiOTkzNjU1NzU0MzU5LmRrci5lY3IudXMtZWFzdC0xLmFtYXpvbmF3cy5jb20vY2RrL2F3c2Vjc2ludGVnaW1hZ2U3YzE1YjhjNjpsYXRlc3RcIlxuICogICAgICAgICBdLFxuICogICAgICAgICBcIlJlcG9EaWdlc3RzXCI6IFtcbiAqICAgICAgICAgICAgIFwiOTkzNjU1NzU0MzU5LmRrci5lY3IudXMtZWFzdC0xLmFtYXpvLi4uLjVlNTBjMGNmYzNmMjM1NTE5MTkzNGIwNWRmNjhjZDMzMzlhMDQ0OTU5MTExZmZlYzJlMTQ3NjVcIlxuICogICAgICAgICBdLFxuICogICAgICAgICBcIlBhcmVudFwiOiBcInNoYTI1Njo0NjU3MjBmOGY0M2M5YzBhZmY1ZGNjNzMxZDRlMzY4YTM5MjdjYWU0ZTg4NTQ0MmQ0YmEwYmY4YTg2N2I3NTYxXCIsXG4gKiAgICAgICAgIFwiQ29tbWVudFwiOiBcIlwiLFxuICogICAgICAgICBcIkNyZWF0ZWRcIjogXCIyMDE4LTEwLTE3VDEwOjE2OjQwLjc3NTg4ODQ3NlpcIixcbiAqICAgICAgICAgXCJDb250YWluZXJcIjogXCIyMGYxNDVkMmU3ZmJmMTI2Y2E5ZjQ0MjI0OTdiOTMyYmM5NmI1ZmFhMDM4ZGMwMzJkZTFlMjQ2ZjY0ZTAzYTY2XCIsXG4gKiAgICAgICAgIFwiQ29udGFpbmVyQ29uZmlnXCI6IHtcbiAqICAgICAgICAgICAgIFwiSG9zdG5hbWVcIjogXCI5YjQ4YjU4MGEzMTJcIixcbiAqICAgICAgICAgICAgIFwiRG9tYWlubmFtZVwiOiBcIlwiLFxuICogICAgICAgICAgICAgXCJVc2VyXCI6IFwiXCIsXG4gKiAgICAgICAgICAgICBcIkF0dGFjaFN0ZGluXCI6IGZhbHNlLFxuICogICAgICAgICAgICAgXCJBdHRhY2hTdGRvdXRcIjogZmFsc2UsXG4gKiAgICAgICAgICAgICBcIkF0dGFjaFN0ZGVyclwiOiBmYWxzZSxcbiAqICAgICAgICAgICAgIFwiRXhwb3NlZFBvcnRzXCI6IHtcbiAqICAgICAgICAgICAgICAgICBcIjgwMDAvdGNwXCI6IHt9XG4gKiAgICAgICAgICAgICB9LFxuICogICAgICAgICAgICAgXCJUdHlcIjogZmFsc2UsXG4gKiAgICAgICAgICAgICBcIk9wZW5TdGRpblwiOiBmYWxzZSxcbiAqICAgICAgICAgICAgIFwiU3RkaW5PbmNlXCI6IGZhbHNlLFxuICogICAgICAgICAgICAgXCJFbnZcIjogW1xuICogICAgICAgICAgICAgICAgIFwiUEFUSD0vdXNyL2xvY2FsL2JpbjovdXNyL2xvY2FsL3NiaW46L3Vzci9sb2NhbC9iaW46L3Vzci9zYmluOi91c3IvYmluOi9zYmluOi9iaW5cIixcbiAqICAgICAgICAgICAgICAgICBcIkxBTkc9Qy5VVEYtOFwiLFxuICogICAgICAgICAgICAgICAgIFwiR1BHX0tFWT0wRDk2REY0RDQxMTBFNUM0M0ZCRkIxN0YyRDM0N0VBNkFBNjU0MjFEXCIsXG4gKiAgICAgICAgICAgICAgICAgXCJQWVRIT05fVkVSU0lPTj0zLjYuNlwiLFxuICogICAgICAgICAgICAgICAgIFwiUFlUSE9OX1BJUF9WRVJTSU9OPTE4LjFcIlxuICogICAgICAgICAgICAgXSxcbiAqICAgICAgICAgICAgIFwiQ21kXCI6IFtcbiAqICAgICAgICAgICAgICAgICBcIi9iaW4vc2hcIixcbiAqICAgICAgICAgICAgICAgICBcIi1jXCIsXG4gKiAgICAgICAgICAgICAgICAgXCIjKG5vcCkgXCIsXG4gKiAgICAgICAgICAgICAgICAgXCJDTUQgW1xcXCIvYmluL3NoXFxcIiBcXFwiLWNcXFwiIFxcXCJweXRob24zIGluZGV4LnB5XFxcIl1cIlxuICogICAgICAgICAgICAgXSxcbiAqICAgICAgICAgICAgIFwiQXJnc0VzY2FwZWRcIjogdHJ1ZSxcbiAqICAgICAgICAgICAgIFwiSW1hZ2VcIjogXCJzaGEyNTY6NDY1NzIwZjhmNDNjOWMwYWZmNWRjYzczMWQ0ZTM2OGEzOTI3Y2FlNGU4ODU0NDJkNGJhMGJmOGE4NjdiNzU2MVwiLFxuICogICAgICAgICAgICAgXCJWb2x1bWVzXCI6IG51bGwsXG4gKiAgICAgICAgICAgICBcIldvcmtpbmdEaXJcIjogXCIvY29kZVwiLFxuICogICAgICAgICAgICAgXCJFbnRyeXBvaW50XCI6IG51bGwsXG4gKiAgICAgICAgICAgICBcIk9uQnVpbGRcIjogW10sXG4gKiAgICAgICAgICAgICBcIkxhYmVsc1wiOiB7fVxuICogICAgICAgICB9LFxuICogICAgICAgICBcIkRvY2tlclZlcnNpb25cIjogXCIxNy4wMy4yLWNlXCIsXG4gKiAgICAgICAgIFwiQXV0aG9yXCI6IFwiXCIsXG4gKiAgICAgICAgIFwiQ29uZmlnXCI6IHtcbiAqICAgICAgICAgICAgIFwiSG9zdG5hbWVcIjogXCI5YjQ4YjU4MGEzMTJcIixcbiAqICAgICAgICAgICAgIFwiRG9tYWlubmFtZVwiOiBcIlwiLFxuICogICAgICAgICAgICAgXCJVc2VyXCI6IFwiXCIsXG4gKiAgICAgICAgICAgICBcIkF0dGFjaFN0ZGluXCI6IGZhbHNlLFxuICogICAgICAgICAgICAgXCJBdHRhY2hTdGRvdXRcIjogZmFsc2UsXG4gKiAgICAgICAgICAgICBcIkF0dGFjaFN0ZGVyclwiOiBmYWxzZSxcbiAqICAgICAgICAgICAgIFwiRXhwb3NlZFBvcnRzXCI6IHtcbiAqICAgICAgICAgICAgICAgICBcIjgwMDAvdGNwXCI6IHt9XG4gKiAgICAgICAgICAgICB9LFxuICogICAgICAgICAgICAgXCJUdHlcIjogZmFsc2UsXG4gKiAgICAgICAgICAgICBcIk9wZW5TdGRpblwiOiBmYWxzZSxcbiAqICAgICAgICAgICAgIFwiU3RkaW5PbmNlXCI6IGZhbHNlLFxuICogICAgICAgICAgICAgXCJFbnZcIjogW1xuICogICAgICAgICAgICAgICAgIFwiUEFUSD0vdXNyL2xvY2FsL2JpbjovdXNyL2xvY2FsL3NiaW46L3Vzci9sb2NhbC9iaW46L3Vzci9zYmluOi91c3IvYmluOi9zYmluOi9iaW5cIixcbiAqICAgICAgICAgICAgICAgICBcIkxBTkc9Qy5VVEYtOFwiLFxuICogICAgICAgICAgICAgICAgIFwiR1BHX0tFWT0wRDk2REY0RDQxMTBFNUM0M0ZCRkIxN0YyRDM0N0VBNkFBNjU0MjFEXCIsXG4gKiAgICAgICAgICAgICAgICAgXCJQWVRIT05fVkVSU0lPTj0zLjYuNlwiLFxuICogICAgICAgICAgICAgICAgIFwiUFlUSE9OX1BJUF9WRVJTSU9OPTE4LjFcIlxuICogICAgICAgICAgICAgXSxcbiAqICAgICAgICAgICAgIFwiQ21kXCI6IFtcbiAqICAgICAgICAgICAgICAgICBcIi9iaW4vc2hcIixcbiAqICAgICAgICAgICAgICAgICBcIi1jXCIsXG4gKiAgICAgICAgICAgICAgICAgXCJweXRob24zIGluZGV4LnB5XCJcbiAqICAgICAgICAgICAgIF0sXG4gKiAgICAgICAgICAgICBcIkFyZ3NFc2NhcGVkXCI6IHRydWUsXG4gKiAgICAgICAgICAgICBcIkltYWdlXCI6IFwic2hhMjU2OjQ2NTcyMGY4ZjQzYzljMGFmZjVkY2M3MzFkNGUzNjhhMzkyN2NhZTRlODg1NDQyZDRiYTBiZjhhODY3Yjc1NjFcIixcbiAqICAgICAgICAgICAgIFwiVm9sdW1lc1wiOiBudWxsLFxuICogICAgICAgICAgICAgXCJXb3JraW5nRGlyXCI6IFwiL2NvZGVcIixcbiAqICAgICAgICAgICAgIFwiRW50cnlwb2ludFwiOiBudWxsLFxuICogICAgICAgICAgICAgXCJPbkJ1aWxkXCI6IFtdLFxuICogICAgICAgICAgICAgXCJMYWJlbHNcIjoge31cbiAqICAgICAgICAgfSxcbiAqICAgICAgICAgXCJBcmNoaXRlY3R1cmVcIjogXCJhbWQ2NFwiLFxuICogICAgICAgICBcIk9zXCI6IFwibGludXhcIixcbiAqICAgICAgICAgXCJTaXplXCI6IDkxNzczMDQ2OCxcbiAqICAgICAgICAgXCJWaXJ0dWFsU2l6ZVwiOiA5MTc3MzA0NjgsXG4gKiAgICAgICAgIFwiR3JhcGhEcml2ZXJcIjoge1xuICogICAgICAgICAgICAgXCJOYW1lXCI6IFwiYXVmc1wiLFxuICogICAgICAgICAgICAgXCJEYXRhXCI6IG51bGxcbiAqICAgICAgICAgfSxcbiAqICAgICAgICAgXCJSb290RlNcIjoge1xuICogICAgICAgICAgICAgXCJUeXBlXCI6IFwibGF5ZXJzXCIsXG4gKiAgICAgICAgICAgICBcIkxheWVyc1wiOiBbXG4gKiAgICAgICAgICAgICAgICAgXCJzaGEyNTY6ZjcxNWVkMTljMjhiNjY5NDNhYzhiYzEyZGJmYjgyOGU4Mzk0ZGUyNTMwYmJhZjFlY2NlOTA2ZTc0OGU0ZmRmZlwiLFxuICogICAgICAgICAgICAgICAgIFwic2hhMjU2OjhiYjI1ZjljZGM0MWU3ZDA4NTAzM2FmMTVhNTIyOTczYjQ0MDg2ZDZlZWRkMjRjMTFjYzYxYzkyMzIzMjRmNzdcIixcbiAqICAgICAgICAgICAgICAgICBcInNoYTI1NjowOGEwMTYxMmZmY2EzMzQ4M2ExODQ3YzkwOTgzNjYxMDYxMGNlNTIzZmI3ZTFhY2E4ODAxNDBlZTg0ZGYyM2U5XCIsXG4gKiAgICAgICAgICAgICAgICAgXCJzaGEyNTY6MTE5MWIzZjU4NjJhYTkyMzE4NTg4MDliN2FjOGI5MWMwYjcyN2NlODVjOWIzMjc5OTMyZjBiYWFjYzkyOTY3ZFwiLFxuICogICAgICAgICAgICAgICAgIFwic2hhMjU2Ojk5NzhkMDg0ZmQ3NzFlMGIzZDFhY2Q3ZjM1MjVkMWIyNTI4OGFiYWJlOWFkOGVkMjU5YjM2MTAxZTRlM2FkZGRcIixcbiAqICAgICAgICAgICAgICAgICBcInNoYTI1NjoyZjRmNzRkMzgyMWVjYmRkNjBiNWQ5MzI0NTJlYTllMzBjZWNmOTAyMzM0MTY1YzRhMTk4MzdmNmVlNjM2Mzc3XCIsXG4gKiAgICAgICAgICAgICAgICAgXCJzaGEyNTY6MDAzYmI2MTc4YmMzMjE4MjQyZDczZTUxZDVlOWFiMmY5OTFkYzYwNzc4MDE5NDcxOWM2YmQ0YzhjNDEyZmU4Y1wiLFxuICogICAgICAgICAgICAgICAgIFwic2hhMjU2OjE1YjMyZDg0OWRhMjIzOWIxYWY1ODNmOTM4MWM3YTc1ZDdhY2ViYTEyZjVkZGZmZmE3YTA1OTExNmNmMDVhYjlcIixcbiAqICAgICAgICAgICAgICAgICBcInNoYTI1Njo2ZTVjNWY2YmYwNDNiYzYzNDM3OGIxZTRiNjFhZjA5YmU3NDc0MWYyYWM4MDIwNGQ3YTM3MzcxM2IxZmQ1YTQwXCIsXG4gKiAgICAgICAgICAgICAgICAgXCJzaGEyNTY6MzI2MGUwMGUzNTNiZmI3NjViMjU1OTdkMTM4NjhjMmVmNjRjYjNkNTA5ODc1YWJjZmI1OGM0ZTliZjdmNGVlMlwiLFxuICogICAgICAgICAgICAgICAgIFwic2hhMjU2OmYzMjc0Yjc1ODU2MzExZTkyZTE0YTEyNzBjNzg3MzdjODY0NTZkNjM1M2ZlNGE4M2JkMmU4MWJjZDJhOTk2ZWFcIlxuICogICAgICAgICAgICAgXVxuICogICAgICAgICB9XG4gKiAgICAgfVxuICogXVxuICovXG4iXX0=
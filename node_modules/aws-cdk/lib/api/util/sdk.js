"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const AWS = require("aws-sdk");
const child_process = require("child_process");
const fs = require("fs-extra");
const os = require("os");
const path = require("path");
const util = require("util");
const logging_1 = require("../../logging");
const plugin_1 = require("../../plugin");
const account_cache_1 = require("./account-cache");
const sdk_ini_file_1 = require("./sdk_ini_file");
/**
 * Source for SDK client objects
 *
 * Credentials are first obtained from the SDK defaults (using environment variables and the
 * ~/.aws/{config,credentials} files).
 *
 * If those don't suffice, a list of CredentialProviderSources is interrogated for access
 * to the requested account.
 */
class SDK {
    constructor(options) {
        this.profile = options.profile;
        const defaultCredentialProvider = makeCLICompatibleCredentialProvider(options.profile, options.ec2creds);
        // Find the package.json from the main toolkit
        const pkg = require.main.require('../package.json');
        AWS.config.update({
            customUserAgent: `${pkg.name}/${pkg.version}`
        });
        // https://aws.amazon.com/blogs/developer/using-the-aws-sdk-for-javascript-from-behind-a-proxy/
        if (options.proxyAddress === undefined) {
            options.proxyAddress = httpsProxyFromEnvironment();
        }
        if (options.proxyAddress) { // Ignore empty string on purpose
            logging_1.debug('Using proxy server: %s', options.proxyAddress);
            AWS.config.update({
                httpOptions: { agent: require('proxy-agent')(options.proxyAddress) }
            });
        }
        this.defaultAwsAccount = new DefaultAWSAccount(defaultCredentialProvider, getCLICompatibleDefaultRegion(this.profile));
        this.credentialsCache = new CredentialsCache(this.defaultAwsAccount, defaultCredentialProvider);
    }
    async cloudFormation(environment, mode) {
        return new AWS.CloudFormation({
            region: environment.region,
            credentials: await this.credentialsCache.get(environment.account, mode)
        });
    }
    async ec2(awsAccountId, region, mode) {
        return new AWS.EC2({
            region,
            credentials: await this.credentialsCache.get(awsAccountId, mode)
        });
    }
    async ssm(awsAccountId, region, mode) {
        return new AWS.SSM({
            region,
            credentials: await this.credentialsCache.get(awsAccountId, mode)
        });
    }
    async s3(environment, mode) {
        return new AWS.S3({
            region: environment.region,
            credentials: await this.credentialsCache.get(environment.account, mode)
        });
    }
    async route53(awsAccountId, region, mode) {
        return new AWS.Route53({
            region,
            credentials: await this.credentialsCache.get(awsAccountId, mode),
        });
    }
    async ecr(environment, mode) {
        return new AWS.ECR({
            region: environment.region,
            credentials: await this.credentialsCache.get(environment.account, mode)
        });
    }
    async defaultRegion() {
        return await getCLICompatibleDefaultRegion(this.profile);
    }
    defaultAccount() {
        return this.defaultAwsAccount.get();
    }
}
exports.SDK = SDK;
/**
 * Cache for credential providers.
 *
 * Given an account and an operating mode (read or write) will return an
 * appropriate credential provider for credentials for the given account. The
 * credential provider will be cached so that multiple AWS clients for the same
 * environment will not make multiple network calls to obtain credentials.
 *
 * Will use default credentials if they are for the right account; otherwise,
 * all loaded credential provider plugins will be tried to obtain credentials
 * for the given account.
 */
class CredentialsCache {
    constructor(defaultAwsAccount, defaultCredentialProvider) {
        this.defaultAwsAccount = defaultAwsAccount;
        this.defaultCredentialProvider = defaultCredentialProvider;
        this.cache = {};
    }
    async get(awsAccountId, mode) {
        const key = `${awsAccountId}-${mode}`;
        if (!(key in this.cache)) {
            this.cache[key] = await this.getCredentials(awsAccountId, mode);
        }
        return this.cache[key];
    }
    async getCredentials(awsAccountId, mode) {
        // If requested account is undefined or equal to default account, use default credentials provider.
        // (Note that we ignore the mode in this case, if you preloaded credentials they better be correct!)
        const defaultAccount = await this.defaultAwsAccount.get();
        if (!awsAccountId || awsAccountId === defaultAccount) {
            logging_1.debug(`Using default AWS SDK credentials for account ${awsAccountId}`);
            // CredentialProviderChain extends Credentials, but that is a lie.
            // https://github.com/aws/aws-sdk-js/issues/2235
            // Call resolve() instead.
            return (await this.defaultCredentialProvider).resolvePromise();
        }
        const triedSources = [];
        // Otherwise, inspect the various credential sources we have
        for (const source of plugin_1.PluginHost.instance.credentialProviderSources) {
            if (!(await source.isAvailable())) {
                logging_1.debug('Credentials source %s is not available, ignoring it.', source.name);
                continue;
            }
            triedSources.push(source);
            if (!(await source.canProvideCredentials(awsAccountId))) {
                continue;
            }
            logging_1.debug(`Using ${source.name} credentials for account ${awsAccountId}`);
            const providerOrCreds = await source.getProvider(awsAccountId, mode);
            // Backwards compatibility: if the plugin returns a ProviderChain, resolve that chain.
            // Otherwise it must have returned credentials.
            if (providerOrCreds.resolvePromise) {
                return await providerOrCreds.resolvePromise();
            }
            return providerOrCreds;
        }
        const sourceNames = ['default credentials'].concat(triedSources.map(s => s.name)).join(', ');
        throw new Error(`Need to perform AWS calls for account ${awsAccountId}, but no credentials found. Tried: ${sourceNames}.`);
    }
}
/**
 * Class to retrieve the account for default credentials and cache it.
 *
 * Uses the default credentials provider to obtain credentials (if available),
 * and uses those credentials to call STS to request the current account ID.
 *
 * The credentials => accountId lookup is cached on disk, since it's
 * guaranteed that igven access key will always remain for the same account.
 */
class DefaultAWSAccount {
    constructor(defaultCredentialsProvider, region) {
        this.defaultCredentialsProvider = defaultCredentialsProvider;
        this.region = region;
        this.defaultAccountFetched = false;
        this.defaultAccountId = undefined;
        this.accountCache = new account_cache_1.AccountAccessKeyCache();
    }
    /**
     * Return the default account
     */
    async get() {
        if (!this.defaultAccountFetched) {
            this.defaultAccountId = await this.lookupDefaultAccount();
            this.defaultAccountFetched = true;
        }
        return this.defaultAccountId;
    }
    async lookupDefaultAccount() {
        try {
            // There just is *NO* way to do AssumeRole credentials as long as AWS_SDK_LOAD_CONFIG is not set. The SDK
            // crash if the file does not exist though. So set the environment variable if we can find that file.
            await setConfigVariable();
            logging_1.debug('Resolving default credentials');
            const credentialProvider = await this.defaultCredentialsProvider;
            const creds = await credentialProvider.resolvePromise();
            const accessKeyId = creds.accessKeyId;
            if (!accessKeyId) {
                throw new Error('Unable to resolve AWS credentials (setup with "aws configure")');
            }
            const accountId = await this.accountCache.fetch(creds.accessKeyId, async () => {
                // if we don't have one, resolve from STS and store in cache.
                logging_1.debug('Looking up default account ID from STS');
                const result = await new AWS.STS({ credentials: creds, region: await this.region }).getCallerIdentity().promise();
                const aid = result.Account;
                if (!aid) {
                    logging_1.debug('STS didn\'t return an account ID');
                    return undefined;
                }
                logging_1.debug('Default account ID:', aid);
                return aid;
            });
            return accountId;
        }
        catch (e) {
            logging_1.debug('Unable to determine the default AWS account (did you configure "aws configure"?):', e);
            return undefined;
        }
    }
}
/**
 * Build an AWS CLI-compatible credential chain provider
 *
 * This is similar to the default credential provider chain created by the SDK
 * except it also accepts the profile argument in the constructor (not just from
 * the environment).
 *
 * To mimic the AWS CLI behavior:
 *
 * - we default to ~/.aws/credentials if environment variable for credentials
 * file location is not given (SDK expects explicit environment variable with name).
 * - AWS_DEFAULT_PROFILE is also inspected for profile name (not just AWS_PROFILE).
 */
async function makeCLICompatibleCredentialProvider(profile, ec2creds) {
    profile = profile || process.env.AWS_PROFILE || process.env.AWS_DEFAULT_PROFILE || 'default';
    // Need to construct filename ourselves, without appropriate environment variables
    // no defaults used by JS SDK.
    const filename = process.env.AWS_SHARED_CREDENTIALS_FILE || path.join(os.homedir(), '.aws', 'credentials');
    const sources = [
        () => new AWS.EnvironmentCredentials('AWS'),
        () => new AWS.EnvironmentCredentials('AMAZON'),
    ];
    if (fs.pathExists(filename)) {
        sources.push(() => new AWS.SharedIniFileCredentials({ profile, filename }));
    }
    if (hasEcsCredentials()) {
        sources.push(() => new AWS.ECSCredentials());
    }
    else {
        // else if: don't get EC2 creds if we should have gotten ECS creds--ECS instances also
        // run on EC2 boxes but the creds represent something different. Same behavior as
        // upstream code.
        if (ec2creds === undefined) {
            ec2creds = await hasEc2Credentials();
        }
        if (ec2creds) {
            sources.push(() => new AWS.EC2MetadataCredentials());
        }
    }
    return new AWS.CredentialProviderChain(sources);
}
/**
 * Return the default region in a CLI-compatible way
 *
 * Mostly copied from node_loader.js, but with the following differences:
 *
 * - Takes a runtime profile name to load the region from, not just based on environment
 *   variables at process start.
 * - We have needed to create a local copy of the SharedIniFile class because the
 *   implementation in 'aws-sdk' is private (and the default use of it in the
 *   SDK does not allow us to specify a profile at runtime).
 * - AWS_DEFAULT_PROFILE and AWS_DEFAULT_REGION are also used as environment
 *   variables to be used to determine the region.
 */
async function getCLICompatibleDefaultRegion(profile) {
    profile = profile || process.env.AWS_PROFILE || process.env.AWS_DEFAULT_PROFILE || 'default';
    // Defaults inside constructor
    const toCheck = [
        { filename: process.env.AWS_SHARED_CREDENTIALS_FILE },
        { isConfig: true, filename: process.env.AWS_CONFIG_FILE },
    ];
    let region = process.env.AWS_REGION || process.env.AMAZON_REGION ||
        process.env.AWS_DEFAULT_REGION || process.env.AMAZON_DEFAULT_REGION;
    while (!region && toCheck.length > 0) {
        const configFile = new sdk_ini_file_1.SharedIniFile(toCheck.shift());
        const section = await configFile.getProfile(profile);
        region = section && section.region;
    }
    return region;
}
/**
 * Find and return the configured HTTPS proxy address
 */
function httpsProxyFromEnvironment() {
    if (process.env.https_proxy) {
        return process.env.https_proxy;
    }
    if (process.env.HTTPS_PROXY) {
        return process.env.HTTPS_PROXY;
    }
    return undefined;
}
/**
 * Return whether it looks like we'll have ECS credentials available
 */
function hasEcsCredentials() {
    return AWS.ECSCredentials.prototype.isConfiguredForEcsCredentials();
}
/**
 * Return whether we're on an EC2 instance
 */
async function hasEc2Credentials() {
    logging_1.debug("Determining whether we're on an EC2 instance.");
    let instance = false;
    if (process.platform === 'win32') {
        // https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/identify_ec2_instances.html
        const result = await util.promisify(child_process.exec)('wmic path win32_computersystemproduct get uuid', { encoding: 'utf-8' });
        // output looks like
        //  UUID
        //  EC2AE145-D1DC-13B2-94ED-01234ABCDEF
        const lines = result.stdout.toString().split('\n');
        instance = lines.some(x => matchesRegex(/^ec2/i, x));
    }
    else {
        // https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/identify_ec2_instances.html
        const files = [
            // This recognizes the Xen hypervisor based instances (pre-5th gen)
            ['/sys/hypervisor/uuid', /^ec2/i],
            // This recognizes the new Hypervisor (5th-gen instances and higher)
            // Can't use the advertised file '/sys/devices/virtual/dmi/id/product_uuid' because it requires root to read.
            // Instead, sys_vendor contains something like 'Amazon EC2'.
            ['/sys/devices/virtual/dmi/id/sys_vendor', /ec2/i],
        ];
        for (const [file, re] of files) {
            if (matchesRegex(re, await readIfPossible(file))) {
                instance = true;
                break;
            }
        }
    }
    logging_1.debug(instance ? 'Looks like EC2 instance.' : 'Does not look like EC2 instance.');
    return instance;
}
async function setConfigVariable() {
    const homeDir = process.env.HOME || process.env.USERPROFILE
        || (process.env.HOMEPATH ? ((process.env.HOMEDRIVE || 'C:/') + process.env.HOMEPATH) : null) || os.homedir();
    if (await fs.pathExists(path.resolve(homeDir, '.aws', 'config'))) {
        process.env.AWS_SDK_LOAD_CONFIG = '1';
    }
}
async function readIfPossible(filename) {
    try {
        if (!await fs.pathExists(filename)) {
            return undefined;
        }
        return fs.readFile(filename, { encoding: 'utf-8' });
    }
    catch (e) {
        logging_1.debug(e);
        return undefined;
    }
}
function matchesRegex(re, s) {
    return s !== undefined && re.exec(s) !== null;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2RrLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic2RrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQ0EsK0JBQWdDO0FBQ2hDLCtDQUFnRDtBQUNoRCwrQkFBZ0M7QUFDaEMseUJBQTBCO0FBQzFCLDZCQUE4QjtBQUM5Qiw2QkFBOEI7QUFDOUIsMkNBQXNDO0FBQ3RDLHlDQUEwQztBQUUxQyxtREFBd0Q7QUFDeEQsaURBQStDO0FBMkIvQzs7Ozs7Ozs7R0FRRztBQUNILE1BQWEsR0FBRztJQUtkLFlBQVksT0FBbUI7UUFDN0IsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDO1FBRS9CLE1BQU0seUJBQXlCLEdBQUcsbUNBQW1DLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFekcsOENBQThDO1FBQzlDLE1BQU0sR0FBRyxHQUFJLE9BQU8sQ0FBQyxJQUFZLENBQUMsT0FBTyxDQUFDLGlCQUFpQixDQUFDLENBQUM7UUFDN0QsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUM7WUFDZCxlQUFlLEVBQUUsR0FBRyxHQUFHLENBQUMsSUFBSSxJQUFJLEdBQUcsQ0FBQyxPQUFPLEVBQUU7U0FDaEQsQ0FBQyxDQUFDO1FBRUgsK0ZBQStGO1FBQy9GLElBQUksT0FBTyxDQUFDLFlBQVksS0FBSyxTQUFTLEVBQUU7WUFDdEMsT0FBTyxDQUFDLFlBQVksR0FBRyx5QkFBeUIsRUFBRSxDQUFDO1NBQ3BEO1FBQ0QsSUFBSSxPQUFPLENBQUMsWUFBWSxFQUFFLEVBQUUsaUNBQWlDO1lBQzNELGVBQUssQ0FBQyx3QkFBd0IsRUFBRSxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7WUFDdEQsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUM7Z0JBQ2hCLFdBQVcsRUFBRSxFQUFFLEtBQUssRUFBRSxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxF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RTtRQUNoRSxPQUFPLENBQUMsR0FBRyxDQUFDLG1CQUFtQixHQUFHLEdBQUcsQ0FBQztLQUN2QztBQUNILENBQUM7QUFFRCxLQUFLLFVBQVUsY0FBYyxDQUFDLFFBQWdCO0lBQzVDLElBQUk7UUFDRixJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQUUsT0FBTyxTQUFTLENBQUM7U0FBRTtRQUN6RCxPQUFPLEVBQUUsQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7S0FDckQ7SUFBQyxPQUFPLENBQUMsRUFBRTtRQUNWLGVBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNULE9BQU8sU0FBUyxDQUFDO0tBQ2xCO0FBQ0gsQ0FBQztBQUVELFNBQVMsWUFBWSxDQUFDLEVBQVUsRUFBRSxDQUFxQjtJQUNyRCxPQUFPLENBQUMsS0FBSyxTQUFTLElBQUksRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUM7QUFDaEQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVudmlyb25tZW50fSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0IEFXUyA9IHJlcXVpcmUoJ2F3cy1zZGsnKTtcbmltcG9ydCBjaGlsZF9wcm9jZXNzID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpO1xuaW1wb3J0IGZzID0gcmVxdWlyZSgnZnMtZXh0cmEnKTtcbmltcG9ydCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5pbXBvcnQgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmltcG9ydCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuaW1wb3J0IHsgZGVidWcgfSBmcm9tICcuLi8uLi9sb2dnaW5nJztcbmltcG9ydCB7IFBsdWdpbkhvc3QgfSBmcm9tICcuLi8uLi9wbHVnaW4nO1xuaW1wb3J0IHsgQ3JlZGVudGlhbFByb3ZpZGVyU291cmNlLCBNb2RlIH0gZnJvbSAnLi4vYXdzLWF1dGgvY3JlZGVudGlhbHMnO1xuaW1wb3J0IHsgQWNjb3VudEFjY2Vzc0tleUNhY2hlIH0gZnJvbSAnLi9hY2NvdW50LWNhY2hlJztcbmltcG9ydCB7IFNoYXJlZEluaUZpbGUgfSBmcm9tICcuL3Nka19pbmlfZmlsZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU0RLT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBQcm9maWxlIG5hbWUgdG8gdXNlXG4gICAqXG4gICAqIEBkZWZhdWx0IE5vIHByb2ZpbGVcbiAgICovXG4gIHByb2ZpbGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFByb3h5IGFkZHJlc3MgdG8gdXNlXG4gICAqXG4gICAqIEBkZWZhdWx0IE5vIHByb3h5XG4gICAqL1xuICBwcm94eUFkZHJlc3M/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgd2Ugc2hvdWxkIHRyeSBpbnN0YW5jZSBjcmVkZW50aWFsc1xuICAgKlxuICAgKiBUcnVlL2ZhbHNlIHRvIGZvcmNlL2Rpc2FibGUuIERlZmF1bHQgaXMgdG8gZ3Vlc3MuXG4gICAqXG4gICAqIEBkZWZhdWx0IEF1dG9tYXRpY2FsbHkgZGV0ZXJtaW5lLlxuICAgKi9cbiAgZWMyY3JlZHM/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIFNvdXJjZSBmb3IgU0RLIGNsaWVudCBvYmplY3RzXG4gKlxuICogQ3JlZGVudGlhbHMgYXJlIGZpcnN0IG9idGFpbmVkIGZyb20gdGhlIFNESyBkZWZhdWx0cyAodXNpbmcgZW52aXJvbm1lbnQgdmFyaWFibGVzIGFuZCB0aGVcbiAqIH4vLmF3cy97Y29uZmlnLGNyZWRlbnRpYWxzfSBmaWxlcykuXG4gKlxuICogSWYgdGhvc2UgZG9uJ3Qgc3VmZmljZSwgYSBsaXN0IG9mIENyZWRlbnRpYWxQcm92aWRlclNvdXJjZXMgaXMgaW50ZXJyb2dhdGVkIGZvciBhY2Nlc3NcbiAqIHRvIHRoZSByZXF1ZXN0ZWQgYWNjb3VudC5cbiAqL1xuZXhwb3J0IGNsYXNzIFNESyB7XG4gIHByaXZhdGUgcmVhZG9ubHkgZGVmYXVsdEF3c0FjY291bnQ6IERlZmF1bHRBV1NBY2NvdW50O1xuICBwcml2YXRlIHJlYWRvbmx5IGNyZWRlbnRpYWxzQ2FjaGU6IENyZWRlbnRpYWxzQ2FjaGU7XG4gIHByaXZhdGUgcmVhZG9ubHkgcHJvZmlsZT86IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBTREtPcHRpb25zKSB7XG4gICAgdGhpcy5wcm9maWxlID0gb3B0aW9ucy5wcm9maWxlO1xuXG4gICAgY29uc3QgZGVmYXVsdENyZWRlbnRpYWxQcm92aWRlciA9IG1ha2VDTElDb21wYXRpYmxlQ3JlZGVudGlhbFByb3ZpZGVyKG9wdGlvbnMucHJvZmlsZSwgb3B0aW9ucy5lYzJjcmVkcyk7XG5cbiAgICAvLyBGaW5kIHRoZSBwYWNrYWdlLmpzb24gZnJvbSB0aGUgbWFpbiB0b29sa2l0XG4gICAgY29uc3QgcGtnID0gKHJlcXVpcmUubWFpbiBhcyBhbnkpLnJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpO1xuICAgIEFXUy5jb25maWcudXBkYXRlKHtcbiAgICAgICAgY3VzdG9tVXNlckFnZW50OiBgJHtwa2cubmFtZX0vJHtwa2cudmVyc2lvbn1gXG4gICAgfSk7XG5cbiAgICAvLyBodHRwczovL2F3cy5hbWF6b24uY29tL2Jsb2dzL2RldmVsb3Blci91c2luZy10aGUtYXdzLXNkay1mb3ItamF2YXNjcmlwdC1mcm9tLWJlaGluZC1hLXByb3h5L1xuICAgIGlmIChvcHRpb25zLnByb3h5QWRkcmVzcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zLnByb3h5QWRkcmVzcyA9IGh0dHBzUHJveHlGcm9tRW52aXJvbm1lbnQoKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucHJveHlBZGRyZXNzKSB7IC8vIElnbm9yZSBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuICAgICAgZGVidWcoJ1VzaW5nIHByb3h5IHNlcnZlcjogJXMnLCBvcHRpb25zLnByb3h5QWRkcmVzcyk7XG4gICAgICBBV1MuY29uZmlnLnVwZGF0ZSh7XG4gICAgICAgIGh0dHBPcHRpb25zOiB7IGFnZW50OiByZXF1aXJlKCdwcm94eS1hZ2VudCcpKG9wdGlvbnMucHJveHlBZGRyZXNzKSB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmRlZmF1bHRBd3NBY2NvdW50ID0gbmV3IERlZmF1bHRBV1NBY2NvdW50KGRlZmF1bHRDcmVkZW50aWFsUHJvdmlkZXIsIGdldENMSUNvbXBhdGlibGVEZWZhdWx0UmVnaW9uKHRoaXMucHJvZmlsZSkpO1xuICAgIHRoaXMuY3JlZGVudGlhbHNDYWNoZSA9IG5ldyBDcmVkZW50aWFsc0NhY2hlKHRoaXMuZGVmYXVsdEF3c0FjY291bnQsIGRlZmF1bHRDcmVkZW50aWFsUHJvdmlkZXIpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGNsb3VkRm9ybWF0aW9uKGVudmlyb25tZW50OiBFbnZpcm9ubWVudCwgbW9kZTogTW9kZSk6IFByb21pc2U8QVdTLkNsb3VkRm9ybWF0aW9uPiB7XG4gICAgcmV0dXJuIG5ldyBBV1MuQ2xvdWRGb3JtYXRpb24oe1xuICAgICAgcmVnaW9uOiBlbnZpcm9ubWVudC5yZWdpb24sXG4gICAgICBjcmVkZW50aWFsczogYXdhaXQgdGhpcy5jcmVkZW50aWFsc0NhY2hlLmdldChlbnZpcm9ubWVudC5hY2NvdW50LCBtb2RlKVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGVjMihhd3NBY2NvdW50SWQ6IHN0cmluZyB8IHVuZGVmaW5lZCwgcmVnaW9uOiBzdHJpbmcgfCB1bmRlZmluZWQsIG1vZGU6IE1vZGUpOiBQcm9taXNlPEFXUy5FQzI+IHtcbiAgICByZXR1cm4gbmV3IEFXUy5FQzIoe1xuICAgICAgcmVnaW9uLFxuICAgICAgY3JlZGVudGlhbHM6IGF3YWl0IHRoaXMuY3JlZGVudGlhbHNDYWNoZS5nZXQoYXdzQWNjb3VudElkLCBtb2RlKVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHNzbShhd3NBY2NvdW50SWQ6IHN0cmluZyB8IHVuZGVmaW5lZCwgcmVnaW9uOiBzdHJpbmcgfCB1bmRlZmluZWQsIG1vZGU6IE1vZGUpOiBQcm9taXNlPEFXUy5TU00+IHtcbiAgICByZXR1cm4gbmV3IEFXUy5TU00oe1xuICAgICAgcmVnaW9uLFxuICAgICAgY3JlZGVudGlhbHM6IGF3YWl0IHRoaXMuY3JlZGVudGlhbHNDYWNoZS5nZXQoYXdzQWNjb3VudElkLCBtb2RlKVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHMzKGVudmlyb25tZW50OiBFbnZpcm9ubWVudCwgbW9kZTogTW9kZSk6IFByb21pc2U8QVdTLlMzPiB7XG4gICAgcmV0dXJuIG5ldyBBV1MuUzMoe1xuICAgICAgcmVnaW9uOiBlbnZpcm9ubWVudC5yZWdpb24sXG4gICAgICBjcmVkZW50aWFsczogYXdhaXQgdGhpcy5jcmVkZW50aWFsc0NhY2hlLmdldChlbnZpcm9ubWVudC5hY2NvdW50LCBtb2RlKVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHJvdXRlNTMoYXdzQWNjb3VudElkOiBzdHJpbmcgfCB1bmRlZmluZWQsIHJlZ2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkLCBtb2RlOiBNb2RlKTogUHJvbWlzZTxBV1MuUm91dGU1Mz4ge1xuICAgIHJldHVybiBuZXcgQVdTLlJvdXRlNTMoe1xuICAgICAgcmVnaW9uLFxuICAgICAgY3JlZGVudGlhbHM6IGF3YWl0IHRoaXMuY3JlZGVudGlhbHNDYWNoZS5nZXQoYXdzQWNjb3VudElkLCBtb2RlKSxcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBlY3IoZW52aXJvbm1lbnQ6IEVudmlyb25tZW50LCBtb2RlOiBNb2RlKTogUHJvbWlzZTxBV1MuRUNSPiB7XG4gICAgcmV0dXJuIG5ldyBBV1MuRUNSKHtcbiAgICAgIHJlZ2lvbjogZW52aXJvbm1lbnQucmVnaW9uLFxuICAgICAgY3JlZGVudGlhbHM6IGF3YWl0IHRoaXMuY3JlZGVudGlhbHNDYWNoZS5nZXQoZW52aXJvbm1lbnQuYWNjb3VudCwgbW9kZSlcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBkZWZhdWx0UmVnaW9uKCk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gICAgcmV0dXJuIGF3YWl0IGdldENMSUNvbXBhdGlibGVEZWZhdWx0UmVnaW9uKHRoaXMucHJvZmlsZSk7XG4gIH1cblxuICBwdWJsaWMgZGVmYXVsdEFjY291bnQoKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgICByZXR1cm4gdGhpcy5kZWZhdWx0QXdzQWNjb3VudC5nZXQoKTtcbiAgfVxufVxuXG4vKipcbiAqIENhY2hlIGZvciBjcmVkZW50aWFsIHByb3ZpZGVycy5cbiAqXG4gKiBHaXZlbiBhbiBhY2NvdW50IGFuZCBhbiBvcGVyYXRpbmcgbW9kZSAocmVhZCBvciB3cml0ZSkgd2lsbCByZXR1cm4gYW5cbiAqIGFwcHJvcHJpYXRlIGNyZWRlbnRpYWwgcHJvdmlkZXIgZm9yIGNyZWRlbnRpYWxzIGZvciB0aGUgZ2l2ZW4gYWNjb3VudC4gVGhlXG4gKiBjcmVkZW50aWFsIHByb3ZpZGVyIHdpbGwgYmUgY2FjaGVkIHNvIHRoYXQgbXVsdGlwbGUgQVdTIGNsaWVudHMgZm9yIHRoZSBzYW1lXG4gKiBlbnZpcm9ubWVudCB3aWxsIG5vdCBtYWtlIG11bHRpcGxlIG5ldHdvcmsgY2FsbHMgdG8gb2J0YWluIGNyZWRlbnRpYWxzLlxuICpcbiAqIFdpbGwgdXNlIGRlZmF1bHQgY3JlZGVudGlhbHMgaWYgdGhleSBhcmUgZm9yIHRoZSByaWdodCBhY2NvdW50OyBvdGhlcndpc2UsXG4gKiBhbGwgbG9hZGVkIGNyZWRlbnRpYWwgcHJvdmlkZXIgcGx1Z2lucyB3aWxsIGJlIHRyaWVkIHRvIG9idGFpbiBjcmVkZW50aWFsc1xuICogZm9yIHRoZSBnaXZlbiBhY2NvdW50LlxuICovXG5jbGFzcyBDcmVkZW50aWFsc0NhY2hlIHtcbiAgcHJpdmF0ZSByZWFkb25seSBjYWNoZToge1trZXk6IHN0cmluZ106IEFXUy5DcmVkZW50aWFsc30gPSB7fTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBkZWZhdWx0QXdzQWNjb3VudDogRGVmYXVsdEFXU0FjY291bnQsXG4gICAgcHJpdmF0ZSByZWFkb25seSBkZWZhdWx0Q3JlZGVudGlhbFByb3ZpZGVyOiBQcm9taXNlPEFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbj4pIHtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZXQoYXdzQWNjb3VudElkOiBzdHJpbmcgfCB1bmRlZmluZWQsIG1vZGU6IE1vZGUpOiBQcm9taXNlPEFXUy5DcmVkZW50aWFscz4ge1xuICAgIGNvbnN0IGtleSA9IGAke2F3c0FjY291bnRJZH0tJHttb2RlfWA7XG4gICAgaWYgKCEoa2V5IGluIHRoaXMuY2FjaGUpKSB7XG4gICAgICB0aGlzLmNhY2hlW2tleV0gPSBhd2FpdCB0aGlzLmdldENyZWRlbnRpYWxzKGF3c0FjY291bnRJZCwgbW9kZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhY2hlW2tleV07XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdldENyZWRlbnRpYWxzKGF3c0FjY291bnRJZDogc3RyaW5nIHwgdW5kZWZpbmVkLCBtb2RlOiBNb2RlKTogUHJvbWlzZTxBV1MuQ3JlZGVudGlhbHM+IHtcbiAgICAvLyBJZiByZXF1ZXN0ZWQgYWNjb3VudCBpcyB1bmRlZmluZWQgb3IgZXF1YWwgdG8gZGVmYXVsdCBhY2NvdW50LCB1c2UgZGVmYXVsdCBjcmVkZW50aWFscyBwcm92aWRlci5cbiAgICAvLyAoTm90ZSB0aGF0IHdlIGlnbm9yZSB0aGUgbW9kZSBpbiB0aGlzIGNhc2UsIGlmIHlvdSBwcmVsb2FkZWQgY3JlZGVudGlhbHMgdGhleSBiZXR0ZXIgYmUgY29ycmVjdCEpXG4gICAgY29uc3QgZGVmYXVsdEFjY291bnQgPSBhd2FpdCB0aGlzLmRlZmF1bHRBd3NBY2NvdW50LmdldCgpO1xuICAgIGlmICghYXdzQWNjb3VudElkIHx8IGF3c0FjY291bnRJZCA9PT0gZGVmYXVsdEFjY291bnQpIHtcbiAgICAgIGRlYnVnKGBVc2luZyBkZWZhdWx0IEFXUyBTREsgY3JlZGVudGlhbHMgZm9yIGFjY291bnQgJHthd3NBY2NvdW50SWR9YCk7XG5cbiAgICAgIC8vIENyZWRlbnRpYWxQcm92aWRlckNoYWluIGV4dGVuZHMgQ3JlZGVudGlhbHMsIGJ1dCB0aGF0IGlzIGEgbGllLlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3Mtc2RrLWpzL2lzc3Vlcy8yMjM1XG4gICAgICAvLyBDYWxsIHJlc29sdmUoKSBpbnN0ZWFkLlxuICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmRlZmF1bHRDcmVkZW50aWFsUHJvdmlkZXIpLnJlc29sdmVQcm9taXNlKCk7XG4gICAgfVxuXG4gICAgY29uc3QgdHJpZWRTb3VyY2VzOiBDcmVkZW50aWFsUHJvdmlkZXJTb3VyY2VbXSA9IFtdO1xuICAgIC8vIE90aGVyd2lzZSwgaW5zcGVjdCB0aGUgdmFyaW91cyBjcmVkZW50aWFsIHNvdXJjZXMgd2UgaGF2ZVxuICAgIGZvciAoY29uc3Qgc291cmNlIG9mIFBsdWdpbkhvc3QuaW5zdGFuY2UuY3JlZGVudGlhbFByb3ZpZGVyU291cmNlcykge1xuICAgICAgaWYgKCEoYXdhaXQgc291cmNlLmlzQXZhaWxhYmxlKCkpKSB7XG4gICAgICAgIGRlYnVnKCdDcmVkZW50aWFscyBzb3VyY2UgJXMgaXMgbm90IGF2YWlsYWJsZSwgaWdub3JpbmcgaXQuJywgc291cmNlLm5hbWUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRyaWVkU291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgICBpZiAoIShhd2FpdCBzb3VyY2UuY2FuUHJvdmlkZUNyZWRlbnRpYWxzKGF3c0FjY291bnRJZCkpKSB7IGNvbnRpbnVlOyB9XG4gICAgICBkZWJ1ZyhgVXNpbmcgJHtzb3VyY2UubmFtZX0gY3JlZGVudGlhbHMgZm9yIGFjY291bnQgJHthd3NBY2NvdW50SWR9YCk7XG4gICAgICBjb25zdCBwcm92aWRlck9yQ3JlZHMgPSBhd2FpdCBzb3VyY2UuZ2V0UHJvdmlkZXIoYXdzQWNjb3VudElkLCBtb2RlKTtcblxuICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHk6IGlmIHRoZSBwbHVnaW4gcmV0dXJucyBhIFByb3ZpZGVyQ2hhaW4sIHJlc29sdmUgdGhhdCBjaGFpbi5cbiAgICAgIC8vIE90aGVyd2lzZSBpdCBtdXN0IGhhdmUgcmV0dXJuZWQgY3JlZGVudGlhbHMuXG4gICAgICBpZiAoKHByb3ZpZGVyT3JDcmVkcyBhcyBhbnkpLnJlc29sdmVQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCAocHJvdmlkZXJPckNyZWRzIGFzIGFueSkucmVzb2x2ZVByb21pc2UoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm92aWRlck9yQ3JlZHM7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZU5hbWVzID0gWydkZWZhdWx0IGNyZWRlbnRpYWxzJ10uY29uY2F0KHRyaWVkU291cmNlcy5tYXAocyA9PiBzLm5hbWUpKS5qb2luKCcsICcpO1xuICAgIHRocm93IG5ldyBFcnJvcihgTmVlZCB0byBwZXJmb3JtIEFXUyBjYWxscyBmb3IgYWNjb3VudCAke2F3c0FjY291bnRJZH0sIGJ1dCBubyBjcmVkZW50aWFscyBmb3VuZC4gVHJpZWQ6ICR7c291cmNlTmFtZXN9LmApO1xuICB9XG59XG5cbi8qKlxuICogQ2xhc3MgdG8gcmV0cmlldmUgdGhlIGFjY291bnQgZm9yIGRlZmF1bHQgY3JlZGVudGlhbHMgYW5kIGNhY2hlIGl0LlxuICpcbiAqIFVzZXMgdGhlIGRlZmF1bHQgY3JlZGVudGlhbHMgcHJvdmlkZXIgdG8gb2J0YWluIGNyZWRlbnRpYWxzIChpZiBhdmFpbGFibGUpLFxuICogYW5kIHVzZXMgdGhvc2UgY3JlZGVudGlhbHMgdG8gY2FsbCBTVFMgdG8gcmVxdWVzdCB0aGUgY3VycmVudCBhY2NvdW50IElELlxuICpcbiAqIFRoZSBjcmVkZW50aWFscyA9PiBhY2NvdW50SWQgbG9va3VwIGlzIGNhY2hlZCBvbiBkaXNrLCBzaW5jZSBpdCdzXG4gKiBndWFyYW50ZWVkIHRoYXQgaWd2ZW4gYWNjZXNzIGtleSB3aWxsIGFsd2F5cyByZW1haW4gZm9yIHRoZSBzYW1lIGFjY291bnQuXG4gKi9cbmNsYXNzIERlZmF1bHRBV1NBY2NvdW50IHtcbiAgcHJpdmF0ZSBkZWZhdWx0QWNjb3VudEZldGNoZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSBkZWZhdWx0QWNjb3VudElkPzogc3RyaW5nID0gdW5kZWZpbmVkO1xuICBwcml2YXRlIHJlYWRvbmx5IGFjY291bnRDYWNoZSA9IG5ldyBBY2NvdW50QWNjZXNzS2V5Q2FjaGUoKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICAgIHByaXZhdGUgcmVhZG9ubHkgZGVmYXVsdENyZWRlbnRpYWxzUHJvdmlkZXI6IFByb21pc2U8QVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluPixcbiAgICAgIHByaXZhdGUgcmVhZG9ubHkgcmVnaW9uOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4pIHtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGRlZmF1bHQgYWNjb3VudFxuICAgKi9cbiAgcHVibGljIGFzeW5jIGdldCgpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICAgIGlmICghdGhpcy5kZWZhdWx0QWNjb3VudEZldGNoZWQpIHtcbiAgICAgIHRoaXMuZGVmYXVsdEFjY291bnRJZCA9IGF3YWl0IHRoaXMubG9va3VwRGVmYXVsdEFjY291bnQoKTtcbiAgICAgIHRoaXMuZGVmYXVsdEFjY291bnRGZXRjaGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdEFjY291bnRJZDtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgbG9va3VwRGVmYXVsdEFjY291bnQoKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgICB0cnkge1xuICAgICAgLy8gVGhlcmUganVzdCBpcyAqTk8qIHdheSB0byBkbyBBc3N1bWVSb2xlIGNyZWRlbnRpYWxzIGFzIGxvbmcgYXMgQVdTX1NES19MT0FEX0NPTkZJRyBpcyBub3Qgc2V0LiBUaGUgU0RLXG4gICAgICAvLyBjcmFzaCBpZiB0aGUgZmlsZSBkb2VzIG5vdCBleGlzdCB0aG91Z2guIFNvIHNldCB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUgaWYgd2UgY2FuIGZpbmQgdGhhdCBmaWxlLlxuICAgICAgYXdhaXQgc2V0Q29uZmlnVmFyaWFibGUoKTtcblxuICAgICAgZGVidWcoJ1Jlc29sdmluZyBkZWZhdWx0IGNyZWRlbnRpYWxzJyk7XG4gICAgICBjb25zdCBjcmVkZW50aWFsUHJvdmlkZXIgPSBhd2FpdCB0aGlzLmRlZmF1bHRDcmVkZW50aWFsc1Byb3ZpZGVyO1xuICAgICAgY29uc3QgY3JlZHMgPSBhd2FpdCBjcmVkZW50aWFsUHJvdmlkZXIucmVzb2x2ZVByb21pc2UoKTtcblxuICAgICAgY29uc3QgYWNjZXNzS2V5SWQgPSBjcmVkcy5hY2Nlc3NLZXlJZDtcbiAgICAgIGlmICghYWNjZXNzS2V5SWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcmVzb2x2ZSBBV1MgY3JlZGVudGlhbHMgKHNldHVwIHdpdGggXCJhd3MgY29uZmlndXJlXCIpJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFjY291bnRJZCA9IGF3YWl0IHRoaXMuYWNjb3VudENhY2hlLmZldGNoKGNyZWRzLmFjY2Vzc0tleUlkLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIGlmIHdlIGRvbid0IGhhdmUgb25lLCByZXNvbHZlIGZyb20gU1RTIGFuZCBzdG9yZSBpbiBjYWNoZS5cbiAgICAgICAgZGVidWcoJ0xvb2tpbmcgdXAgZGVmYXVsdCBhY2NvdW50IElEIGZyb20gU1RTJyk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG5ldyBBV1MuU1RTKHsgY3JlZGVudGlhbHM6IGNyZWRzLCByZWdpb246IGF3YWl0IHRoaXMucmVnaW9uIH0pLmdldENhbGxlcklkZW50aXR5KCkucHJvbWlzZSgpO1xuICAgICAgICBjb25zdCBhaWQgPSByZXN1bHQuQWNjb3VudDtcbiAgICAgICAgaWYgKCFhaWQpIHtcbiAgICAgICAgICBkZWJ1ZygnU1RTIGRpZG5cXCd0IHJldHVybiBhbiBhY2NvdW50IElEJyk7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZygnRGVmYXVsdCBhY2NvdW50IElEOicsIGFpZCk7XG4gICAgICAgIHJldHVybiBhaWQ7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGFjY291bnRJZDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1ZygnVW5hYmxlIHRvIGRldGVybWluZSB0aGUgZGVmYXVsdCBBV1MgYWNjb3VudCAoZGlkIHlvdSBjb25maWd1cmUgXCJhd3MgY29uZmlndXJlXCI/KTonLCBlKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQnVpbGQgYW4gQVdTIENMSS1jb21wYXRpYmxlIGNyZWRlbnRpYWwgY2hhaW4gcHJvdmlkZXJcbiAqXG4gKiBUaGlzIGlzIHNpbWlsYXIgdG8gdGhlIGRlZmF1bHQgY3JlZGVudGlhbCBwcm92aWRlciBjaGFpbiBjcmVhdGVkIGJ5IHRoZSBTREtcbiAqIGV4Y2VwdCBpdCBhbHNvIGFjY2VwdHMgdGhlIHByb2ZpbGUgYXJndW1lbnQgaW4gdGhlIGNvbnN0cnVjdG9yIChub3QganVzdCBmcm9tXG4gKiB0aGUgZW52aXJvbm1lbnQpLlxuICpcbiAqIFRvIG1pbWljIHRoZSBBV1MgQ0xJIGJlaGF2aW9yOlxuICpcbiAqIC0gd2UgZGVmYXVsdCB0byB+Ly5hd3MvY3JlZGVudGlhbHMgaWYgZW52aXJvbm1lbnQgdmFyaWFibGUgZm9yIGNyZWRlbnRpYWxzXG4gKiBmaWxlIGxvY2F0aW9uIGlzIG5vdCBnaXZlbiAoU0RLIGV4cGVjdHMgZXhwbGljaXQgZW52aXJvbm1lbnQgdmFyaWFibGUgd2l0aCBuYW1lKS5cbiAqIC0gQVdTX0RFRkFVTFRfUFJPRklMRSBpcyBhbHNvIGluc3BlY3RlZCBmb3IgcHJvZmlsZSBuYW1lIChub3QganVzdCBBV1NfUFJPRklMRSkuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG1ha2VDTElDb21wYXRpYmxlQ3JlZGVudGlhbFByb3ZpZGVyKHByb2ZpbGU6IHN0cmluZyB8IHVuZGVmaW5lZCwgZWMyY3JlZHM6IGJvb2xlYW4gfCB1bmRlZmluZWQpIHtcbiAgcHJvZmlsZSA9IHByb2ZpbGUgfHwgcHJvY2Vzcy5lbnYuQVdTX1BST0ZJTEUgfHwgcHJvY2Vzcy5lbnYuQVdTX0RFRkFVTFRfUFJPRklMRSB8fCAnZGVmYXVsdCc7XG5cbiAgLy8gTmVlZCB0byBjb25zdHJ1Y3QgZmlsZW5hbWUgb3Vyc2VsdmVzLCB3aXRob3V0IGFwcHJvcHJpYXRlIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAvLyBubyBkZWZhdWx0cyB1c2VkIGJ5IEpTIFNESy5cbiAgY29uc3QgZmlsZW5hbWUgPSBwcm9jZXNzLmVudi5BV1NfU0hBUkVEX0NSRURFTlRJQUxTX0ZJTEUgfHwgcGF0aC5qb2luKG9zLmhvbWVkaXIoKSwgJy5hd3MnLCAnY3JlZGVudGlhbHMnKTtcblxuICBjb25zdCBzb3VyY2VzID0gW1xuICAgICgpID0+IG5ldyBBV1MuRW52aXJvbm1lbnRDcmVkZW50aWFscygnQVdTJyksXG4gICAgKCkgPT4gbmV3IEFXUy5FbnZpcm9ubWVudENyZWRlbnRpYWxzKCdBTUFaT04nKSxcbiAgXTtcbiAgaWYgKGZzLnBhdGhFeGlzdHMoZmlsZW5hbWUpKSB7XG4gICAgc291cmNlcy5wdXNoKCgpID0+IG5ldyBBV1MuU2hhcmVkSW5pRmlsZUNyZWRlbnRpYWxzKHsgcHJvZmlsZSwgZmlsZW5hbWUgfSkpO1xuICB9XG5cbiAgaWYgKGhhc0Vjc0NyZWRlbnRpYWxzKCkpIHtcbiAgICBzb3VyY2VzLnB1c2goKCkgPT4gbmV3IEFXUy5FQ1NDcmVkZW50aWFscygpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlbHNlIGlmOiBkb24ndCBnZXQgRUMyIGNyZWRzIGlmIHdlIHNob3VsZCBoYXZlIGdvdHRlbiBFQ1MgY3JlZHMtLUVDUyBpbnN0YW5jZXMgYWxzb1xuICAgIC8vIHJ1biBvbiBFQzIgYm94ZXMgYnV0IHRoZSBjcmVkcyByZXByZXNlbnQgc29tZXRoaW5nIGRpZmZlcmVudC4gU2FtZSBiZWhhdmlvciBhc1xuICAgIC8vIHVwc3RyZWFtIGNvZGUuXG5cbiAgICBpZiAoZWMyY3JlZHMgPT09IHVuZGVmaW5lZCkgeyBlYzJjcmVkcyA9IGF3YWl0IGhhc0VjMkNyZWRlbnRpYWxzKCk7IH1cblxuICAgIGlmIChlYzJjcmVkcykge1xuICAgICAgc291cmNlcy5wdXNoKCgpID0+IG5ldyBBV1MuRUMyTWV0YWRhdGFDcmVkZW50aWFscygpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IEFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbihzb3VyY2VzKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGRlZmF1bHQgcmVnaW9uIGluIGEgQ0xJLWNvbXBhdGlibGUgd2F5XG4gKlxuICogTW9zdGx5IGNvcGllZCBmcm9tIG5vZGVfbG9hZGVyLmpzLCBidXQgd2l0aCB0aGUgZm9sbG93aW5nIGRpZmZlcmVuY2VzOlxuICpcbiAqIC0gVGFrZXMgYSBydW50aW1lIHByb2ZpbGUgbmFtZSB0byBsb2FkIHRoZSByZWdpb24gZnJvbSwgbm90IGp1c3QgYmFzZWQgb24gZW52aXJvbm1lbnRcbiAqICAgdmFyaWFibGVzIGF0IHByb2Nlc3Mgc3RhcnQuXG4gKiAtIFdlIGhhdmUgbmVlZGVkIHRvIGNyZWF0ZSBhIGxvY2FsIGNvcHkgb2YgdGhlIFNoYXJlZEluaUZpbGUgY2xhc3MgYmVjYXVzZSB0aGVcbiAqICAgaW1wbGVtZW50YXRpb24gaW4gJ2F3cy1zZGsnIGlzIHByaXZhdGUgKGFuZCB0aGUgZGVmYXVsdCB1c2Ugb2YgaXQgaW4gdGhlXG4gKiAgIFNESyBkb2VzIG5vdCBhbGxvdyB1cyB0byBzcGVjaWZ5IGEgcHJvZmlsZSBhdCBydW50aW1lKS5cbiAqIC0gQVdTX0RFRkFVTFRfUFJPRklMRSBhbmQgQVdTX0RFRkFVTFRfUkVHSU9OIGFyZSBhbHNvIHVzZWQgYXMgZW52aXJvbm1lbnRcbiAqICAgdmFyaWFibGVzIHRvIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSByZWdpb24uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldENMSUNvbXBhdGlibGVEZWZhdWx0UmVnaW9uKHByb2ZpbGU6IHN0cmluZyB8IHVuZGVmaW5lZCk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gIHByb2ZpbGUgPSBwcm9maWxlIHx8IHByb2Nlc3MuZW52LkFXU19QUk9GSUxFIHx8IHByb2Nlc3MuZW52LkFXU19ERUZBVUxUX1BST0ZJTEUgfHwgJ2RlZmF1bHQnO1xuXG4gIC8vIERlZmF1bHRzIGluc2lkZSBjb25zdHJ1Y3RvclxuICBjb25zdCB0b0NoZWNrID0gW1xuICAgIHtmaWxlbmFtZTogcHJvY2Vzcy5lbnYuQVdTX1NIQVJFRF9DUkVERU5USUFMU19GSUxFIH0sXG4gICAge2lzQ29uZmlnOiB0cnVlLCBmaWxlbmFtZTogcHJvY2Vzcy5lbnYuQVdTX0NPTkZJR19GSUxFfSxcbiAgXTtcblxuICBsZXQgcmVnaW9uID0gcHJvY2Vzcy5lbnYuQVdTX1JFR0lPTiB8fCBwcm9jZXNzLmVudi5BTUFaT05fUkVHSU9OIHx8XG4gICAgcHJvY2Vzcy5lbnYuQVdTX0RFRkFVTFRfUkVHSU9OIHx8IHByb2Nlc3MuZW52LkFNQVpPTl9ERUZBVUxUX1JFR0lPTjtcblxuICB3aGlsZSAoIXJlZ2lvbiAmJiB0b0NoZWNrLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBjb25maWdGaWxlID0gbmV3IFNoYXJlZEluaUZpbGUodG9DaGVjay5zaGlmdCgpKTtcbiAgICBjb25zdCBzZWN0aW9uID0gYXdhaXQgY29uZmlnRmlsZS5nZXRQcm9maWxlKHByb2ZpbGUpO1xuICAgIHJlZ2lvbiA9IHNlY3Rpb24gJiYgc2VjdGlvbi5yZWdpb247XG4gIH1cblxuICByZXR1cm4gcmVnaW9uO1xufVxuXG4vKipcbiAqIEZpbmQgYW5kIHJldHVybiB0aGUgY29uZmlndXJlZCBIVFRQUyBwcm94eSBhZGRyZXNzXG4gKi9cbmZ1bmN0aW9uIGh0dHBzUHJveHlGcm9tRW52aXJvbm1lbnQoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHByb2Nlc3MuZW52Lmh0dHBzX3Byb3h5KSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52Lmh0dHBzX3Byb3h5O1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5IVFRQU19QUk9YWSkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5IVFRQU19QUk9YWTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGl0IGxvb2tzIGxpa2Ugd2UnbGwgaGF2ZSBFQ1MgY3JlZGVudGlhbHMgYXZhaWxhYmxlXG4gKi9cbmZ1bmN0aW9uIGhhc0Vjc0NyZWRlbnRpYWxzKCkge1xuICByZXR1cm4gKEFXUy5FQ1NDcmVkZW50aWFscy5wcm90b3R5cGUgYXMgYW55KS5pc0NvbmZpZ3VyZWRGb3JFY3NDcmVkZW50aWFscygpO1xufVxuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIHdlJ3JlIG9uIGFuIEVDMiBpbnN0YW5jZVxuICovXG5hc3luYyBmdW5jdGlvbiBoYXNFYzJDcmVkZW50aWFscygpIHtcbiAgZGVidWcoXCJEZXRlcm1pbmluZyB3aGV0aGVyIHdlJ3JlIG9uIGFuIEVDMiBpbnN0YW5jZS5cIik7XG5cbiAgbGV0IGluc3RhbmNlID0gZmFsc2U7XG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FXU0VDMi9sYXRlc3QvV2luZG93c0d1aWRlL2lkZW50aWZ5X2VjMl9pbnN0YW5jZXMuaHRtbFxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHV0aWwucHJvbWlzaWZ5KGNoaWxkX3Byb2Nlc3MuZXhlYykoJ3dtaWMgcGF0aCB3aW4zMl9jb21wdXRlcnN5c3RlbXByb2R1Y3QgZ2V0IHV1aWQnLCB7IGVuY29kaW5nOiAndXRmLTgnIH0pO1xuICAgIC8vIG91dHB1dCBsb29rcyBsaWtlXG4gICAgLy8gIFVVSURcbiAgICAvLyAgRUMyQUUxNDUtRDFEQy0xM0IyLTk0RUQtMDEyMzRBQkNERUZcbiAgICBjb25zdCBsaW5lcyA9IHJlc3VsdC5zdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgaW5zdGFuY2UgPSBsaW5lcy5zb21lKHggPT4gbWF0Y2hlc1JlZ2V4KC9eZWMyL2ksIHgpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vQVdTRUMyL2xhdGVzdC9Vc2VyR3VpZGUvaWRlbnRpZnlfZWMyX2luc3RhbmNlcy5odG1sXG4gICAgY29uc3QgZmlsZXM6IEFycmF5PFtzdHJpbmcsIFJlZ0V4cF0+ID0gW1xuICAgICAgLy8gVGhpcyByZWNvZ25pemVzIHRoZSBYZW4gaHlwZXJ2aXNvciBiYXNlZCBpbnN0YW5jZXMgKHByZS01dGggZ2VuKVxuICAgICAgWycvc3lzL2h5cGVydmlzb3IvdXVpZCcsIC9eZWMyL2ldLFxuXG4gICAgICAvLyBUaGlzIHJlY29nbml6ZXMgdGhlIG5ldyBIeXBlcnZpc29yICg1dGgtZ2VuIGluc3RhbmNlcyBhbmQgaGlnaGVyKVxuICAgICAgLy8gQ2FuJ3QgdXNlIHRoZSBhZHZlcnRpc2VkIGZpbGUgJy9zeXMvZGV2aWNlcy92aXJ0dWFsL2RtaS9pZC9wcm9kdWN0X3V1aWQnIGJlY2F1c2UgaXQgcmVxdWlyZXMgcm9vdCB0byByZWFkLlxuICAgICAgLy8gSW5zdGVhZCwgc3lzX3ZlbmRvciBjb250YWlucyBzb21ldGhpbmcgbGlrZSAnQW1hem9uIEVDMicuXG4gICAgICBbJy9zeXMvZGV2aWNlcy92aXJ0dWFsL2RtaS9pZC9zeXNfdmVuZG9yJywgL2VjMi9pXSxcbiAgICBdO1xuICAgIGZvciAoY29uc3QgW2ZpbGUsIHJlXSBvZiBmaWxlcykge1xuICAgICAgaWYgKG1hdGNoZXNSZWdleChyZSwgYXdhaXQgcmVhZElmUG9zc2libGUoZmlsZSkpKSB7XG4gICAgICAgIGluc3RhbmNlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGVidWcoaW5zdGFuY2UgPyAnTG9va3MgbGlrZSBFQzIgaW5zdGFuY2UuJyA6ICdEb2VzIG5vdCBsb29rIGxpa2UgRUMyIGluc3RhbmNlLicpO1xuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNldENvbmZpZ1ZhcmlhYmxlKCkge1xuICBjb25zdCBob21lRGlyID0gcHJvY2Vzcy5lbnYuSE9NRSB8fCBwcm9jZXNzLmVudi5VU0VSUFJPRklMRVxuICAgIHx8IChwcm9jZXNzLmVudi5IT01FUEFUSCA/ICgocHJvY2Vzcy5lbnYuSE9NRURSSVZFIHx8ICdDOi8nKSArIHByb2Nlc3MuZW52LkhPTUVQQVRIKSA6IG51bGwpIHx8IG9zLmhvbWVkaXIoKTtcblxuICBpZiAoYXdhaXQgZnMucGF0aEV4aXN0cyhwYXRoLnJlc29sdmUoaG9tZURpciwgJy5hd3MnLCAnY29uZmlnJykpKSB7XG4gICAgcHJvY2Vzcy5lbnYuQVdTX1NES19MT0FEX0NPTkZJRyA9ICcxJztcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiByZWFkSWZQb3NzaWJsZShmaWxlbmFtZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgdHJ5IHtcbiAgICBpZiAoIWF3YWl0IGZzLnBhdGhFeGlzdHMoZmlsZW5hbWUpKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgICByZXR1cm4gZnMucmVhZEZpbGUoZmlsZW5hbWUsIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWJ1ZyhlKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXNSZWdleChyZTogUmVnRXhwLCBzOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgcmV0dXJuIHMgIT09IHVuZGVmaW5lZCAmJiByZS5leGVjKHMpICE9PSBudWxsO1xufVxuIl19
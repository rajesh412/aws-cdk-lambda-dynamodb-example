"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const logging_1 = require("../../logging");
const stack_status_1 = require("./cloudformation/stack-status");
/**
 * Describe a changeset in CloudFormation, regardless of it's current state.
 *
 * @param cfn       a CloudFormation client
 * @param stackName   the name of the Stack the ChangeSet belongs to
 * @param changeSetName the name of the ChangeSet
 *
 * @returns       CloudFormation information about the ChangeSet
 */
async function describeChangeSet(cfn, stackName, changeSetName) {
    const response = await cfn.describeChangeSet({ StackName: stackName, ChangeSetName: changeSetName }).promise();
    return response;
}
/**
 * Describes a stack in CloudFormation, regardless of it's current state.
 *
 * @param cfn     a CloudFormation client
 * @param stackName the name of the stack to be described
 *
 * @returns +undefined+ if the stack does not exist or is deleted, and the CloudFormation stack description otherwise
 */
async function describeStack(cfn, stackName) {
    try {
        const response = await cfn.describeStacks({ StackName: stackName }).promise();
        return response.Stacks && response.Stacks[0];
    }
    catch (e) {
        if (e.code === 'ValidationError' && e.message === `Stack with id ${stackName} does not exist`) {
            return undefined;
        }
        throw e;
    }
}
exports.describeStack = describeStack;
/**
 * Checks whether a stack exists in CloudFormation.
 *
 * @param cfn     a CloudFormation client
 * @param stackName the name of the stack to be checked for
 *
 * @returns     +true+ if the stack exists, regardless of it's current state
 */
async function stackExists(cfn, stackName) {
    const description = await describeStack(cfn, stackName);
    return description !== undefined;
}
exports.stackExists = stackExists;
/**
 * Checks whether a stack has failed creation in CloudFormation. This is identified by the current stack Status being
 * ``ROLLBACK_COMPLETE``.
 *
 * @param cfn       a CloudFormation client
 * @param stackName the name of the stack to be checked for
 *
 * @returns +true+ if the stack exists and is in failed-creation state.
 */
async function stackFailedCreating(cfn, stackName) {
    const description = await describeStack(cfn, stackName);
    return description != null && description.StackStatus === 'ROLLBACK_COMPLETE';
}
exports.stackFailedCreating = stackFailedCreating;
/**
 * Waits for a function to return non-+undefined+ before returning.
 *
 * @param valueProvider a function that will return a value that is not +undefined+ once the wait should be over
 * @param timeout     the time to wait between two calls to +valueProvider+
 *
 * @returns       the value that was returned by +valueProvider+
 */
async function waitFor(valueProvider, timeout = 5000) {
    while (true) {
        const result = await valueProvider();
        if (result === null) {
            return undefined;
        }
        else if (result !== undefined) {
            return result;
        }
        await new Promise(cb => setTimeout(cb, timeout));
    }
}
/**
 * Waits for a ChangeSet to be available for triggering a StackUpdate.
 *
 * @param cfn       a CloudFormation client
 * @param stackName   the name of the Stack that the ChangeSet belongs to
 * @param changeSetName the name of the ChangeSet
 *
 * @returns       the CloudFormation description of the ChangeSet
 */
// tslint:disable-next-line:max-line-length
async function waitForChangeSet(cfn, stackName, changeSetName) {
    logging_1.debug('Waiting for changeset %s on stack %s to finish creating...', changeSetName, stackName);
    return waitFor(async () => {
        const description = await describeChangeSet(cfn, stackName, changeSetName);
        // The following doesn't use a switch because tsc will not allow fall-through, UNLESS it is allows
        // EVERYWHERE that uses this library directly or indirectly, which is undesirable.
        if (description.Status === 'CREATE_PENDING' || description.Status === 'CREATE_IN_PROGRESS') {
            logging_1.debug('Changeset %s on stack %s is still creating', changeSetName, stackName);
            return undefined;
        }
        else if (description.Status === 'CREATE_COMPLETE') {
            return description;
        }
        else if (description.Status === 'FAILED') {
            if (description.StatusReason && description.StatusReason.startsWith('The submitted information didn\'t contain changes.')) {
                return description;
            }
        }
        // tslint:disable-next-line:max-line-length
        throw new Error(`Failed to create ChangeSet ${changeSetName} on ${stackName}: ${description.Status || 'NO_STATUS'}, ${description.StatusReason || 'no reason provided'}`);
    });
}
exports.waitForChangeSet = waitForChangeSet;
/**
 * Waits for a CloudFormation stack to stabilize in a complete/available state.
 *
 * @param cfn        a CloudFormation client
 * @param stackName      the name of the stack to wait for
 * @param failOnDeletedStack whether to fail if the awaited stack is deleted.
 *
 * @returns     the CloudFormation description of the stabilized stack
 */
async function waitForStack(cfn, stackName, failOnDeletedStack = true) {
    logging_1.debug('Waiting for stack %s to finish creating or updating...', stackName);
    return waitFor(async () => {
        const description = await describeStack(cfn, stackName);
        if (!description) {
            logging_1.debug('Stack %s does not exist', stackName);
            return null;
        }
        const status = stack_status_1.StackStatus.fromStackDescription(description);
        if (!status.isStable) {
            logging_1.debug('Stack %s is still not stable (%s)', stackName, status);
            return undefined;
        }
        if (status.isCreationFailure) {
            throw new Error(`The stack named ${stackName} failed creation, it may need to be manually deleted from the AWS console: ${status}`);
        }
        else if (!status.isSuccess) {
            throw new Error(`The stack named ${stackName} is in a failed state: ${status}`);
        }
        else if (status.isDeleted) {
            if (failOnDeletedStack) {
                throw new Error(`The stack named ${stackName} was deleted`);
            }
            return undefined;
        }
        return description;
    });
}
exports.waitForStack = waitForStack;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xvdWRmb3JtYXRpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjbG91ZGZvcm1hdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUNBLDJDQUFzQztBQUN0QyxnRUFBNEQ7QUFFNUQ7Ozs7Ozs7O0dBUUc7QUFDSCxLQUFLLFVBQVUsaUJBQWlCLENBQUMsR0FBbUIsRUFBRSxTQUFpQixFQUFFLGFBQXFCO0lBQzVGLE1BQU0sUUFBUSxHQUFHLE1BQU0sR0FBRyxDQUFDLGlCQUFpQixDQUFDLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxhQUFhLEVBQUUsYUFBYSxFQUFFLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUMvRyxPQUFPLFFBQVEsQ0FBQztBQUNsQixDQUFDO0FBRUQ7Ozs7Ozs7R0FPRztBQUNJLEtBQUssVUFBVSxhQUFhLENBQUMsR0FBbUIsRUFBRSxTQUFpQjtJQUN4RSxJQUFJO1FBQ0YsTUFBTSxRQUFRLEdBQUcsTUFBTSxHQUFHLENBQUMsY0FBYyxDQUFDLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDOUUsT0FBTyxRQUFRLENBQUMsTUFBTSxJQUFJLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDOUM7SUFBQyxPQUFPLENBQUMsRUFBRTtRQUNWLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxpQkFBaUIsSUFBSSxDQUFDLENBQUMsT0FBTyxLQUFLLGlCQUFpQixTQUFTLGlCQUFpQixFQUFFO1lBQzdGLE9BQU8sU0FBUyxDQUFDO1NBQ2xCO1FBQ0QsTUFBTSxDQUFDLENBQUM7S0FDVDtBQUNILENBQUM7QUFWRCxzQ0FVQztBQUVEOzs7Ozs7O0dBT0c7QUFDSSxLQUFLLFVBQVUsV0FBVyxDQUFDLEdBQW1CLEVBQUUsU0FBaUI7SUFDdEUsTUFBTSxXQUFXLEdBQUcsTUFBTSxhQUFhLENBQUMsR0FBRyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQ3hE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SUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUU7WUFDcEIsZUFBSyxDQUFDLG1DQUFtQyxFQUFFLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQztZQUM5RCxPQUFPLFNBQVMsQ0FBQztTQUNsQjtRQUNELElBQUksTUFBTSxDQUFDLGlCQUFpQixFQUFFO1lBQzVCLE1BQU0sSUFBSSxLQUFLLENBQUMsbUJBQW1CLFNBQVMsOEVBQThFLE1BQU0sRUFBRSxDQUFDLENBQUM7U0FDckk7YUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRTtZQUM1QixNQUFNLElBQUksS0FBSyxDQUFDLG1CQUFtQixTQUFTLDBCQUEwQixNQUFNLEVBQUUsQ0FBQyxDQUFDO1NBQ2pGO2FBQU0sSUFBSSxNQUFNLENBQUMsU0FBUyxFQUFFO1lBQzNCLElBQUksa0JBQWtCLEVBQUU7Z0JBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQkFBbUIsU0FBUyxjQUFjLENBQUMsQ0FBQzthQUFFO1lBQ3hGLE9BQU8sU0FBUyxDQUFDO1NBQ2xCO1FBQ0QsT0FBTyxXQUFXLENBQUM7SUFDckIsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDO0FBekJELG9DQXlCQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENsb3VkRm9ybWF0aW9uIH0gZnJvbSAnYXdzLXNkayc7XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4uLy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHsgU3RhY2tTdGF0dXMgfSBmcm9tICcuL2Nsb3VkZm9ybWF0aW9uL3N0YWNrLXN0YXR1cyc7XG5cbi8qKlxuICogRGVzY3JpYmUgYSBjaGFuZ2VzZXQgaW4gQ2xvdWRGb3JtYXRpb24sIHJlZ2FyZGxlc3Mgb2YgaXQncyBjdXJyZW50IHN0YXRlLlxuICpcbiAqIEBwYXJhbSBjZm4gICAgICAgYSBDbG91ZEZvcm1hdGlvbiBjbGllbnRcbiAqIEBwYXJhbSBzdGFja05hbWUgICB0aGUgbmFtZSBvZiB0aGUgU3RhY2sgdGhlIENoYW5nZVNldCBiZWxvbmdzIHRvXG4gKiBAcGFyYW0gY2hhbmdlU2V0TmFtZSB0aGUgbmFtZSBvZiB0aGUgQ2hhbmdlU2V0XG4gKlxuICogQHJldHVybnMgICAgICAgQ2xvdWRGb3JtYXRpb24gaW5mb3JtYXRpb24gYWJvdXQgdGhlIENoYW5nZVNldFxuICovXG5hc3luYyBmdW5jdGlvbiBkZXNjcmliZUNoYW5nZVNldChjZm46IENsb3VkRm9ybWF0aW9uLCBzdGFja05hbWU6IHN0cmluZywgY2hhbmdlU2V0TmFtZTogc3RyaW5nKTogUHJvbWlzZTxDbG91ZEZvcm1hdGlvbi5EZXNjcmliZUNoYW5nZVNldE91dHB1dD4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNmbi5kZXNjcmliZUNoYW5nZVNldCh7IFN0YWNrTmFtZTogc3RhY2tOYW1lLCBDaGFuZ2VTZXROYW1lOiBjaGFuZ2VTZXROYW1lIH0pLnByb21pc2UoKTtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufVxuXG4vKipcbiAqIERlc2NyaWJlcyBhIHN0YWNrIGluIENsb3VkRm9ybWF0aW9uLCByZWdhcmRsZXNzIG9mIGl0J3MgY3VycmVudCBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0gY2ZuICAgICBhIENsb3VkRm9ybWF0aW9uIGNsaWVudFxuICogQHBhcmFtIHN0YWNrTmFtZSB0aGUgbmFtZSBvZiB0aGUgc3RhY2sgdG8gYmUgZGVzY3JpYmVkXG4gKlxuICogQHJldHVybnMgK3VuZGVmaW5lZCsgaWYgdGhlIHN0YWNrIGRvZXMgbm90IGV4aXN0IG9yIGlzIGRlbGV0ZWQsIGFuZCB0aGUgQ2xvdWRGb3JtYXRpb24gc3RhY2sgZGVzY3JpcHRpb24gb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZXNjcmliZVN0YWNrKGNmbjogQ2xvdWRGb3JtYXRpb24sIHN0YWNrTmFtZTogc3RyaW5nKTogUHJvbWlzZTxDbG91ZEZvcm1hdGlvbi5TdGFjayB8IHVuZGVmaW5lZD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2ZuLmRlc2NyaWJlU3RhY2tzKHsgU3RhY2tOYW1lOiBzdGFja05hbWUgfSkucHJvbWlzZSgpO1xuICAgIHJldHVybiByZXNwb25zZS5TdGFja3MgJiYgcmVzcG9uc2UuU3RhY2tzWzBdO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUuY29kZSA9PT0gJ1ZhbGlkYXRpb25FcnJvcicgJiYgZS5tZXNzYWdlID09PSBgU3RhY2sgd2l0aCBpZCAke3N0YWNrTmFtZX0gZG9lcyBub3QgZXhpc3RgKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBzdGFjayBleGlzdHMgaW4gQ2xvdWRGb3JtYXRpb24uXG4gKlxuICogQHBhcmFtIGNmbiAgICAgYSBDbG91ZEZvcm1hdGlvbiBjbGllbnRcbiAqIEBwYXJhbSBzdGFja05hbWUgdGhlIG5hbWUgb2YgdGhlIHN0YWNrIHRvIGJlIGNoZWNrZWQgZm9yXG4gKlxuICogQHJldHVybnMgICAgICt0cnVlKyBpZiB0aGUgc3RhY2sgZXhpc3RzLCByZWdhcmRsZXNzIG9mIGl0J3MgY3VycmVudCBzdGF0ZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RhY2tFeGlzdHMoY2ZuOiBDbG91ZEZvcm1hdGlvbiwgc3RhY2tOYW1lOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSBhd2FpdCBkZXNjcmliZVN0YWNrKGNmbiwgc3RhY2tOYW1lKTtcbiAgcmV0dXJuIGRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBzdGFjayBoYXMgZmFpbGVkIGNyZWF0aW9uIGluIENsb3VkRm9ybWF0aW9uLiBUaGlzIGlzIGlkZW50aWZpZWQgYnkgdGhlIGN1cnJlbnQgc3RhY2sgU3RhdHVzIGJlaW5nXG4gKiBgYFJPTExCQUNLX0NPTVBMRVRFYGAuXG4gKlxuICogQHBhcmFtIGNmbiAgICAgICBhIENsb3VkRm9ybWF0aW9uIGNsaWVudFxuICogQHBhcmFtIHN0YWNrTmFtZSB0aGUgbmFtZSBvZiB0aGUgc3RhY2sgdG8gYmUgY2hlY2tlZCBmb3JcbiAqXG4gKiBAcmV0dXJucyArdHJ1ZSsgaWYgdGhlIHN0YWNrIGV4aXN0cyBhbmQgaXMgaW4gZmFpbGVkLWNyZWF0aW9uIHN0YXRlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RhY2tGYWlsZWRDcmVhdGluZyhjZm46IENsb3VkRm9ybWF0aW9uLCBzdGFja05hbWU6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICBjb25zdCBkZXNjcmlwdGlvbiA9IGF3YWl0IGRlc2NyaWJlU3RhY2soY2ZuLCBzdGFja05hbWUpO1xuICByZXR1cm4gZGVzY3JpcHRpb24gIT0gbnVsbCAmJiBkZXNjcmlwdGlvbi5TdGFja1N0YXR1cyA9PT0gJ1JPTExCQUNLX0NPTVBMRVRFJztcbn1cblxuLyoqXG4gKiBXYWl0cyBmb3IgYSBmdW5jdGlvbiB0byByZXR1cm4gbm9uLSt1bmRlZmluZWQrIGJlZm9yZSByZXR1cm5pbmcuXG4gKlxuICogQHBhcmFtIHZhbHVlUHJvdmlkZXIgYSBmdW5jdGlvbiB0aGF0IHdpbGwgcmV0dXJuIGEgdmFsdWUgdGhhdCBpcyBub3QgK3VuZGVmaW5lZCsgb25jZSB0aGUgd2FpdCBzaG91bGQgYmUgb3ZlclxuICogQHBhcmFtIHRpbWVvdXQgICAgIHRoZSB0aW1lIHRvIHdhaXQgYmV0d2VlbiB0d28gY2FsbHMgdG8gK3ZhbHVlUHJvdmlkZXIrXG4gKlxuICogQHJldHVybnMgICAgICAgdGhlIHZhbHVlIHRoYXQgd2FzIHJldHVybmVkIGJ5ICt2YWx1ZVByb3ZpZGVyK1xuICovXG5hc3luYyBmdW5jdGlvbiB3YWl0Rm9yPFQ+KHZhbHVlUHJvdmlkZXI6ICgpID0+IFByb21pc2U8VCB8IG51bGwgfCB1bmRlZmluZWQ+LCB0aW1lb3V0OiBudW1iZXIgPSA1MDAwKTogUHJvbWlzZTxUIHwgdW5kZWZpbmVkPiB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsdWVQcm92aWRlcigpO1xuICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXdhaXQgbmV3IFByb21pc2UoY2IgPT4gc2V0VGltZW91dChjYiwgdGltZW91dCkpO1xuICB9XG59XG5cbi8qKlxuICogV2FpdHMgZm9yIGEgQ2hhbmdlU2V0IHRvIGJlIGF2YWlsYWJsZSBmb3IgdHJpZ2dlcmluZyBhIFN0YWNrVXBkYXRlLlxuICpcbiAqIEBwYXJhbSBjZm4gICAgICAgYSBDbG91ZEZvcm1hdGlvbiBjbGllbnRcbiAqIEBwYXJhbSBzdGFja05hbWUgICB0aGUgbmFtZSBvZiB0aGUgU3RhY2sgdGhhdCB0aGUgQ2hhbmdlU2V0IGJlbG9uZ3MgdG9cbiAqIEBwYXJhbSBjaGFuZ2VTZXROYW1lIHRoZSBuYW1lIG9mIHRoZSBDaGFuZ2VTZXRcbiAqXG4gKiBAcmV0dXJucyAgICAgICB0aGUgQ2xvdWRGb3JtYXRpb24gZGVzY3JpcHRpb24gb2YgdGhlIENoYW5nZVNldFxuICovXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2FpdEZvckNoYW5nZVNldChjZm46IENsb3VkRm9ybWF0aW9uLCBzdGFja05hbWU6IHN0cmluZywgY2hhbmdlU2V0TmFtZTogc3RyaW5nKTogUHJvbWlzZTxDbG91ZEZvcm1hdGlvbi5EZXNjcmliZUNoYW5nZVNldE91dHB1dCB8IHVuZGVmaW5lZD4ge1xuICBkZWJ1ZygnV2FpdGluZyBmb3IgY2hhbmdlc2V0ICVzIG9uIHN0YWNrICVzIHRvIGZpbmlzaCBjcmVhdGluZy4uLicsIGNoYW5nZVNldE5hbWUsIHN0YWNrTmFtZSk7XG4gIHJldHVybiB3YWl0Rm9yKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGF3YWl0IGRlc2NyaWJlQ2hhbmdlU2V0KGNmbiwgc3RhY2tOYW1lLCBjaGFuZ2VTZXROYW1lKTtcbiAgICAvLyBUaGUgZm9sbG93aW5nIGRvZXNuJ3QgdXNlIGEgc3dpdGNoIGJlY2F1c2UgdHNjIHdpbGwgbm90IGFsbG93IGZhbGwtdGhyb3VnaCwgVU5MRVNTIGl0IGlzIGFsbG93c1xuICAgIC8vIEVWRVJZV0hFUkUgdGhhdCB1c2VzIHRoaXMgbGlicmFyeSBkaXJlY3RseSBvciBpbmRpcmVjdGx5LCB3aGljaCBpcyB1bmRlc2lyYWJsZS5cbiAgICBpZiAoZGVzY3JpcHRpb24uU3RhdHVzID09PSAnQ1JFQVRFX1BFTkRJTkcnIHx8IGRlc2NyaXB0aW9uLlN0YXR1cyA9PT0gJ0NSRUFURV9JTl9QUk9HUkVTUycpIHtcbiAgICAgIGRlYnVnKCdDaGFuZ2VzZXQgJXMgb24gc3RhY2sgJXMgaXMgc3RpbGwgY3JlYXRpbmcnLCBjaGFuZ2VTZXROYW1lLCBzdGFja05hbWUpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKGRlc2NyaXB0aW9uLlN0YXR1cyA9PT0gJ0NSRUFURV9DT01QTEVURScpIHtcbiAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICB9IGVsc2UgaWYgKGRlc2NyaXB0aW9uLlN0YXR1cyA9PT0gJ0ZBSUxFRCcpIHtcbiAgICAgIGlmIChkZXNjcmlwdGlvbi5TdGF0dXNSZWFzb24gJiYgZGVzY3JpcHRpb24uU3RhdHVzUmVhc29uLnN0YXJ0c1dpdGgoJ1RoZSBzdWJtaXR0ZWQgaW5mb3JtYXRpb24gZGlkblxcJ3QgY29udGFpbiBjaGFuZ2VzLicpKSB7XG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1saW5lLWxlbmd0aFxuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBDaGFuZ2VTZXQgJHtjaGFuZ2VTZXROYW1lfSBvbiAke3N0YWNrTmFtZX06ICR7ZGVzY3JpcHRpb24uU3RhdHVzIHx8ICdOT19TVEFUVVMnfSwgJHtkZXNjcmlwdGlvbi5TdGF0dXNSZWFzb24gfHwgJ25vIHJlYXNvbiBwcm92aWRlZCd9YCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFdhaXRzIGZvciBhIENsb3VkRm9ybWF0aW9uIHN0YWNrIHRvIHN0YWJpbGl6ZSBpbiBhIGNvbXBsZXRlL2F2YWlsYWJsZSBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0gY2ZuICAgICAgICBhIENsb3VkRm9ybWF0aW9uIGNsaWVudFxuICogQHBhcmFtIHN0YWNrTmFtZSAgICAgIHRoZSBuYW1lIG9mIHRoZSBzdGFjayB0byB3YWl0IGZvclxuICogQHBhcmFtIGZhaWxPbkRlbGV0ZWRTdGFjayB3aGV0aGVyIHRvIGZhaWwgaWYgdGhlIGF3YWl0ZWQgc3RhY2sgaXMgZGVsZXRlZC5cbiAqXG4gKiBAcmV0dXJucyAgICAgdGhlIENsb3VkRm9ybWF0aW9uIGRlc2NyaXB0aW9uIG9mIHRoZSBzdGFiaWxpemVkIHN0YWNrXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3YWl0Rm9yU3RhY2soY2ZuOiBDbG91ZEZvcm1hdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tOYW1lOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWxPbkRlbGV0ZWRTdGFjazogYm9vbGVhbiA9IHRydWUpOiBQcm9taXNlPENsb3VkRm9ybWF0aW9uLlN0YWNrIHwgdW5kZWZpbmVkPiB7XG4gIGRlYnVnKCdXYWl0aW5nIGZvciBzdGFjayAlcyB0byBmaW5pc2ggY3JlYXRpbmcgb3IgdXBkYXRpbmcuLi4nLCBzdGFja05hbWUpO1xuICByZXR1cm4gd2FpdEZvcihhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSBhd2FpdCBkZXNjcmliZVN0YWNrKGNmbiwgc3RhY2tOYW1lKTtcbiAgICBpZiAoIWRlc2NyaXB0aW9uKSB7XG4gICAgICBkZWJ1ZygnU3RhY2sgJXMgZG9lcyBub3QgZXhpc3QnLCBzdGFja05hbWUpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHN0YXR1cyA9IFN0YWNrU3RhdHVzLmZyb21TdGFja0Rlc2NyaXB0aW9uKGRlc2NyaXB0aW9uKTtcbiAgICBpZiAoIXN0YXR1cy5pc1N0YWJsZSkge1xuICAgICAgZGVidWcoJ1N0YWNrICVzIGlzIHN0aWxsIG5vdCBzdGFibGUgKCVzKScsIHN0YWNrTmFtZSwgc3RhdHVzKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChzdGF0dXMuaXNDcmVhdGlvbkZhaWx1cmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHN0YWNrIG5hbWVkICR7c3RhY2tOYW1lfSBmYWlsZWQgY3JlYXRpb24sIGl0IG1heSBuZWVkIHRvIGJlIG1hbnVhbGx5IGRlbGV0ZWQgZnJvbSB0aGUgQVdTIGNvbnNvbGU6ICR7c3RhdHVzfWApO1xuICAgIH0gZWxzZSBpZiAoIXN0YXR1cy5pc1N1Y2Nlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHN0YWNrIG5hbWVkICR7c3RhY2tOYW1lfSBpcyBpbiBhIGZhaWxlZCBzdGF0ZTogJHtzdGF0dXN9YCk7XG4gICAgfSBlbHNlIGlmIChzdGF0dXMuaXNEZWxldGVkKSB7XG4gICAgICBpZiAoZmFpbE9uRGVsZXRlZFN0YWNrKSB7IHRocm93IG5ldyBFcnJvcihgVGhlIHN0YWNrIG5hbWVkICR7c3RhY2tOYW1lfSB3YXMgZGVsZXRlZGApOyB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gZGVzY3JpcHRpb247XG4gIH0pO1xufVxuIl19
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const colors = require("colors/safe");
const archive_1 = require("../archive");
const logging_1 = require("../logging");
const credentials_1 = require("./aws-auth/credentials");
const bootstrap_environment_1 = require("./bootstrap-environment");
const cloudformation_1 = require("./util/cloudformation");
class ToolkitInfo {
    constructor(props) {
        this.props = props;
        /**
         * A cache of previous uploads done in this session
         */
        this.previousUploads = {};
        this.sdk = props.sdk;
    }
    get bucketUrl() {
        return `https://${this.props.bucketEndpoint}`;
    }
    get bucketName() {
        return this.props.bucketName;
    }
    /**
     * Uploads a data blob to S3 under the specified key prefix.
     * Uses md5 hash to render the full key and skips upload if an object
     * already exists by this key.
     */
    async uploadIfChanged(data, props) {
        const s3 = await this.props.sdk.s3(this.props.environment, credentials_1.Mode.ForWriting);
        const s3KeyPrefix = props.s3KeyPrefix || '';
        const s3KeySuffix = props.s3KeySuffix || '';
        const bucket = this.props.bucketName;
        const hash = archive_1.md5hash(data);
        const filename = `${hash}${s3KeySuffix}`;
        const key = `${s3KeyPrefix}${filename}`;
        const url = `s3://${bucket}/${key}`;
        logging_1.debug(`${url}: checking if already exists`);
        if (await objectExists(s3, bucket, key)) {
            logging_1.debug(`${url}: found (skipping upload)`);
            return { filename, key, changed: false };
        }
        const uploaded = { filename, key, changed: true };
        // Upload if it's new or server-side copy if it was already uploaded previously
        const previous = this.previousUploads[hash];
        if (previous) {
            logging_1.debug(`${url}: copying`);
            await s3.copyObject({
                Bucket: bucket,
                Key: key,
                CopySource: `${bucket}/${previous.key}`
            }).promise();
            logging_1.debug(`${url}: copy complete`);
        }
        else {
            logging_1.debug(`${url}: uploading`);
            await s3.putObject({
                Bucket: bucket,
                Key: key,
                Body: data,
                ContentType: props.contentType
            }).promise();
            logging_1.debug(`${url}: upload complete`);
            this.previousUploads[hash] = uploaded;
        }
        return uploaded;
    }
    /**
     * Prepare an ECR repository for uploading to using Docker
     */
    async prepareEcrRepository(id, imageTag) {
        const ecr = await this.props.sdk.ecr(this.props.environment, credentials_1.Mode.ForWriting);
        // Create the repository if it doesn't exist yet
        const repositoryName = 'cdk/' + id.replace(/[:/]/g, '-').toLowerCase();
        let repository;
        try {
            logging_1.debug(`${repositoryName}: checking for repository.`);
            const describeResponse = await ecr.describeRepositories({ repositoryNames: [repositoryName] }).promise();
            repository = describeResponse.repositories[0];
        }
        catch (e) {
            if (e.code !== 'RepositoryNotFoundException') {
                throw e;
            }
        }
        if (repository) {
            try {
                logging_1.debug(`${repositoryName}: checking for image ${imageTag}`);
                await ecr.describeImages({ repositoryName, imageIds: [{ imageTag }] }).promise();
                // If we got here, the image already exists. Nothing else needs to be done.
                return {
                    alreadyExists: true,
                    repositoryUri: repository.repositoryUri,
                    repositoryName
                };
            }
            catch (e) {
                if (e.code !== 'ImageNotFoundException') {
                    throw e;
                }
            }
        }
        else {
            logging_1.debug(`${repositoryName}: creating`);
            const response = await ecr.createRepository({ repositoryName }).promise();
            repository = response.repository;
            // Better put a lifecycle policy on this so as to not cost too much money
            await ecr.putLifecyclePolicy({
                repositoryName,
                lifecyclePolicyText: JSON.stringify(DEFAULT_REPO_LIFECYCLE)
            }).promise();
        }
        // The repo exists, image just needs to be uploaded. Get auth to do so.
        logging_1.debug(`Fetching ECR authorization token`);
        const authData = (await ecr.getAuthorizationToken({}).promise()).authorizationData || [];
        if (authData.length === 0) {
            throw new Error('No authorization data received from ECR');
        }
        const token = Buffer.from(authData[0].authorizationToken, 'base64').toString('ascii');
        const [username, password] = token.split(':');
        return {
            alreadyExists: false,
            repositoryUri: repository.repositoryUri,
            repositoryName,
            username,
            password,
            endpoint: authData[0].proxyEndpoint,
        };
    }
}
exports.ToolkitInfo = ToolkitInfo;
async function objectExists(s3, bucket, key) {
    try {
        await s3.headObject({ Bucket: bucket, Key: key }).promise();
        return true;
    }
    catch (e) {
        if (e.code === 'NotFound') {
            return false;
        }
        throw e;
    }
}
async function loadToolkitInfo(environment, sdk, stackName) {
    const cfn = await sdk.cloudFormation(environment, credentials_1.Mode.ForReading);
    const stack = await cloudformation_1.waitForStack(cfn, stackName);
    if (!stack) {
        logging_1.debug('The environment %s doesn\'t have the CDK toolkit stack (%s) installed. Use %s to setup your environment for use with the toolkit.', environment.name, stackName, colors.blue(`cdk bootstrap "${environment.name}"`));
        return undefined;
    }
    return new ToolkitInfo({
        sdk, environment,
        bucketName: getOutputValue(stack, bootstrap_environment_1.BUCKET_NAME_OUTPUT),
        bucketEndpoint: getOutputValue(stack, bootstrap_environment_1.BUCKET_DOMAIN_NAME_OUTPUT)
    });
}
exports.loadToolkitInfo = loadToolkitInfo;
function getOutputValue(stack, output) {
    let result;
    if (stack.Outputs) {
        const found = stack.Outputs.find(o => o.OutputKey === output);
        result = found && found.OutputValue;
    }
    if (result === undefined) {
        throw new Error(`The CDK toolkit stack (${stack.StackName}) does not have an output named ${output}. Use 'cdk bootstrap' to correct this.`);
    }
    return result;
}
const DEFAULT_REPO_LIFECYCLE = {
    rules: [
        {
            rulePriority: 100,
            description: 'Retain only 5 images',
            selection: {
                tagStatus: 'any',
                countType: 'imageCountMoreThan',
                countNumber: 5,
            },
            action: { type: 'expire' }
        }
    ]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9vbGtpdC1pbmZvLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsidG9vbGtpdC1pbmZvLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUEsc0NBQXVDO0FBQ3ZDLHdDQUFxQztBQUNyQyx3Q0FBbUM7QUFDbkMsd0RBQThDO0FBQzlDLG1FQUF5RjtBQUN6RiwwREFBcUQ7QUFlckQsTUFBYSxXQUFXO0lBUXRCLFlBQTZCLEtBSzVCO1FBTDRCLFVBQUssR0FBTCxLQUFLLENBS2pDO1FBVkQ7O1dBRUc7UUFDYyxvQkFBZSxHQUE4QixFQUFFLENBQUM7UUFRL0QsSUFBSSxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDO0lBQ3ZCLENBQUM7SUFFRCxJQUFXLFNBQVM7UUFDbEIsT0FBTyxXQUFXLElBQUksQ0FBQyxLQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7SUFDaEQsQ0FBQztJQUVELElBQVcsVUFBVTtRQUNuQixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDO0lBQy9CLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksS0FBSyxDQUFDLGVBQWUsQ0FBQyxJQUFTLEVBQUUsS0FBa0I7UUFDeEQsTUFBTSxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUUsa0JBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUU1RSxNQUFNLFdBQVcsR0FBRyxLQUFLLENBQUMsV0FBVyxJQUFJLEVBQUUsQ0FBQztRQUM1QyxNQUFNLFdBQVcsR0FBRyxLQUFLLENBQUMsV0FBVyxJQUFJLEVBQUUsQ0FBQztRQUU1QyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQztRQUVyQyxNQUFNLElBQUksR0FBRyxpQkFBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzNCLE1BQU0sUUFBUSxHQUFHLEdBQUcsSUFBSSxHQUFHLFdB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cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGN4YXBpID0gcmVxdWlyZSgnQGF3cy1jZGsvY3gtYXBpJyk7XG5pbXBvcnQgYXdzID0gcmVxdWlyZSgnYXdzLXNkaycpO1xuaW1wb3J0IGNvbG9ycyA9IHJlcXVpcmUoJ2NvbG9ycy9zYWZlJyk7XG5pbXBvcnQgeyBtZDVoYXNoIH0gZnJvbSAnLi4vYXJjaGl2ZSc7XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHsgTW9kZSB9IGZyb20gJy4vYXdzLWF1dGgvY3JlZGVudGlhbHMnO1xuaW1wb3J0IHsgQlVDS0VUX0RPTUFJTl9OQU1FX09VVFBVVCwgQlVDS0VUX05BTUVfT1VUUFVUICB9IGZyb20gJy4vYm9vdHN0cmFwLWVudmlyb25tZW50JztcbmltcG9ydCB7IHdhaXRGb3JTdGFjayB9IGZyb20gJy4vdXRpbC9jbG91ZGZvcm1hdGlvbic7XG5pbXBvcnQgeyBTREsgfSBmcm9tICcuL3V0aWwvc2RrJztcblxuZXhwb3J0IGludGVyZmFjZSBVcGxvYWRQcm9wcyB7XG4gIHMzS2V5UHJlZml4Pzogc3RyaW5nLFxuICBzM0tleVN1ZmZpeD86IHN0cmluZyxcbiAgY29udGVudFR5cGU/OiBzdHJpbmcsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXBsb2FkZWQge1xuICBmaWxlbmFtZTogc3RyaW5nO1xuICBrZXk6IHN0cmluZztcbiAgY2hhbmdlZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNsYXNzIFRvb2xraXRJbmZvIHtcbiAgcHVibGljIHJlYWRvbmx5IHNkazogU0RLO1xuXG4gIC8qKlxuICAgKiBBIGNhY2hlIG9mIHByZXZpb3VzIHVwbG9hZHMgZG9uZSBpbiB0aGlzIHNlc3Npb25cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgcHJldmlvdXNVcGxvYWRzOiB7W2tleTogc3RyaW5nXTogVXBsb2FkZWR9ID0ge307XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBwcm9wczoge1xuICAgIHNkazogU0RLLFxuICAgIGJ1Y2tldE5hbWU6IHN0cmluZyxcbiAgICBidWNrZXRFbmRwb2ludDogc3RyaW5nLFxuICAgIGVudmlyb25tZW50OiBjeGFwaS5FbnZpcm9ubWVudFxuICB9KSB7XG4gICAgdGhpcy5zZGsgPSBwcm9wcy5zZGs7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGJ1Y2tldFVybCgpIHtcbiAgICByZXR1cm4gYGh0dHBzOi8vJHt0aGlzLnByb3BzLmJ1Y2tldEVuZHBvaW50fWA7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGJ1Y2tldE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuYnVja2V0TmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGxvYWRzIGEgZGF0YSBibG9iIHRvIFMzIHVuZGVyIHRoZSBzcGVjaWZpZWQga2V5IHByZWZpeC5cbiAgICogVXNlcyBtZDUgaGFzaCB0byByZW5kZXIgdGhlIGZ1bGwga2V5IGFuZCBza2lwcyB1cGxvYWQgaWYgYW4gb2JqZWN0XG4gICAqIGFscmVhZHkgZXhpc3RzIGJ5IHRoaXMga2V5LlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHVwbG9hZElmQ2hhbmdlZChkYXRhOiBhbnksIHByb3BzOiBVcGxvYWRQcm9wcyk6IFByb21pc2U8VXBsb2FkZWQ+IHtcbiAgICBjb25zdCBzMyA9IGF3YWl0IHRoaXMucHJvcHMuc2RrLnMzKHRoaXMucHJvcHMuZW52aXJvbm1lbnQsIE1vZGUuRm9yV3JpdGluZyk7XG5cbiAgICBjb25zdCBzM0tleVByZWZpeCA9IHByb3BzLnMzS2V5UHJlZml4IHx8ICcnO1xuICAgIGNvbnN0IHMzS2V5U3VmZml4ID0gcHJvcHMuczNLZXlTdWZmaXggfHwgJyc7XG5cbiAgICBjb25zdCBidWNrZXQgPSB0aGlzLnByb3BzLmJ1Y2tldE5hbWU7XG5cbiAgICBjb25zdCBoYXNoID0gbWQ1aGFzaChkYXRhKTtcbiAgICBjb25zdCBmaWxlbmFtZSA9IGAke2hhc2h9JHtzM0tleVN1ZmZpeH1gO1xuICAgIGNvbnN0IGtleSA9IGAke3MzS2V5UHJlZml4fSR7ZmlsZW5hbWV9YDtcbiAgICBjb25zdCB1cmwgPSBgczM6Ly8ke2J1Y2tldH0vJHtrZXl9YDtcblxuICAgIGRlYnVnKGAke3VybH06IGNoZWNraW5nIGlmIGFscmVhZHkgZXhpc3RzYCk7XG4gICAgaWYgKGF3YWl0IG9iamVjdEV4aXN0cyhzMywgYnVja2V0LCBrZXkpKSB7XG4gICAgICBkZWJ1ZyhgJHt1cmx9OiBmb3VuZCAoc2tpcHBpbmcgdXBsb2FkKWApO1xuICAgICAgcmV0dXJuIHsgZmlsZW5hbWUsIGtleSwgY2hhbmdlZDogZmFsc2UgfTtcbiAgICB9XG5cbiAgICBjb25zdCB1cGxvYWRlZCA9IHsgZmlsZW5hbWUsIGtleSwgY2hhbmdlZDogdHJ1ZSB9O1xuXG4gICAgLy8gVXBsb2FkIGlmIGl0J3MgbmV3IG9yIHNlcnZlci1zaWRlIGNvcHkgaWYgaXQgd2FzIGFscmVhZHkgdXBsb2FkZWQgcHJldmlvdXNseVxuICAgIGNvbnN0IHByZXZpb3VzID0gdGhpcy5wcmV2aW91c1VwbG9hZHNbaGFzaF07XG4gICAgaWYgKHByZXZpb3VzKSB7XG4gICAgICBkZWJ1ZyhgJHt1cmx9OiBjb3B5aW5nYCk7XG4gICAgICBhd2FpdCBzMy5jb3B5T2JqZWN0KHtcbiAgICAgICAgQnVja2V0OiBidWNrZXQsXG4gICAgICAgIEtleToga2V5LFxuICAgICAgICBDb3B5U291cmNlOiBgJHtidWNrZXR9LyR7cHJldmlvdXMua2V5fWBcbiAgICAgIH0pLnByb21pc2UoKTtcbiAgICAgIGRlYnVnKGAke3VybH06IGNvcHkgY29tcGxldGVgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoYCR7dXJsfTogdXBsb2FkaW5nYCk7XG4gICAgICBhd2FpdCBzMy5wdXRPYmplY3Qoe1xuICAgICAgICBCdWNrZXQ6IGJ1Y2tldCxcbiAgICAgICAgS2V5OiBrZXksXG4gICAgICAgIEJvZHk6IGRhdGEsXG4gICAgICAgIENvbnRlbnRUeXBlOiBwcm9wcy5jb250ZW50VHlwZVxuICAgICAgfSkucHJvbWlzZSgpO1xuICAgICAgZGVidWcoYCR7dXJsfTogdXBsb2FkIGNvbXBsZXRlYCk7XG4gICAgICB0aGlzLnByZXZpb3VzVXBsb2Fkc1toYXNoXSA9IHVwbG9hZGVkO1xuICAgIH1cblxuICAgIHJldHVybiB1cGxvYWRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwYXJlIGFuIEVDUiByZXBvc2l0b3J5IGZvciB1cGxvYWRpbmcgdG8gdXNpbmcgRG9ja2VyXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgcHJlcGFyZUVjclJlcG9zaXRvcnkoaWQ6IHN0cmluZywgaW1hZ2VUYWc6IHN0cmluZyk6IFByb21pc2U8RWNyUmVwb3NpdG9yeUluZm8+IHtcbiAgICBjb25zdCBlY3IgPSBhd2FpdCB0aGlzLnByb3BzLnNkay5lY3IodGhpcy5wcm9wcy5lbnZpcm9ubWVudCwgTW9kZS5Gb3JXcml0aW5nKTtcblxuICAgIC8vIENyZWF0ZSB0aGUgcmVwb3NpdG9yeSBpZiBpdCBkb2Vzbid0IGV4aXN0IHlldFxuICAgIGNvbnN0IHJlcG9zaXRvcnlOYW1lID0gJ2Nkay8nICsgaWQucmVwbGFjZSgvWzovXS9nLCAnLScpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBsZXQgcmVwb3NpdG9yeTtcbiAgICB0cnkge1xuICAgICAgZGVidWcoYCR7cmVwb3NpdG9yeU5hbWV9OiBjaGVja2luZyBmb3IgcmVwb3NpdG9yeS5gKTtcbiAgICAgIGNvbnN0IGRlc2NyaWJlUmVzcG9uc2UgPSBhd2FpdCBlY3IuZGVzY3JpYmVSZXBvc2l0b3JpZXMoeyByZXBvc2l0b3J5TmFtZXM6IFtyZXBvc2l0b3J5TmFtZV0gfSkucHJvbWlzZSgpO1xuICAgICAgcmVwb3NpdG9yeSA9IGRlc2NyaWJlUmVzcG9uc2UucmVwb3NpdG9yaWVzIVswXTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5jb2RlICE9PSAnUmVwb3NpdG9yeU5vdEZvdW5kRXhjZXB0aW9uJykgeyB0aHJvdyBlOyB9XG4gICAgfVxuXG4gICAgaWYgKHJlcG9zaXRvcnkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRlYnVnKGAke3JlcG9zaXRvcnlOYW1lfTogY2hlY2tpbmcgZm9yIGltYWdlICR7aW1hZ2VUYWd9YCk7XG4gICAgICAgIGF3YWl0IGVjci5kZXNjcmliZUltYWdlcyh7IHJlcG9zaXRvcnlOYW1lLCBpbWFnZUlkczogW3sgaW1hZ2VUYWcgfV0gfSkucHJvbWlzZSgpO1xuXG4gICAgICAgIC8vIElmIHdlIGdvdCBoZXJlLCB0aGUgaW1hZ2UgYWxyZWFkeSBleGlzdHMuIE5vdGhpbmcgZWxzZSBuZWVkcyB0byBiZSBkb25lLlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFscmVhZHlFeGlzdHM6IHRydWUsXG4gICAgICAgICAgcmVwb3NpdG9yeVVyaTogcmVwb3NpdG9yeS5yZXBvc2l0b3J5VXJpISxcbiAgICAgICAgICByZXBvc2l0b3J5TmFtZVxuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS5jb2RlICE9PSAnSW1hZ2VOb3RGb3VuZEV4Y2VwdGlvbicpIHsgdGhyb3cgZTsgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZyhgJHtyZXBvc2l0b3J5TmFtZX06IGNyZWF0aW5nYCk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGVjci5jcmVhdGVSZXBvc2l0b3J5KHsgcmVwb3NpdG9yeU5hbWUgfSkucHJvbWlzZSgpO1xuICAgICAgcmVwb3NpdG9yeSA9IHJlc3BvbnNlLnJlcG9zaXRvcnkhO1xuXG4gICAgICAvLyBCZXR0ZXIgcHV0IGEgbGlmZWN5Y2xlIHBvbGljeSBvbiB0aGlzIHNvIGFzIHRvIG5vdCBjb3N0IHRvbyBtdWNoIG1vbmV5XG4gICAgICBhd2FpdCBlY3IucHV0TGlmZWN5Y2xlUG9saWN5KHtcbiAgICAgICAgcmVwb3NpdG9yeU5hbWUsXG4gICAgICAgIGxpZmVjeWNsZVBvbGljeVRleHQ6IEpTT04uc3RyaW5naWZ5KERFRkFVTFRfUkVQT19MSUZFQ1lDTEUpXG4gICAgICB9KS5wcm9taXNlKCk7XG4gICAgfVxuXG4gICAgLy8gVGhlIHJlcG8gZXhpc3RzLCBpbWFnZSBqdXN0IG5lZWRzIHRvIGJlIHVwbG9hZGVkLiBHZXQgYXV0aCB0byBkbyBzby5cbiAgICBkZWJ1ZyhgRmV0Y2hpbmcgRUNSIGF1dGhvcml6YXRpb24gdG9rZW5gKTtcbiAgICBjb25zdCBhdXRoRGF0YSA9ICAoYXdhaXQgZWNyLmdldEF1dGhvcml6YXRpb25Ub2tlbih7IH0pLnByb21pc2UoKSkuYXV0aG9yaXphdGlvbkRhdGEgfHwgW107XG4gICAgaWYgKGF1dGhEYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhdXRob3JpemF0aW9uIGRhdGEgcmVjZWl2ZWQgZnJvbSBFQ1InKTtcbiAgICB9XG4gICAgY29uc3QgdG9rZW4gPSBCdWZmZXIuZnJvbShhdXRoRGF0YVswXS5hdXRob3JpemF0aW9uVG9rZW4hLCAnYmFzZTY0JykudG9TdHJpbmcoJ2FzY2lpJyk7XG4gICAgY29uc3QgW3VzZXJuYW1lLCBwYXNzd29yZF0gPSB0b2tlbi5zcGxpdCgnOicpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFscmVhZHlFeGlzdHM6IGZhbHNlLFxuICAgICAgcmVwb3NpdG9yeVVyaTogcmVwb3NpdG9yeS5yZXBvc2l0b3J5VXJpISxcbiAgICAgIHJlcG9zaXRvcnlOYW1lLFxuICAgICAgdXNlcm5hbWUsXG4gICAgICBwYXNzd29yZCxcbiAgICAgIGVuZHBvaW50OiBhdXRoRGF0YVswXS5wcm94eUVuZHBvaW50ISxcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIEVjclJlcG9zaXRvcnlJbmZvID0gQ29tcGxldGVFY3JSZXBvc2l0b3J5SW5mbyB8IFVwbG9hZGFibGVFY3JSZXBvc2l0b3J5SW5mbztcblxuZXhwb3J0IGludGVyZmFjZSBDb21wbGV0ZUVjclJlcG9zaXRvcnlJbmZvIHtcbiAgcmVwb3NpdG9yeVVyaTogc3RyaW5nO1xuICByZXBvc2l0b3J5TmFtZTogc3RyaW5nO1xuICBhbHJlYWR5RXhpc3RzOiB0cnVlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVwbG9hZGFibGVFY3JSZXBvc2l0b3J5SW5mbyB7XG4gIHJlcG9zaXRvcnlVcmk6IHN0cmluZztcbiAgcmVwb3NpdG9yeU5hbWU6IHN0cmluZztcbiAgYWxyZWFkeUV4aXN0czogZmFsc2U7XG4gIHVzZXJuYW1lOiBzdHJpbmc7XG4gIHBhc3N3b3JkOiBzdHJpbmc7XG4gIGVuZHBvaW50OiBzdHJpbmc7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG9iamVjdEV4aXN0cyhzMzogYXdzLlMzLCBidWNrZXQ6IHN0cmluZywga2V5OiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBzMy5oZWFkT2JqZWN0KHsgQnVja2V0OiBidWNrZXQsIEtleToga2V5IH0pLnByb21pc2UoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlLmNvZGUgPT09ICdOb3RGb3VuZCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aHJvdyBlO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkVG9vbGtpdEluZm8oZW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50LCBzZGs6IFNESywgc3RhY2tOYW1lOiBzdHJpbmcpOiBQcm9taXNlPFRvb2xraXRJbmZvIHzCoHVuZGVmaW5lZD4ge1xuICBjb25zdCBjZm4gPSBhd2FpdCBzZGsuY2xvdWRGb3JtYXRpb24oZW52aXJvbm1lbnQsIE1vZGUuRm9yUmVhZGluZyk7XG4gIGNvbnN0IHN0YWNrID0gYXdhaXQgd2FpdEZvclN0YWNrKGNmbiwgc3RhY2tOYW1lKTtcbiAgaWYgKCFzdGFjaykge1xuICAgIGRlYnVnKCdUaGUgZW52aXJvbm1lbnQgJXMgZG9lc25cXCd0IGhhdmUgdGhlIENESyB0b29sa2l0IHN0YWNrICglcykgaW5zdGFsbGVkLiBVc2UgJXMgdG8gc2V0dXAgeW91ciBlbnZpcm9ubWVudCBmb3IgdXNlIHdpdGggdGhlIHRvb2xraXQuJyxcbiAgICAgICAgZW52aXJvbm1lbnQubmFtZSwgc3RhY2tOYW1lLCBjb2xvcnMuYmx1ZShgY2RrIGJvb3RzdHJhcCBcIiR7ZW52aXJvbm1lbnQubmFtZX1cImApKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBuZXcgVG9vbGtpdEluZm8oe1xuICAgIHNkaywgZW52aXJvbm1lbnQsXG4gICAgYnVja2V0TmFtZTogZ2V0T3V0cHV0VmFsdWUoc3RhY2ssIEJVQ0tFVF9OQU1FX09VVFBVVCksXG4gICAgYnVja2V0RW5kcG9pbnQ6IGdldE91dHB1dFZhbHVlKHN0YWNrLCBCVUNLRVRfRE9NQUlOX05BTUVfT1VUUFVUKVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0T3V0cHV0VmFsdWUoc3RhY2s6IGF3cy5DbG91ZEZvcm1hdGlvbi5TdGFjaywgb3V0cHV0OiBzdHJpbmcpOiBzdHJpbmcge1xuICBsZXQgcmVzdWx0OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIGlmIChzdGFjay5PdXRwdXRzKSB7XG4gICAgY29uc3QgZm91bmQgPSBzdGFjay5PdXRwdXRzLmZpbmQobyA9PiBvLk91dHB1dEtleSA9PT0gb3V0cHV0KTtcbiAgICByZXN1bHQgPSBmb3VuZCAmJiBmb3VuZC5PdXRwdXRWYWx1ZTtcbiAgfVxuICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBDREsgdG9vbGtpdCBzdGFjayAoJHtzdGFjay5TdGFja05hbWV9KSBkb2VzIG5vdCBoYXZlIGFuIG91dHB1dCBuYW1lZCAke291dHB1dH0uIFVzZSAnY2RrIGJvb3RzdHJhcCcgdG8gY29ycmVjdCB0aGlzLmApO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnN0IERFRkFVTFRfUkVQT19MSUZFQ1lDTEUgPSB7XG4gIHJ1bGVzOiBbXG4gICAge1xuICAgICAgcnVsZVByaW9yaXR5OiAxMDAsXG4gICAgICBkZXNjcmlwdGlvbjogJ1JldGFpbiBvbmx5IDUgaW1hZ2VzJyxcbiAgICAgIHNlbGVjdGlvbjoge1xuICAgICAgICB0YWdTdGF0dXM6ICdhbnknLFxuICAgICAgICBjb3VudFR5cGU6ICdpbWFnZUNvdW50TW9yZVRoYW4nLFxuICAgICAgICBjb3VudE51bWJlcjogNSxcbiAgICAgIH0sXG4gICAgICBhY3Rpb246IHsgdHlwZTogJ2V4cGlyZScgfVxuICAgIH1cbiAgXVxufTtcbiJdfQ==
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cxapi = require("@aws-cdk/cx-api");
const Table = require("cli-table");
const colors = require("colors/safe");
const util_1 = require("util");
const diff_template_1 = require("./diff-template");
const util_2 = require("./diff/util");
/**
 * Renders template differences to the process' console.
 *
 * @param templateDiff TemplateDiff to be rendered to the console.
 * @param logicalToPathMap A map from logical ID to construct path. Useful in
 *                         case there is no aws:cdk:path metadata in the template.
 */
function formatDifferences(stream, templateDiff, logicalToPathMap = {}) {
    const formatter = new Formatter(stream, logicalToPathMap, templateDiff);
    if (templateDiff.awsTemplateFormatVersion || templateDiff.transform || templateDiff.description) {
        formatter.printSectionHeader('Template');
        formatter.formatDifference('AWSTemplateFormatVersion', 'AWSTemplateFormatVersion', templateDiff.awsTemplateFormatVersion);
        formatter.formatDifference('Transform', 'Transform', templateDiff.transform);
        formatter.formatDifference('Description', 'Description', templateDiff.description);
        formatter.printSectionFooter();
    }
    formatSecurityChangesWithBanner(formatter, templateDiff);
    formatter.formatSection('Parameters', 'Parameter', templateDiff.parameters);
    formatter.formatSection('Metadata', 'Metadata', templateDiff.metadata);
    formatter.formatSection('Mappings', 'Mapping', templateDiff.mappings);
    formatter.formatSection('Conditions', 'Condition', templateDiff.conditions);
    formatter.formatSection('Resources', 'Resource', templateDiff.resources, formatter.formatResourceDifference.bind(formatter));
    formatter.formatSection('Outputs', 'Output', templateDiff.outputs);
    formatter.formatSection('Other Changes', 'Unknown', templateDiff.unknown);
}
exports.formatDifferences = formatDifferences;
/**
 * Renders a diff of security changes to the given stream
 */
function formatSecurityChanges(stream, templateDiff, logicalToPathMap = {}) {
    const formatter = new Formatter(stream, logicalToPathMap, templateDiff);
    formatSecurityChangesWithBanner(formatter, templateDiff);
}
exports.formatSecurityChanges = formatSecurityChanges;
function formatSecurityChangesWithBanner(formatter, templateDiff) {
    if (!templateDiff.iamChanges.hasChanges && !templateDiff.securityGroupChanges.hasChanges) {
        return;
    }
    formatter.formatIamChanges(templateDiff.iamChanges);
    formatter.formatSecurityGroupChanges(templateDiff.securityGroupChanges);
    formatter.warning(`(NOTE: There may be security-related changes not in this list. See http://bit.ly/cdk-2EhF7Np)`);
    formatter.printSectionFooter();
}
const ADDITION = colors.green('[+]');
const UPDATE = colors.yellow('[~]');
const REMOVAL = colors.red('[-]');
class Formatter {
    constructor(stream, logicalToPathMap, diff) {
        this.stream = stream;
        this.logicalToPathMap = logicalToPathMap;
        // Read additional construct paths from the diff if it is supplied
        if (diff) {
            this.readConstructPathsFrom(diff);
        }
    }
    print(fmt, ...args) {
        this.stream.write(colors.white(util_1.format(fmt, ...args)) + '\n');
    }
    warning(fmt, ...args) {
        this.stream.write(colors.yellow(util_1.format(fmt, ...args)) + '\n');
    }
    formatSection(title, entryType, collection, formatter = this.formatDifference.bind(this)) {
        if (collection.count === 0) {
            return;
        }
        this.printSectionHeader(title);
        collection.forEach((id, diff) => formatter(entryType, id, diff));
        this.printSectionFooter();
    }
    printSectionHeader(title) {
        this.print(colors.underline(colors.bold(title)));
    }
    printSectionFooter() {
        this.print('');
    }
    /**
     * Print a simple difference for a given named entity.
     *
     * @param logicalId the name of the entity that is different.
     * @param diff the difference to be rendered.
     */
    formatDifference(type, logicalId, diff) {
        if (!diff) {
            return;
        }
        let value;
        const oldValue = this.formatValue(diff.oldValue, colors.red);
        const newValue = this.formatValue(diff.newValue, colors.green);
        if (diff.isAddition) {
            value = newValue;
        }
        else if (diff.isUpdate) {
            value = `${oldValue} to ${newValue}`;
        }
        else if (diff.isRemoval) {
            value = oldValue;
        }
        this.print(`${this.formatPrefix(diff)} ${colors.cyan(type)} ${this.formatLogicalId(logicalId)}: ${value}`);
    }
    /**
     * Print a resource difference for a given logical ID.
     *
     * @param logicalId the logical ID of the resource that changed.
     * @param diff    the change to be rendered.
     */
    formatResourceDifference(_type, logicalId, diff) {
        const resourceType = diff.isRemoval ? diff.oldResourceType : diff.newResourceType;
        // tslint:disable-next-line:max-line-length
        this.print(`${this.formatPrefix(diff)} ${this.formatValue(resourceType, colors.cyan)} ${this.formatLogicalId(logicalId)} ${this.formatImpact(diff.changeImpact)}`);
        if (diff.isUpdate) {
            let processedCount = 0;
            diff.forEach((_, name, values) => {
                processedCount += 1;
                this.formatTreeDiff(name, values, processedCount === diff.count);
            });
        }
    }
    formatPrefix(diff) {
        if (diff.isAddition) {
            return ADDITION;
        }
        if (diff.isUpdate) {
            return UPDATE;
        }
        if (diff.isRemoval) {
            return REMOVAL;
        }
        return colors.white('[?]');
    }
    /**
     * @param value the value to be formatted.
     * @param color the color to be used.
     *
     * @returns the formatted string, with color applied.
     */
    formatValue(value, color) {
        if (value == null) {
            return undefined;
        }
        if (typeof value === 'string') {
            return color(value);
        }
        return color(JSON.stringify(value));
    }
    /**
     * @param impact the impact to be formatted
     * @returns a user-friendly, colored string representing the impact.
     */
    formatImpact(impact) {
        switch (impact) {
            case diff_template_1.ResourceImpact.MAY_REPLACE:
                return colors.italic(colors.yellow('may be replaced'));
            case diff_template_1.ResourceImpact.WILL_REPLACE:
                return colors.italic(colors.bold(colors.yellow('replace')));
            case diff_template_1.ResourceImpact.WILL_DESTROY:
                return colors.italic(colors.bold(colors.red('destroy')));
            case diff_template_1.ResourceImpact.WILL_ORPHAN:
                return colors.italic(colors.yellow('orphan'));
            case diff_template_1.ResourceImpact.WILL_UPDATE:
            case diff_template_1.ResourceImpact.WILL_CREATE:
                return ''; // no extra info is gained here
        }
    }
    /**
     * Renders a tree of differences under a particular name.
     * @param name the name of the root of the tree.
     * @param diff the difference on the tree.
     * @param last whether this is the last node of a parent tree.
     */
    formatTreeDiff(name, diff, last) {
        let additionalInfo = '';
        if (diff_template_1.isPropertyDifference(diff)) {
            if (diff.changeImpact === diff_template_1.ResourceImpact.MAY_REPLACE) {
                additionalInfo = ' (may cause replacement)';
            }
            else if (diff.changeImpact === diff_template_1.ResourceImpact.WILL_REPLACE) {
                additionalInfo = ' (requires replacement)';
            }
        }
        this.print(' %s─ %s %s%s', last ? '└' : '├', this.changeTag(diff.oldValue, diff.newValue), name, additionalInfo);
        return this.formatObjectDiff(diff.oldValue, diff.newValue, ` ${last ? ' ' : '│'}`);
    }
    /**
     * Renders the difference between two objects, looking for the differences as deep as possible,
     * and rendering a tree graph of the path until the difference is found.
     *
     * @param oldObject  the old object.
     * @param newObject  the new object.
     * @param linePrefix a prefix (indent-like) to be used on every line.
     */
    formatObjectDiff(oldObject, newObject, linePrefix) {
        if ((typeof oldObject !== typeof newObject) || Array.isArray(oldObject) || typeof oldObject === 'string' || typeof oldObject === 'number') {
            if (oldObject !== undefined && newObject !== undefined) {
                this.print('%s   ├─ %s %s', linePrefix, REMOVAL, this.formatValue(oldObject, colors.red));
                this.print('%s   └─ %s %s', linePrefix, ADDITION, this.formatValue(newObject, colors.green));
            }
            else if (oldObject !== undefined /* && newObject === undefined */) {
                this.print('%s   └─ %s', linePrefix, this.formatValue(oldObject, colors.red));
            }
            else /* if (oldObject === undefined && newObject !== undefined) */ {
                this.print('%s   └─ %s', linePrefix, this.formatValue(newObject, colors.green));
            }
            return;
        }
        const keySet = new Set(Object.keys(oldObject));
        Object.keys(newObject).forEach(k => keySet.add(k));
        const keys = new Array(...keySet).filter(k => !util_2.deepEqual(oldObject[k], newObject[k])).sort();
        const lastKey = keys[keys.length - 1];
        for (const key of keys) {
            const oldValue = oldObject[key];
            const newValue = newObject[key];
            const treePrefix = key === lastKey ? '└' : '├';
            if (oldValue !== undefined && newValue !== undefined) {
                this.print('%s   %s─ %s %s:', linePrefix, treePrefix, this.changeTag(oldValue, newValue), colors.blue(`.${key}`));
                this.formatObjectDiff(oldValue, newValue, `${linePrefix}   ${key === lastKey ? ' ' : '│'}`);
            }
            else if (oldValue !== undefined /* && newValue === undefined */) {
                this.print('%s   %s─ %s Removed: %s', linePrefix, treePrefix, REMOVAL, colors.blue(`.${key}`));
            }
            else /* if (oldValue === undefined && newValue !== undefined */ {
                this.print('%s   %s─ %s Added: %s', linePrefix, treePrefix, ADDITION, colors.blue(`.${key}`));
            }
        }
    }
    /**
     * @param oldValue the old value of a difference.
     * @param newValue the new value of a difference.
     *
     * @returns a tag to be rendered in the diff, reflecting whether the difference
     *      was an ADDITION, UPDATE or REMOVAL.
     */
    changeTag(oldValue, newValue) {
        if (oldValue !== undefined && newValue !== undefined) {
            return UPDATE;
        }
        else if (oldValue !== undefined /* && newValue === undefined*/) {
            return REMOVAL;
        }
        else /* if (oldValue === undefined && newValue !== undefined) */ {
            return ADDITION;
        }
    }
    /**
     * Find 'aws:cdk:path' metadata in the diff and add it to the logicalToPathMap
     *
     * There are multiple sources of logicalID -> path mappings: synth metadata
     * and resource metadata, and we combine all sources into a single map.
     */
    readConstructPathsFrom(templateDiff) {
        for (const [logicalId, resourceDiff] of Object.entries(templateDiff.resources)) {
            if (!resourceDiff) {
                continue;
            }
            const oldPathMetadata = resourceDiff.oldValue && resourceDiff.oldValue.Metadata && resourceDiff.oldValue.Metadata[cxapi.PATH_METADATA_KEY];
            if (oldPathMetadata && !(logicalId in this.logicalToPathMap)) {
                this.logicalToPathMap[logicalId] = oldPathMetadata;
            }
            const newPathMetadata = resourceDiff.newValue && resourceDiff.newValue.Metadata && resourceDiff.newValue.Metadata[cxapi.PATH_METADATA_KEY];
            if (newPathMetadata && !(logicalId in this.logicalToPathMap)) {
                this.logicalToPathMap[logicalId] = newPathMetadata;
            }
        }
    }
    formatLogicalId(logicalId) {
        // if we have a path in the map, return it
        const normalized = this.normalizedLogicalIdPath(logicalId);
        if (normalized) {
            return `${normalized} ${colors.gray(logicalId)}`;
        }
        return logicalId;
    }
    normalizedLogicalIdPath(logicalId) {
        // if we have a path in the map, return it
        const path = this.logicalToPathMap[logicalId];
        return path ? normalizePath(path) : undefined;
        /**
         * Path is supposed to start with "/stack-name". If this is the case (i.e. path has more than
         * two components, we remove the first part. Otherwise, we just use the full path.
         * @param p
         */
        function normalizePath(p) {
            if (p.startsWith('/')) {
                p = p.substr(1);
            }
            let parts = p.split('/');
            if (parts.length > 1) {
                parts = parts.slice(1);
                // remove the last component if it's "Resource" or "Default" (if we have more than a single component)
                if (parts.length > 1) {
                    const last = parts[parts.length - 1];
                    if (last === 'Resource' || last === 'Default') {
                        parts = parts.slice(0, parts.length - 1);
                    }
                }
                p = parts.join('/');
            }
            return p;
        }
    }
    formatIamChanges(changes) {
        if (!changes.hasChanges) {
            return;
        }
        if (changes.statements.hasChanges) {
            this.printSectionHeader('IAM Statement Changes');
            this.print(renderTable(this.deepSubstituteBracedLogicalIds(changes.summarizeStatements())));
        }
        if (changes.managedPolicies.hasChanges) {
            this.printSectionHeader('IAM Policy Changes');
            this.print(renderTable(this.deepSubstituteBracedLogicalIds(changes.summarizeManagedPolicies())));
        }
    }
    formatSecurityGroupChanges(changes) {
        if (!changes.hasChanges) {
            return;
        }
        this.printSectionHeader('Security Group Changes');
        this.print(renderTable(this.deepSubstituteBracedLogicalIds(changes.summarize())));
    }
    deepSubstituteBracedLogicalIds(rows) {
        return rows.map(row => row.map(this.substituteBracedLogicalIds.bind(this)));
    }
    /**
     * Substitute all strings like ${LogId.xxx} with the path instead of the logical ID
     */
    substituteBracedLogicalIds(source) {
        return source.replace(/\$\{([^.}]+)(.[^}]+)?\}/ig, (_match, logId, suffix) => {
            return '${' + (this.normalizedLogicalIdPath(logId) || logId) + (suffix || '') + '}';
        });
    }
}
/**
 * Render a two-dimensional array to a visually attractive table
 *
 * First row is considered the table header.
 */
function renderTable(cells) {
    const head = cells.splice(0, 1)[0];
    const table = new Table({ head, style: { head: [] } });
    table.push(...cells);
    return stripHorizontalLines(table.toString()).trimRight();
}
/**
 * Strip horizontal lines in the table rendering if the second-column values are the same
 *
 * We couldn't find a table library that BOTH does newlines-in-cells correctly AND
 * has an option to enable/disable separator lines on a per-row basis. So we're
 * going to do some character post-processing on the table instead.
 */
function stripHorizontalLines(tableRendering) {
    const lines = tableRendering.split('\n');
    let i = 3;
    while (i < lines.length - 3) {
        if (secondColumnValue(lines[i]) === secondColumnValue(lines[i + 2])) {
            lines.splice(i + 1, 1);
            i += 1;
        }
        else {
            i += 2;
        }
    }
    return lines.join('\n');
    function secondColumnValue(line) {
        const cols = colors.stripColors(line).split('│').filter(x => x !== '');
        return cols[1];
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9ybWF0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZm9ybWF0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEseUNBQTBDO0FBQzFDLG1DQUFvQztBQUNwQyxzQ0FBdUM7QUFDdkMsK0JBQThCO0FBQzlCLG1EQUF1RztBQUV2RyxzQ0FBd0M7QUFJeEM7Ozs7OztHQU1HO0FBQ0gsU0FBZ0IsaUJBQWlCLENBQUMsTUFBMEIsRUFBRSxZQUEwQixFQUFFLG1CQUFvRCxFQUFHO0lBQy9JLE1BQU0sU0FBUyxHQUFHLElBQUksU0FBUyxDQUFDLE1BQU0sRUFBRSxnQkFBZ0IsRUFBRSxZQUFZLENBQUMsQ0FBQztJQUV4RSxJQUFJLFlBQVksQ0FBQyx3QkFBd0IsSUFBSSxZQUFZLENBQUMsU0FBUyxJQUFJLFlBQVksQ0FBQyxXQUFXLEVBQUU7UUFDL0YsU0FBUyxDQUFDLGtCQUFrQixDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ3pDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQywwQkFBMEIsRUFBRSwwQkFBMEIsRUFBRSxZQUFZLENBQUMsd0JBQXdCLENBQUMsQ0FBQztRQUMxSCxTQUFTLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxFQUFFLFdBQVcsRUFBRSxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDN0UsU0FBUyxDQUFDLGdCQUFnQixDQUFDLGFBQWEsRUFBRSxhQUFhLEVBQUUsWUFBWSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ25GLFNBQVMsQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO0tBQ2hDO0lBRUQsK0JBQStCLENBQUMsU0FBUyxFQUFFLFlBQVksQ0FBQyxDQUFDO0lBRXpELFNBQVMsQ0FBQyxhQUFhLENBQUMsWUFBWSxFQUFFLFdBQVcsRUFBRSxZQUFZLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDNUUsU0FBUyxDQUFDLGFBQWEsQ0FBQyxVQUFVLEVBQUUsVUFBVSxFQUFFLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN2RSxTQUFTLENBQUMs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Ozs7Ozs7R0FNRztBQUNILFNBQVMsb0JBQW9CLENBQUMsY0FBc0I7SUFDbEQsTUFBTSxLQUFLLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUV6QyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDVixPQUFPLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtRQUMzQixJQUFJLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRTtZQUNuRSxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDdkIsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNSO2FBQU07WUFDTCxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ1I7S0FDRjtJQUVELE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUV4QixTQUFTLGlCQUFpQixDQUFDLElBQVk7UUFDckMsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO1FBQ3ZFLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2pCLENBQUM7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGN4YXBpID0gcmVxdWlyZSgnQGF3cy1jZGsvY3gtYXBpJyk7XG5pbXBvcnQgVGFibGUgPSByZXF1aXJlKCdjbGktdGFibGUnKTtcbmltcG9ydCBjb2xvcnMgPSByZXF1aXJlKCdjb2xvcnMvc2FmZScpO1xuaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAndXRpbCc7XG5pbXBvcnQgeyBEaWZmZXJlbmNlLCBpc1Byb3BlcnR5RGlmZmVyZW5jZSwgUmVzb3VyY2VEaWZmZXJlbmNlLCBSZXNvdXJjZUltcGFjdCB9IGZyb20gJy4vZGlmZi10ZW1wbGF0ZSc7XG5pbXBvcnQgeyBEaWZmZXJlbmNlQ29sbGVjdGlvbiwgVGVtcGxhdGVEaWZmIH0gZnJvbSAnLi9kaWZmL3R5cGVzJztcbmltcG9ydCB7IGRlZXBFcXVhbCB9IGZyb20gJy4vZGlmZi91dGlsJztcbmltcG9ydCB7IElhbUNoYW5nZXMgfSBmcm9tICcuL2lhbS9pYW0tY2hhbmdlcyc7XG5pbXBvcnQgeyBTZWN1cml0eUdyb3VwQ2hhbmdlcyB9IGZyb20gJy4vbmV0d29yay9zZWN1cml0eS1ncm91cC1jaGFuZ2VzJztcblxuLyoqXG4gKiBSZW5kZXJzIHRlbXBsYXRlIGRpZmZlcmVuY2VzIHRvIHRoZSBwcm9jZXNzJyBjb25zb2xlLlxuICpcbiAqIEBwYXJhbSB0ZW1wbGF0ZURpZmYgVGVtcGxhdGVEaWZmIHRvIGJlIHJlbmRlcmVkIHRvIHRoZSBjb25zb2xlLlxuICogQHBhcmFtIGxvZ2ljYWxUb1BhdGhNYXAgQSBtYXAgZnJvbSBsb2dpY2FsIElEIHRvIGNvbnN0cnVjdCBwYXRoLiBVc2VmdWwgaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhlcmUgaXMgbm8gYXdzOmNkazpwYXRoIG1ldGFkYXRhIGluIHRoZSB0ZW1wbGF0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdERpZmZlcmVuY2VzKHN0cmVhbTogTm9kZUpTLldyaXRlU3RyZWFtLCB0ZW1wbGF0ZURpZmY6IFRlbXBsYXRlRGlmZiwgbG9naWNhbFRvUGF0aE1hcDogeyBbbG9naWNhbElkOiBzdHJpbmddOiBzdHJpbmcgfSA9IHsgfSkge1xuICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgRm9ybWF0dGVyKHN0cmVhbSwgbG9naWNhbFRvUGF0aE1hcCwgdGVtcGxhdGVEaWZmKTtcblxuICBpZiAodGVtcGxhdGVEaWZmLmF3c1RlbXBsYXRlRm9ybWF0VmVyc2lvbiB8fCB0ZW1wbGF0ZURpZmYudHJhbnNmb3JtIHx8IHRlbXBsYXRlRGlmZi5kZXNjcmlwdGlvbikge1xuICAgIGZvcm1hdHRlci5wcmludFNlY3Rpb25IZWFkZXIoJ1RlbXBsYXRlJyk7XG4gICAgZm9ybWF0dGVyLmZvcm1hdERpZmZlcmVuY2UoJ0FXU1RlbXBsYXRlRm9ybWF0VmVyc2lvbicsICdBV1NUZW1wbGF0ZUZvcm1hdFZlcnNpb24nLCB0ZW1wbGF0ZURpZmYuYXdzVGVtcGxhdGVGb3JtYXRWZXJzaW9uKTtcbiAgICBmb3JtYXR0ZXIuZm9ybWF0RGlmZmVyZW5jZSgnVHJhbnNmb3JtJywgJ1RyYW5zZm9ybScsIHRlbXBsYXRlRGlmZi50cmFuc2Zvcm0pO1xuICAgIGZvcm1hdHRlci5mb3JtYXREaWZmZXJlbmNlKCdEZXNjcmlwdGlvbicsICdEZXNjcmlwdGlvbicsIHRlbXBsYXRlRGlmZi5kZXNjcmlwdGlvbik7XG4gICAgZm9ybWF0dGVyLnByaW50U2VjdGlvbkZvb3RlcigpO1xuICB9XG5cbiAgZm9ybWF0U2VjdXJpdHlDaGFuZ2VzV2l0aEJhbm5lcihmb3JtYXR0ZXIsIHRlbXBsYXRlRGlmZik7XG5cbiAgZm9ybWF0dGVyLmZvcm1hdFNlY3Rpb24oJ1BhcmFtZXRlcnMnLCAnUGFyYW1ldGVyJywgdGVtcGxhdGVEaWZmLnBhcmFtZXRlcnMpO1xuICBmb3JtYXR0ZXIuZm9ybWF0U2VjdGlvbignTWV0YWRhdGEnLCAnTWV0YWRhdGEnLCB0ZW1wbGF0ZURpZmYubWV0YWRhdGEpO1xuICBmb3JtYXR0ZXIuZm9ybWF0U2VjdGlvbignTWFwcGluZ3MnLCAnTWFwcGluZycsIHRlbXBsYXRlRGlmZi5tYXBwaW5ncyk7XG4gIGZvcm1hdHRlci5mb3JtYXRTZWN0aW9uKCdDb25kaXRpb25zJywgJ0NvbmRpdGlvbicsIHRlbXBsYXRlRGlmZi5jb25kaXRpb25zKTtcbiAgZm9ybWF0dGVyLmZvcm1hdFNlY3Rpb24oJ1Jlc291cmNlcycsICdSZXNvdXJjZScsIHRlbXBsYXRlRGlmZi5yZXNvdXJjZXMsIGZvcm1hdHRlci5mb3JtYXRSZXNvdXJjZURpZmZlcmVuY2UuYmluZChmb3JtYXR0ZXIpKTtcbiAgZm9ybWF0dGVyLmZvcm1hdFNlY3Rpb24oJ091dHB1dHMnLCAnT3V0cHV0JywgdGVtcGxhdGVEaWZmLm91dHB1dHMpO1xuICBmb3JtYXR0ZXIuZm9ybWF0U2VjdGlvbignT3RoZXIgQ2hhbmdlcycsICdVbmtub3duJywgdGVtcGxhdGVEaWZmLnVua25vd24pO1xufVxuXG4vKipcbiAqIFJlbmRlcnMgYSBkaWZmIG9mIHNlY3VyaXR5IGNoYW5nZXMgdG8gdGhlIGdpdmVuIHN0cmVhbVxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0U2VjdXJpdHlDaGFuZ2VzKHN0cmVhbTogTm9kZUpTLldyaXRlU3RyZWFtLCB0ZW1wbGF0ZURpZmY6IFRlbXBsYXRlRGlmZiwgbG9naWNhbFRvUGF0aE1hcDoge1tsb2dpY2FsSWQ6IHN0cmluZ106IHN0cmluZ30gPSB7fSkge1xuICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgRm9ybWF0dGVyKHN0cmVhbSwgbG9naWNhbFRvUGF0aE1hcCwgdGVtcGxhdGVEaWZmKTtcblxuICBmb3JtYXRTZWN1cml0eUNoYW5nZXNXaXRoQmFubmVyKGZvcm1hdHRlciwgdGVtcGxhdGVEaWZmKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0U2VjdXJpdHlDaGFuZ2VzV2l0aEJhbm5lcihmb3JtYXR0ZXI6IEZvcm1hdHRlciwgdGVtcGxhdGVEaWZmOiBUZW1wbGF0ZURpZmYpIHtcbiAgaWYgKCF0ZW1wbGF0ZURpZmYuaWFtQ2hhbmdlcy5oYXNDaGFuZ2VzICYmICF0ZW1wbGF0ZURpZmYuc2VjdXJpdHlHcm91cENoYW5nZXMuaGFzQ2hhbmdlcykgeyByZXR1cm47IH1cbiAgZm9ybWF0dGVyLmZvcm1hdElhbUNoYW5nZXModGVtcGxhdGVEaWZmLmlhbUNoYW5nZXMpO1xuICBmb3JtYXR0ZXIuZm9ybWF0U2VjdXJpdHlHcm91cENoYW5nZXModGVtcGxhdGVEaWZmLnNlY3VyaXR5R3JvdXBDaGFuZ2VzKTtcblxuICBmb3JtYXR0ZXIud2FybmluZyhgKE5PVEU6IFRoZXJlIG1heSBiZSBzZWN1cml0eS1yZWxhdGVkIGNoYW5nZXMgbm90IGluIHRoaXMgbGlzdC4gU2VlIGh0dHA6Ly9iaXQubHkvY2RrLTJFaEY3TnApYCk7XG4gIGZvcm1hdHRlci5wcmludFNlY3Rpb25Gb290ZXIoKTtcbn1cblxuY29uc3QgQURESVRJT04gPSBjb2xvcnMuZ3JlZW4oJ1srXScpO1xuY29uc3QgVVBEQVRFICAgPSBjb2xvcnMueWVsbG93KCdbfl0nKTtcbmNvbnN0IFJFTU9WQUwgID0gY29sb3JzLnJlZCgnWy1dJyk7XG5cbmNsYXNzIEZvcm1hdHRlciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgc3RyZWFtOiBOb2RlSlMuV3JpdGVTdHJlYW0sIHByaXZhdGUgcmVhZG9ubHkgbG9naWNhbFRvUGF0aE1hcDogeyBbbG9naWNhbElkOiBzdHJpbmddOiBzdHJpbmcgfSwgZGlmZj86IFRlbXBsYXRlRGlmZikge1xuICAgIC8vIFJlYWQgYWRkaXRpb25hbCBjb25zdHJ1Y3QgcGF0aHMgZnJvbSB0aGUgZGlmZiBpZiBpdCBpcyBzdXBwbGllZFxuICAgIGlmIChkaWZmKSB7XG4gICAgICB0aGlzLnJlYWRDb25zdHJ1Y3RQYXRoc0Zyb20oZGlmZik7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHByaW50KGZtdDogc3RyaW5nLCAuLi5hcmdzOiBhbnlbXSkge1xuICAgIHRoaXMuc3RyZWFtLndyaXRlKGNvbG9ycy53aGl0ZShmb3JtYXQoZm10LCAuLi5hcmdzKSkgKyAnXFxuJyk7XG4gIH1cblxuICBwdWJsaWMgd2FybmluZyhmbXQ6IHN0cmluZywgLi4uYXJnczogYW55W10pIHtcbiAgICB0aGlzLnN0cmVhbS53cml0ZShjb2xvcnMueWVsbG93KGZvcm1hdChmbXQsIC4uLmFyZ3MpKSArICdcXG4nKTtcbiAgfVxuXG4gIHB1YmxpYyBmb3JtYXRTZWN0aW9uPFYsIFQgZXh0ZW5kcyBEaWZmZXJlbmNlPFY+PihcbiAgICAgIHRpdGxlOiBzdHJpbmcsXG4gICAgICBlbnRyeVR5cGU6IHN0cmluZyxcbiAgICAgIGNvbGxlY3Rpb246IERpZmZlcmVuY2VDb2xsZWN0aW9uPFYsIFQ+LFxuICAgICAgZm9ybWF0dGVyOiAodHlwZTogc3RyaW5nLCBpZDogc3RyaW5nLCBkaWZmOiBUKSA9PiB2b2lkID0gdGhpcy5mb3JtYXREaWZmZXJlbmNlLmJpbmQodGhpcykpIHtcblxuICAgIGlmIChjb2xsZWN0aW9uLmNvdW50ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wcmludFNlY3Rpb25IZWFkZXIodGl0bGUpO1xuICAgIGNvbGxlY3Rpb24uZm9yRWFjaCgoaWQsIGRpZmYpID0+IGZvcm1hdHRlcihlbnRyeVR5cGUsIGlkLCBkaWZmKSk7XG4gICAgdGhpcy5wcmludFNlY3Rpb25Gb290ZXIoKTtcbiAgfVxuXG4gIHB1YmxpYyBwcmludFNlY3Rpb25IZWFkZXIodGl0bGU6IHN0cmluZykge1xuICAgIHRoaXMucHJpbnQoY29sb3JzLnVuZGVybGluZShjb2xvcnMuYm9sZCh0aXRsZSkpKTtcbiAgfVxuXG4gIHB1YmxpYyBwcmludFNlY3Rpb25Gb290ZXIoKSB7XG4gICAgdGhpcy5wcmludCgnJyk7XG4gIH1cblxuICAvKipcbiAgICogUHJpbnQgYSBzaW1wbGUgZGlmZmVyZW5jZSBmb3IgYSBnaXZlbiBuYW1lZCBlbnRpdHkuXG4gICAqXG4gICAqIEBwYXJhbSBsb2dpY2FsSWQgdGhlIG5hbWUgb2YgdGhlIGVudGl0eSB0aGF0IGlzIGRpZmZlcmVudC5cbiAgICogQHBhcmFtIGRpZmYgdGhlIGRpZmZlcmVuY2UgdG8gYmUgcmVuZGVyZWQuXG4gICAqL1xuICBwdWJsaWMgZm9ybWF0RGlmZmVyZW5jZSh0eXBlOiBzdHJpbmcsIGxvZ2ljYWxJZDogc3RyaW5nLCBkaWZmOiBEaWZmZXJlbmNlPGFueT4gfCB1bmRlZmluZWQpIHtcbiAgICBpZiAoIWRpZmYpIHsgcmV0dXJuOyB9XG5cbiAgICBsZXQgdmFsdWU7XG5cbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuZm9ybWF0VmFsdWUoZGlmZi5vbGRWYWx1ZSwgY29sb3JzLnJlZCk7XG4gICAgY29uc3QgbmV3VmFsdWUgPSB0aGlzLmZvcm1hdFZhbHVlKGRpZmYubmV3VmFsdWUsIGNvbG9ycy5ncmVlbik7XG4gICAgaWYgKGRpZmYuaXNBZGRpdGlvbikge1xuICAgICAgdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9IGVsc2UgaWYgKGRpZmYuaXNVcGRhdGUpIHtcbiAgICAgIHZhbHVlID0gYCR7b2xkVmFsdWV9IHRvICR7bmV3VmFsdWV9YDtcbiAgICB9IGVsc2UgaWYgKGRpZmYuaXNSZW1vdmFsKSB7XG4gICAgICB2YWx1ZSA9IG9sZFZhbHVlO1xuICAgIH1cblxuICAgIHRoaXMucHJpbnQoYCR7dGhpcy5mb3JtYXRQcmVmaXgoZGlmZil9ICR7Y29sb3JzLmN5YW4odHlwZSl9ICR7dGhpcy5mb3JtYXRMb2dpY2FsSWQobG9naWNhbElkKX06ICR7dmFsdWV9YCk7XG4gIH1cblxuICAvKipcbiAgICogUHJpbnQgYSByZXNvdXJjZSBkaWZmZXJlbmNlIGZvciBhIGdpdmVuIGxvZ2ljYWwgSUQuXG4gICAqXG4gICAqIEBwYXJhbSBsb2dpY2FsSWQgdGhlIGxvZ2ljYWwgSUQgb2YgdGhlIHJlc291cmNlIHRoYXQgY2hhbmdlZC5cbiAgICogQHBhcmFtIGRpZmYgICAgdGhlIGNoYW5nZSB0byBiZSByZW5kZXJlZC5cbiAgICovXG4gIHB1YmxpYyBmb3JtYXRSZXNvdXJjZURpZmZlcmVuY2UoX3R5cGU6IHN0cmluZywgbG9naWNhbElkOiBzdHJpbmcsIGRpZmY6IFJlc291cmNlRGlmZmVyZW5jZSkge1xuICAgIGNvbnN0IHJlc291cmNlVHlwZSA9IGRpZmYuaXNSZW1vdmFsID8gZGlmZi5vbGRSZXNvdXJjZVR5cGUgOiBkaWZmLm5ld1Jlc291cmNlVHlwZTtcblxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbiAgICB0aGlzLnByaW50KGAke3RoaXMuZm9ybWF0UHJlZml4KGRpZmYpfSAke3RoaXMuZm9ybWF0VmFsdWUocmVzb3VyY2VUeXBlLCBjb2xvcnMuY3lhbil9ICR7dGhpcy5mb3JtYXRMb2dpY2FsSWQobG9naWNhbElkKX0gJHt0aGlzLmZvcm1hdEltcGFjdChkaWZmLmNoYW5nZUltcGFjdCl9YCk7XG5cbiAgICBpZiAoZGlmZi5pc1VwZGF0ZSkge1xuICAgICAgbGV0IHByb2Nlc3NlZENvdW50ID0gMDtcbiAgICAgIGRpZmYuZm9yRWFjaCgoXywgbmFtZSwgdmFsdWVzKSA9PiB7XG4gICAgICAgIHByb2Nlc3NlZENvdW50ICs9IDE7XG4gICAgICAgIHRoaXMuZm9ybWF0VHJlZURpZmYobmFtZSwgdmFsdWVzLCBwcm9jZXNzZWRDb3VudCA9PT0gZGlmZi5jb3VudCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZm9ybWF0UHJlZml4PFQ+KGRpZmY6IERpZmZlcmVuY2U8VD4pIHtcbiAgICBpZiAoZGlmZi5pc0FkZGl0aW9uKSB7IHJldHVybiBBRERJVElPTjsgfVxuICAgIGlmIChkaWZmLmlzVXBkYXRlKSB7IHJldHVybiBVUERBVEU7IH1cbiAgICBpZiAoZGlmZi5pc1JlbW92YWwpIHsgcmV0dXJuIFJFTU9WQUw7IH1cbiAgICByZXR1cm4gY29sb3JzLndoaXRlKCdbP10nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIGJlIGZvcm1hdHRlZC5cbiAgICogQHBhcmFtIGNvbG9yIHRoZSBjb2xvciB0byBiZSB1c2VkLlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgZm9ybWF0dGVkIHN0cmluZywgd2l0aCBjb2xvciBhcHBsaWVkLlxuICAgKi9cbiAgcHVibGljIGZvcm1hdFZhbHVlKHZhbHVlOiBhbnksIGNvbG9yOiAoc3RyOiBzdHJpbmcpID0+IHN0cmluZykge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgeyByZXR1cm4gY29sb3IodmFsdWUpOyB9XG4gICAgcmV0dXJuIGNvbG9yKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIGltcGFjdCB0aGUgaW1wYWN0IHRvIGJlIGZvcm1hdHRlZFxuICAgKiBAcmV0dXJucyBhIHVzZXItZnJpZW5kbHksIGNvbG9yZWQgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgaW1wYWN0LlxuICAgKi9cbiAgcHVibGljIGZvcm1hdEltcGFjdChpbXBhY3Q6IFJlc291cmNlSW1wYWN0KSB7XG4gICAgc3dpdGNoIChpbXBhY3QpIHtcbiAgICBjYXNlIFJlc291cmNlSW1wYWN0Lk1BWV9SRVBMQUNFOlxuICAgICAgcmV0dXJuIGNvbG9ycy5pdGFsaWMoY29sb3JzLnllbGxvdygnbWF5IGJlIHJlcGxhY2VkJykpO1xuICAgIGNhc2UgUmVzb3VyY2VJbXBhY3QuV0lMTF9SRVBMQUNFOlxuICAgICAgcmV0dXJuIGNvbG9ycy5pdGFsaWMoY29sb3JzLmJvbGQoY29sb3JzLnllbGxvdygncmVwbGFjZScpKSk7XG4gICAgY2FzZSBSZXNvdXJjZUltcGFjdC5XSUxMX0RFU1RST1k6XG4gICAgICByZXR1cm4gY29sb3JzLml0YWxpYyhjb2xvcnMuYm9sZChjb2xvcnMucmVkKCdkZXN0cm95JykpKTtcbiAgICBjYXNlIFJlc291cmNlSW1wYWN0LldJTExfT1JQSEFOOlxuICAgICAgcmV0dXJuIGNvbG9ycy5pdGFsaWMoY29sb3JzLnllbGxvdygnb3JwaGFuJykpO1xuICAgIGNhc2UgUmVzb3VyY2VJbXBhY3QuV0lMTF9VUERBVEU6XG4gICAgY2FzZSBSZXNvdXJjZUltcGFjdC5XSUxMX0NSRUFURTpcbiAgICAgIHJldHVybiAnJzsgLy8gbm8gZXh0cmEgaW5mbyBpcyBnYWluZWQgaGVyZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgdHJlZSBvZiBkaWZmZXJlbmNlcyB1bmRlciBhIHBhcnRpY3VsYXIgbmFtZS5cbiAgICogQHBhcmFtIG5hbWUgdGhlIG5hbWUgb2YgdGhlIHJvb3Qgb2YgdGhlIHRyZWUuXG4gICAqIEBwYXJhbSBkaWZmIHRoZSBkaWZmZXJlbmNlIG9uIHRoZSB0cmVlLlxuICAgKiBAcGFyYW0gbGFzdCB3aGV0aGVyIHRoaXMgaXMgdGhlIGxhc3Qgbm9kZSBvZiBhIHBhcmVudCB0cmVlLlxuICAgKi9cbiAgcHVibGljIGZvcm1hdFRyZWVEaWZmKG5hbWU6IHN0cmluZywgZGlmZjogRGlmZmVyZW5jZTxhbnk+LCBsYXN0OiBib29sZWFuKSB7XG4gICAgbGV0IGFkZGl0aW9uYWxJbmZvID0gJyc7XG4gICAgaWYgKGlzUHJvcGVydHlEaWZmZXJlbmNlKGRpZmYpKSB7XG4gICAgICBpZiAoZGlmZi5jaGFuZ2VJbXBhY3QgPT09IFJlc291cmNlSW1wYWN0Lk1BWV9SRVBMQUNFKSB7XG4gICAgICAgIGFkZGl0aW9uYWxJbmZvID0gJyAobWF5IGNhdXNlIHJlcGxhY2VtZW50KSc7XG4gICAgICB9IGVsc2UgaWYgKGRpZmYuY2hhbmdlSW1wYWN0ID09PSAgUmVzb3VyY2VJbXBhY3QuV0lMTF9SRVBMQUNFKSB7XG4gICAgICAgIGFkZGl0aW9uYWxJbmZvID0gJyAocmVxdWlyZXMgcmVwbGFjZW1lbnQpJztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wcmludCgnICVz4pSAICVzICVzJXMnLCBsYXN0ID8gJ+KUlCcgOiAn4pScJywgdGhpcy5jaGFuZ2VUYWcoZGlmZi5vbGRWYWx1ZSwgZGlmZi5uZXdWYWx1ZSksIG5hbWUsIGFkZGl0aW9uYWxJbmZvKTtcbiAgICByZXR1cm4gdGhpcy5mb3JtYXRPYmplY3REaWZmKGRpZmYub2xkVmFsdWUsIGRpZmYubmV3VmFsdWUsIGAgJHtsYXN0ID8gJyAnIDogJ+KUgid9YCk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBvYmplY3RzLCBsb29raW5nIGZvciB0aGUgZGlmZmVyZW5jZXMgYXMgZGVlcCBhcyBwb3NzaWJsZSxcbiAgICogYW5kIHJlbmRlcmluZyBhIHRyZWUgZ3JhcGggb2YgdGhlIHBhdGggdW50aWwgdGhlIGRpZmZlcmVuY2UgaXMgZm91bmQuXG4gICAqXG4gICAqIEBwYXJhbSBvbGRPYmplY3QgIHRoZSBvbGQgb2JqZWN0LlxuICAgKiBAcGFyYW0gbmV3T2JqZWN0ICB0aGUgbmV3IG9iamVjdC5cbiAgICogQHBhcmFtIGxpbmVQcmVmaXggYSBwcmVmaXggKGluZGVudC1saWtlKSB0byBiZSB1c2VkIG9uIGV2ZXJ5IGxpbmUuXG4gICAqL1xuICBwdWJsaWMgZm9ybWF0T2JqZWN0RGlmZihvbGRPYmplY3Q6IGFueSwgbmV3T2JqZWN0OiBhbnksIGxpbmVQcmVmaXg6IHN0cmluZykge1xuICAgIGlmICgodHlwZW9mIG9sZE9iamVjdCAhPT0gdHlwZW9mIG5ld09iamVjdCkgfHwgQXJyYXkuaXNBcnJheShvbGRPYmplY3QpIHx8IHR5cGVvZiBvbGRPYmplY3QgPT09ICdzdHJpbmcnIHx8wqB0eXBlb2Ygb2xkT2JqZWN0ID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKG9sZE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIG5ld09iamVjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMucHJpbnQoJyVzICAg4pSc4pSAICVzICVzJywgbGluZVByZWZpeCwgUkVNT1ZBTCwgdGhpcy5mb3JtYXRWYWx1ZShvbGRPYmplY3QsIGNvbG9ycy5yZWQpKTtcbiAgICAgICAgdGhpcy5wcmludCgnJXMgICDilJTilIAgJXMgJXMnLCBsaW5lUHJlZml4LCBBRERJVElPTiwgdGhpcy5mb3JtYXRWYWx1ZShuZXdPYmplY3QsIGNvbG9ycy5ncmVlbikpO1xuICAgICAgfSBlbHNlIGlmIChvbGRPYmplY3QgIT09IHVuZGVmaW5lZCAvKiAmJiBuZXdPYmplY3QgPT09IHVuZGVmaW5lZCAqLykge1xuICAgICAgICB0aGlzLnByaW50KCclcyAgIOKUlOKUgCAlcycsIGxpbmVQcmVmaXgsIHRoaXMuZm9ybWF0VmFsdWUob2xkT2JqZWN0LCBjb2xvcnMucmVkKSk7XG4gICAgICB9IGVsc2UgLyogaWYgKG9sZE9iamVjdCA9PT0gdW5kZWZpbmVkICYmIG5ld09iamVjdCAhPT0gdW5kZWZpbmVkKSAqLyB7XG4gICAgICAgIHRoaXMucHJpbnQoJyVzICAg4pSU4pSAICVzJywgbGluZVByZWZpeCwgdGhpcy5mb3JtYXRWYWx1ZShuZXdPYmplY3QsIGNvbG9ycy5ncmVlbikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBrZXlTZXQgPSBuZXcgU2V0KE9iamVjdC5rZXlzKG9sZE9iamVjdCkpO1xuICAgIE9iamVjdC5rZXlzKG5ld09iamVjdCkuZm9yRWFjaChrID0+IGtleVNldC5hZGQoaykpO1xuICAgIGNvbnN0IGtleXMgPSBuZXcgQXJyYXkoLi4ua2V5U2V0KS5maWx0ZXIoayA9PiAhZGVlcEVxdWFsKG9sZE9iamVjdFtrXSwgbmV3T2JqZWN0W2tdKSkuc29ydCgpO1xuICAgIGNvbnN0IGxhc3RLZXkgPSBrZXlzW2tleXMubGVuZ3RoIC0gMV07XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgY29uc3Qgb2xkVmFsdWUgPSBvbGRPYmplY3Rba2V5XTtcbiAgICAgIGNvbnN0IG5ld1ZhbHVlID0gbmV3T2JqZWN0W2tleV07XG4gICAgICBjb25zdCB0cmVlUHJlZml4ID0ga2V5ID09PSBsYXN0S2V5ID8gJ+KUlCcgOiAn4pScJztcbiAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIG5ld1ZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5wcmludCgnJXMgICAlc+KUgCAlcyAlczonLCBsaW5lUHJlZml4LCB0cmVlUHJlZml4LCB0aGlzLmNoYW5nZVRhZyhvbGRWYWx1ZSwgbmV3VmFsdWUpLCBjb2xvcnMuYmx1ZShgLiR7a2V5fWApKTtcbiAgICAgICAgdGhpcy5mb3JtYXRPYmplY3REaWZmKG9sZFZhbHVlLCBuZXdWYWx1ZSwgYCR7bGluZVByZWZpeH0gICAke2tleSA9PT0gbGFzdEtleSA/ICcgJyA6ICfilIInfWApO1xuICAgICAgfSBlbHNlIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkIC8qICYmIG5ld1ZhbHVlID09PSB1bmRlZmluZWQgKi8pIHtcbiAgICAgICAgdGhpcy5wcmludCgnJXMgICAlc+KUgCAlcyBSZW1vdmVkOiAlcycsIGxpbmVQcmVmaXgsIHRyZWVQcmVmaXgsIFJFTU9WQUwsIGNvbG9ycy5ibHVlKGAuJHtrZXl9YCkpO1xuICAgICAgfSBlbHNlIC8qIGlmIChvbGRWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG5ld1ZhbHVlICE9PSB1bmRlZmluZWQgKi8ge1xuICAgICAgICB0aGlzLnByaW50KCclcyAgICVz4pSAICVzIEFkZGVkOiAlcycsIGxpbmVQcmVmaXgsIHRyZWVQcmVmaXgsIEFERElUSU9OLCBjb2xvcnMuYmx1ZShgLiR7a2V5fWApKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIG9sZFZhbHVlIHRoZSBvbGQgdmFsdWUgb2YgYSBkaWZmZXJlbmNlLlxuICAgKiBAcGFyYW0gbmV3VmFsdWUgdGhlIG5ldyB2YWx1ZSBvZiBhIGRpZmZlcmVuY2UuXG4gICAqXG4gICAqIEByZXR1cm5zIGEgdGFnIHRvIGJlIHJlbmRlcmVkIGluIHRoZSBkaWZmLCByZWZsZWN0aW5nIHdoZXRoZXIgdGhlIGRpZmZlcmVuY2VcbiAgICogICAgICB3YXMgYW4gQURESVRJT04sIFVQREFURSBvciBSRU1PVkFMLlxuICAgKi9cbiAgcHVibGljIGNoYW5nZVRhZyhvbGRWYWx1ZTogYW55IHwgdW5kZWZpbmVkLCBuZXdWYWx1ZTogYW55IHwgdW5kZWZpbmVkKTogc3RyaW5nIHtcbiAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBuZXdWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gVVBEQVRFO1xuICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCAvKiAmJiBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKi8pIHtcbiAgICAgIHJldHVybiBSRU1PVkFMO1xuICAgIH0gZWxzZSAvKiBpZiAob2xkVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBuZXdWYWx1ZSAhPT0gdW5kZWZpbmVkKSAqLyB7XG4gICAgICByZXR1cm4gQURESVRJT047XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgJ2F3czpjZGs6cGF0aCcgbWV0YWRhdGEgaW4gdGhlIGRpZmYgYW5kIGFkZCBpdCB0byB0aGUgbG9naWNhbFRvUGF0aE1hcFxuICAgKlxuICAgKiBUaGVyZSBhcmUgbXVsdGlwbGUgc291cmNlcyBvZiBsb2dpY2FsSUQgLT4gcGF0aCBtYXBwaW5nczogc3ludGggbWV0YWRhdGFcbiAgICogYW5kIHJlc291cmNlIG1ldGFkYXRhLCBhbmQgd2UgY29tYmluZSBhbGwgc291cmNlcyBpbnRvIGEgc2luZ2xlIG1hcC5cbiAgICovXG4gIHB1YmxpYyByZWFkQ29uc3RydWN0UGF0aHNGcm9tKHRlbXBsYXRlRGlmZjogVGVtcGxhdGVEaWZmKSB7XG4gICAgZm9yIChjb25zdCBbbG9naWNhbElkLCByZXNvdXJjZURpZmZdIG9mIE9iamVjdC5lbnRyaWVzKHRlbXBsYXRlRGlmZi5yZXNvdXJjZXMpKSB7XG4gICAgICBpZiAoIXJlc291cmNlRGlmZikgeyBjb250aW51ZTsgfVxuXG4gICAgICBjb25zdCBvbGRQYXRoTWV0YWRhdGEgPSByZXNvdXJjZURpZmYub2xkVmFsdWUgJiYgcmVzb3VyY2VEaWZmLm9sZFZhbHVlLk1ldGFkYXRhICYmIHJlc291cmNlRGlmZi5vbGRWYWx1ZS5NZXRhZGF0YVtjeGFwaS5QQVRIX01FVEFEQVRBX0tFWV07XG4gICAgICBpZiAob2xkUGF0aE1ldGFkYXRhICYmICEobG9naWNhbElkIGluIHRoaXMubG9naWNhbFRvUGF0aE1hcCkpIHtcbiAgICAgICAgdGhpcy5sb2dpY2FsVG9QYXRoTWFwW2xvZ2ljYWxJZF0gPSBvbGRQYXRoTWV0YWRhdGE7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld1BhdGhNZXRhZGF0YSA9IHJlc291cmNlRGlmZi5uZXdWYWx1ZSAmJiByZXNvdXJjZURpZmYubmV3VmFsdWUuTWV0YWRhdGEgJiYgcmVzb3VyY2VEaWZmLm5ld1ZhbHVlLk1ldGFkYXRhW2N4YXBpLlBBVEhfTUVUQURBVEFfS0VZXTtcbiAgICAgIGlmIChuZXdQYXRoTWV0YWRhdGEgJiYgIShsb2dpY2FsSWQgaW4gdGhpcy5sb2dpY2FsVG9QYXRoTWFwKSkge1xuICAgICAgICB0aGlzLmxvZ2ljYWxUb1BhdGhNYXBbbG9naWNhbElkXSA9IG5ld1BhdGhNZXRhZGF0YTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZm9ybWF0TG9naWNhbElkKGxvZ2ljYWxJZDogc3RyaW5nKSB7XG4gICAgLy8gaWYgd2UgaGF2ZSBhIHBhdGggaW4gdGhlIG1hcCwgcmV0dXJuIGl0XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHRoaXMubm9ybWFsaXplZExvZ2ljYWxJZFBhdGgobG9naWNhbElkKTtcblxuICAgIGlmIChub3JtYWxpemVkKSB7XG4gICAgICByZXR1cm4gYCR7bm9ybWFsaXplZH0gJHtjb2xvcnMuZ3JheShsb2dpY2FsSWQpfWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxvZ2ljYWxJZDtcbiAgfVxuXG4gIHB1YmxpYyBub3JtYWxpemVkTG9naWNhbElkUGF0aChsb2dpY2FsSWQ6IHN0cmluZyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgLy8gaWYgd2UgaGF2ZSBhIHBhdGggaW4gdGhlIG1hcCwgcmV0dXJuIGl0XG4gICAgY29uc3QgcGF0aCA9IHRoaXMubG9naWNhbFRvUGF0aE1hcFtsb2dpY2FsSWRdO1xuICAgIHJldHVybiBwYXRoID8gbm9ybWFsaXplUGF0aChwYXRoKSA6IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFBhdGggaXMgc3VwcG9zZWQgdG8gc3RhcnQgd2l0aCBcIi9zdGFjay1uYW1lXCIuIElmIHRoaXMgaXMgdGhlIGNhc2UgKGkuZS4gcGF0aCBoYXMgbW9yZSB0aGFuXG4gICAgICogdHdvIGNvbXBvbmVudHMsIHdlIHJlbW92ZSB0aGUgZmlyc3QgcGFydC4gT3RoZXJ3aXNlLCB3ZSBqdXN0IHVzZSB0aGUgZnVsbCBwYXRoLlxuICAgICAqIEBwYXJhbSBwXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplUGF0aChwOiBzdHJpbmcpIHtcbiAgICAgIGlmIChwLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICBwID0gcC5zdWJzdHIoMSk7XG4gICAgICB9XG5cbiAgICAgIGxldCBwYXJ0cyA9IHAuc3BsaXQoJy8nKTtcbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHBhcnRzID0gcGFydHMuc2xpY2UoMSk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBsYXN0IGNvbXBvbmVudCBpZiBpdCdzIFwiUmVzb3VyY2VcIiBvciBcIkRlZmF1bHRcIiAoaWYgd2UgaGF2ZSBtb3JlIHRoYW4gYSBzaW5nbGUgY29tcG9uZW50KVxuICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGNvbnN0IGxhc3QgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAobGFzdCA9PT0gJ1Jlc291cmNlJyB8fCBsYXN0ID09PSAnRGVmYXVsdCcpIHtcbiAgICAgICAgICAgIHBhcnRzID0gcGFydHMuc2xpY2UoMCwgcGFydHMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcCA9IHBhcnRzLmpvaW4oJy8nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBmb3JtYXRJYW1DaGFuZ2VzKGNoYW5nZXM6IElhbUNoYW5nZXMpIHtcbiAgICBpZiAoIWNoYW5nZXMuaGFzQ2hhbmdlcykgeyByZXR1cm47IH1cblxuICAgIGlmIChjaGFuZ2VzLnN0YXRlbWVudHMuaGFzQ2hhbmdlcykge1xuICAgICAgdGhpcy5wcmludFNlY3Rpb25IZWFkZXIoJ0lBTSBTdGF0ZW1lbnQgQ2hhbmdlcycpO1xuICAgICAgdGhpcy5wcmludChyZW5kZXJUYWJsZSh0aGlzLmRlZXBTdWJzdGl0dXRlQnJhY2VkTG9naWNhbElkcyhjaGFuZ2VzLnN1bW1hcml6ZVN0YXRlbWVudHMoKSkpKTtcbiAgICB9XG5cbiAgICBpZiAoY2hhbmdlcy5tYW5hZ2VkUG9saWNpZXMuaGFzQ2hhbmdlcykge1xuICAgICAgdGhpcy5wcmludFNlY3Rpb25IZWFkZXIoJ0lBTSBQb2xpY3kgQ2hhbmdlcycpO1xuICAgICAgdGhpcy5wcmludChyZW5kZXJUYWJsZSh0aGlzLmRlZXBTdWJzdGl0dXRlQnJhY2VkTG9naWNhbElkcyhjaGFuZ2VzLnN1bW1hcml6ZU1hbmFnZWRQb2xpY2llcygpKSkpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBmb3JtYXRTZWN1cml0eUdyb3VwQ2hhbmdlcyhjaGFuZ2VzOiBTZWN1cml0eUdyb3VwQ2hhbmdlcykge1xuICAgIGlmICghY2hhbmdlcy5oYXNDaGFuZ2VzKSB7IHJldHVybjsgfVxuXG4gICAgdGhpcy5wcmludFNlY3Rpb25IZWFkZXIoJ1NlY3VyaXR5IEdyb3VwIENoYW5nZXMnKTtcbiAgICB0aGlzLnByaW50KHJlbmRlclRhYmxlKHRoaXMuZGVlcFN1YnN0aXR1dGVCcmFjZWRMb2dpY2FsSWRzKGNoYW5nZXMuc3VtbWFyaXplKCkpKSk7XG4gIH1cblxuICBwdWJsaWMgZGVlcFN1YnN0aXR1dGVCcmFjZWRMb2dpY2FsSWRzKHJvd3M6IHN0cmluZ1tdW10pOiBzdHJpbmdbXVtdIHtcbiAgICByZXR1cm4gcm93cy5tYXAocm93ID0+IHJvdy5tYXAodGhpcy5zdWJzdGl0dXRlQnJhY2VkTG9naWNhbElkcy5iaW5kKHRoaXMpKSk7XG4gIH1cblxuICAvKipcbiAgICogU3Vic3RpdHV0ZSBhbGwgc3RyaW5ncyBsaWtlICR7TG9nSWQueHh4fSB3aXRoIHRoZSBwYXRoIGluc3RlYWQgb2YgdGhlIGxvZ2ljYWwgSURcbiAgICovXG4gIHB1YmxpYyBzdWJzdGl0dXRlQnJhY2VkTG9naWNhbElkcyhzb3VyY2U6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHNvdXJjZS5yZXBsYWNlKC9cXCRcXHsoW14ufV0rKSguW159XSspP1xcfS9pZywgKF9tYXRjaCwgbG9nSWQsIHN1ZmZpeCkgPT4ge1xuICAgICAgcmV0dXJuICckeycgKyAodGhpcy5ub3JtYWxpemVkTG9naWNhbElkUGF0aChsb2dJZCkgfHwgbG9nSWQpICsgKHN1ZmZpeCB8fCAnJykgKyAnfSc7XG4gIH0pO1xuICB9XG59XG5cbi8qKlxuICogUmVuZGVyIGEgdHdvLWRpbWVuc2lvbmFsIGFycmF5IHRvIGEgdmlzdWFsbHkgYXR0cmFjdGl2ZSB0YWJsZVxuICpcbiAqIEZpcnN0IHJvdyBpcyBjb25zaWRlcmVkIHRoZSB0YWJsZSBoZWFkZXIuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclRhYmxlKGNlbGxzOiBzdHJpbmdbXVtdKTogc3RyaW5nIHtcbiAgY29uc3QgaGVhZCA9IGNlbGxzLnNwbGljZSgwLCAxKVswXTtcblxuICBjb25zdCB0YWJsZSA9IG5ldyBUYWJsZSh7IGhlYWQsIHN0eWxlOiB7IGhlYWQ6IFtdIH0gfSk7XG4gIHRhYmxlLnB1c2goLi4uY2VsbHMpO1xuICByZXR1cm4gc3RyaXBIb3Jpem9udGFsTGluZXModGFibGUudG9TdHJpbmcoKSkudHJpbVJpZ2h0KCk7XG59XG5cbi8qKlxuICogU3RyaXAgaG9yaXpvbnRhbCBsaW5lcyBpbiB0aGUgdGFibGUgcmVuZGVyaW5nIGlmIHRoZSBzZWNvbmQtY29sdW1uIHZhbHVlcyBhcmUgdGhlIHNhbWVcbiAqXG4gKiBXZSBjb3VsZG4ndCBmaW5kIGEgdGFibGUgbGlicmFyeSB0aGF0IEJPVEggZG9lcyBuZXdsaW5lcy1pbi1jZWxscyBjb3JyZWN0bHkgQU5EXG4gKiBoYXMgYW4gb3B0aW9uIHRvIGVuYWJsZS9kaXNhYmxlIHNlcGFyYXRvciBsaW5lcyBvbiBhIHBlci1yb3cgYmFzaXMuIFNvIHdlJ3JlXG4gKiBnb2luZyB0byBkbyBzb21lIGNoYXJhY3RlciBwb3N0LXByb2Nlc3Npbmcgb24gdGhlIHRhYmxlIGluc3RlYWQuXG4gKi9cbmZ1bmN0aW9uIHN0cmlwSG9yaXpvbnRhbExpbmVzKHRhYmxlUmVuZGVyaW5nOiBzdHJpbmcpIHtcbiAgY29uc3QgbGluZXMgPSB0YWJsZVJlbmRlcmluZy5zcGxpdCgnXFxuJyk7XG5cbiAgbGV0IGkgPSAzO1xuICB3aGlsZSAoaSA8IGxpbmVzLmxlbmd0aCAtIDMpIHtcbiAgICBpZiAoc2Vjb25kQ29sdW1uVmFsdWUobGluZXNbaV0pID09PSBzZWNvbmRDb2x1bW5WYWx1ZShsaW5lc1tpICsgMl0pKSB7XG4gICAgICBsaW5lcy5zcGxpY2UoaSArIDEsIDEpO1xuICAgICAgaSArPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpICs9IDI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xuXG4gIGZ1bmN0aW9uIHNlY29uZENvbHVtblZhbHVlKGxpbmU6IHN0cmluZykge1xuICAgIGNvbnN0IGNvbHMgPSBjb2xvcnMuc3RyaXBDb2xvcnMobGluZSkuc3BsaXQoJ+KUgicpLmZpbHRlcih4ID0+IHggIT09ICcnKTtcbiAgICByZXR1cm4gY29sc1sxXTtcbiAgfVxufVxuIl19
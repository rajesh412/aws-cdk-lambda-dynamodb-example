"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cxapi = require("@aws-cdk/cx-api");
const app_1 = require("../app");
const construct_1 = require("../core/construct");
const tokens_1 = require("../core/tokens");
const cloudformation_token_1 = require("./cloudformation-token");
const logical_id_1 = require("./logical-id");
/**
 * A root construct which represents a single CloudFormation stack.
 */
class Stack extends construct_1.Construct {
    /**
     * Creates a new stack.
     *
     * @param parent Parent of this stack, usually a Program instance.
     * @param name The name of the CloudFormation stack. Defaults to "Stack".
     * @param props Stack properties.
     */
    constructor(parent, name, props) {
        // For unit test convenience parents are optional, so bypass the type check when calling the parent.
        super(parent, name);
        /**
         * Lists all missing contextual information.
         * This is returned when the stack is synthesized under the 'missing' attribute
         * and allows tooling to obtain the context and re-synthesize.
         */
        this.missingContext = {};
        /**
         * Options for CloudFormation template (like version, transform, description).
         */
        this.templateOptions = {};
        /**
         * Used to determine if this construct is a stack.
         */
        this._isStack = true;
        this.env = this.parseEnvironment(props);
        this.logicalIds = new logical_id_1.LogicalIDs(props && props.namingScheme ? props.namingScheme : new logical_id_1.HashedAddressingScheme());
        this.name = this.id;
    }
    /**
     * Traverses the tree and looks up for the Stack root.
     * @param node A construct in the tree
     * @returns The Stack object (throws if the node is not part of a Stack-rooted tree)
     */
    static find(node) {
        let curr = node;
        while (curr != null && !Stack.isStack(curr)) {
            curr = curr.parent;
        }
        if (curr == null) {
            throw new Error(`Cannot find a Stack parent for '${node.toString()}'`);
        }
        return curr;
    }
    /**
     * Adds a metadata annotation "aws:cdk:physical-name" to the construct if physicalName
     * is non-null. This can be used later by tools and aspects to determine if resources
     * have been created with physical names.
     */
    static annotatePhysicalName(construct, physicalName) {
        if (physicalName == null) {
            return;
        }
        construct.addMetadata('aws:cdk:physical-name', physicalName);
    }
    /**
     * Return whether the given object is a Stack.
     *
     * We do attribute detection since we can't reliably use 'instanceof'.
     */
    static isStack(construct) {
        return construct._isStack;
    }
    /**
     * Looks up a resource by path.
     *
     * @returns The Resource or undefined if not found
     */
    findResource(path) {
        const r = this.findChild(path);
        if (!r) {
            return undefined;
        }
        // found an element, check if it's a resource (duck-type)
        if (!('resourceType' in r)) {
            throw new Error(`Found a stack element for ${path} but it is not a resource: ${r.toString()}`);
        }
        return r;
    }
    /**
     * Returns the CloudFormation template for this stack by traversing
     * the tree and invoking toCloudFormation() on all Entity objects.
     */
    toCloudFormation() {
        // before we begin synthesis, we shall lock this stack, so children cannot be added
        this.lock();
        try {
            const template = {
                Description: this.templateOptions.description,
                Transform: this.templateOptions.transform,
                AWSTemplateFormatVersion: this.templateOptions.templateFormatVersion,
                Metadata: this.templateOptions.metadata
            };
            const elements = stackElements(this);
            const fragments = elements.map(e => e.toCloudFormation());
            // merge in all CloudFormation fragments collected from the tree
            for (const fragment of fragments) {
                merge(template, fragment);
            }
            // resolve all tokens and remove all empties
            const ret = tokens_1.resolve(template) || {};
            this.logicalIds.assertAllRenamesApplied();
            return ret;
        }
        finally {
            // allow mutations after synthesis is finished.
            this.unlock();
        }
    }
    /**
     * @param why more information about why region is required.
     * @returns The region in which this stack is deployed. Throws if region is not defined.
     */
    requireRegion(why) {
        if (!this.env.region) {
            throw new Error(`${why ? why + '. ' : ''}Stack requires region information. It can be either supplied via the "env" property, ` +
                `via the "${cxapi.DEFAULT_REGION_CONTEXT_KEY}" context parameters or using "aws configure"`);
        }
        return this.env.region;
    }
    /**
     * Returns the AWS account ID of this Stack,
     * or throws an exception if the account ID is not set in the environment.
     *
     * @param why more information about why is the account ID required
     * @returns the AWS account ID of this Stack
     */
    requireAccountId(why) {
        if (!this.env.account) {
            throw new Error(`${why ? why + '. ' : ''}Stack requires account information. ` +
                'It can be supplied either via the "env" property when creating the Stack, or by using "aws configure"');
        }
        return this.env.account;
    }
    parentApp() {
        const parent = this.parent;
        return parent instanceof app_1.App
            ? parent
            : undefined;
    }
    /**
     * Indicate that a context key was expected
     *
     * Contains instructions on how the key should be supplied.
     * @param key Key that uniquely identifies this missing context.
     * @param details The set of parameters needed to obtain the context (specific to context provider).
     */
    reportMissingContext(key, details) {
        this.missingContext[key] = details;
    }
    /**
     * Rename a generated logical identities
     */
    renameLogical(oldId, newId) {
        // tslint:disable-next-line:no-console
        if (this.children.length > 0) {
            throw new Error("All renames must be set up before adding elements to the stack");
        }
        this.logicalIds.renameLogical(oldId, newId);
    }
    /**
     * Validate stack name
     *
     * CloudFormation stack names can include dashes in addition to the regular identifier
     * character classes, and we don't allow one of the magic markers.
     */
    _validateId(name) {
        if (name && !Stack.VALID_STACK_NAME_REGEX.test(name)) {
            throw new Error(`Stack name must match the regular expression: ${Stack.VALID_STACK_NAME_REGEX.toString()}, got '${name}'`);
        }
    }
    /**
     * Applied defaults to environment attributes.
     */
    parseEnvironment(props) {
        // start with `env`.
        const env = (props && props.env) || {};
        // if account is not specified, attempt to read from context.
        if (!env.account) {
            env.account = this.getContext(cxapi.DEFAULT_ACCOUNT_CONTEXT_KEY);
        }
        // if region is not specified, attempt to read from context.
        if (!env.region) {
            env.region = this.getContext(cxapi.DEFAULT_REGION_CONTEXT_KEY);
        }
        return env;
    }
}
Stack.VALID_STACK_NAME_REGEX = /^[A-Za-z][A-Za-z0-9-]*$/;
exports.Stack = Stack;
function merge(template, part) {
    for (const section of Object.keys(part)) {
        const src = part[section];
        // create top-level section if it doesn't exist
        let dest = template[section];
        if (!dest) {
            template[section] = dest = src;
        }
        else {
            // add all entities from source section to destination section
            for (const id of Object.keys(src)) {
                if (id in dest) {
                    throw new Error(`section '${section}' already contains '${id}'`);
                }
                dest[id] = src[id];
            }
        }
    }
}
const LOGICAL_ID_MD = 'aws:cdk:logicalId';
/**
 * An element of a CloudFormation stack.
 */
class StackElement extends construct_1.Construct {
    /**
     * Returns `true` if a construct is a stack element (i.e. part of the
     * synthesized cloudformation template).
     *
     * Uses duck-typing instead of `instanceof` to allow stack elements from different
     * versions of this library to be included in the same stack.
     *
     * @returns The construct as a stack element or undefined if it is not a stack element.
     */
    static _asStackElement(construct) {
        if ('logicalId' in construct && 'toCloudFormation' in construct) {
            return construct;
        }
        else {
            return undefined;
        }
    }
    /**
     * Creates an entity and binds it to a tree.
     * Note that the root of the tree must be a Stack object (not just any Root).
     *
     * @param parent The parent construct
     * @param props Construct properties
     */
    constructor(parent, name) {
        super(parent, name);
        const s = Stack.find(this);
        if (!s) {
            throw new Error('The tree root must be derived from "Stack"');
        }
        this.stack = s;
        this.addMetadata(LOGICAL_ID_MD, new tokens_1.Token(() => this.logicalId), this.constructor);
        this.logicalId = this.stack.logicalIds.getLogicalId(this);
    }
    /**
     * @returns the stack trace of the point where this Resource was created from, sourced
     *      from the +metadata+ entry typed +aws:cdk:logicalId+, and with the bottom-most
     *      node +internal+ entries filtered.
     */
    get creationStackTrace() {
        return filterStackTrace(this.metadata.find(md => md.type === LOGICAL_ID_MD).trace);
        function filterStackTrace(stack) {
            const result = Array.of(...stack);
            while (result.length > 0 && shouldFilter(result[result.length - 1])) {
                result.pop();
            }
            // It's weird if we filtered everything, so return the whole stack...
            return result.length === 0 ? stack : result;
        }
        function shouldFilter(str) {
            return str.match(/[^(]+\(internal\/.*/) !== null;
        }
    }
    /**
     * Return the path with respect to the stack
     */
    get stackPath() {
        return this.ancestors(this.stack).map(c => c.id).join(construct_1.PATH_SEP);
    }
    get dependencyElements() {
        return [this];
    }
}
exports.StackElement = StackElement;
/**
 * Base class for referenceable CloudFormation constructs which are not Resources
 *
 * These constructs are things like Conditions and Parameters, can be
 * referenced by taking the `.ref` attribute.
 *
 * Resource constructs do not inherit from Referenceable because they have their
 * own, more specific types returned from the .ref attribute. Also, some
 * resources aren't referenceable at all (such as BucketPolicies or GatewayAttachments).
 */
class Referenceable extends StackElement {
    /**
     * Returns a token to a CloudFormation { Ref } that references this entity based on it's logical ID.
     */
    get ref() {
        return new Ref(this).toString();
    }
}
exports.Referenceable = Referenceable;
/**
 * Collect all StackElements from a construct
 *
 * @param node Root node to collect all StackElements from
 * @param into Array to append StackElements to
 * @returns The same array as is being collected into
 */
function stackElements(node, into = []) {
    const element = StackElement._asStackElement(node);
    if (element) {
        into.push(element);
    }
    for (const child of node.children) {
        stackElements(child, into);
    }
    return into;
}
/**
 * A generic, untyped reference to a Stack Element
 */
class Ref extends cloudformation_token_1.CloudFormationToken {
    constructor(element) {
        super({ Ref: element.logicalId }, `${element.logicalId}.Ref`);
    }
}
exports.Ref = Ref;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhY2suanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJzdGFjay50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHlDQUEwQztBQUMxQyxnQ0FBNkI7QUFDN0IsaURBQXdEO0FBQ3hELDJDQUFnRDtBQUVoRCxpRUFBNkQ7QUFDN0QsNkNBQXFGO0FBb0JyRjs7R0FFRztBQUNILE1BQWEsS0FBTSxTQUFRLHFCQUFTO0lBMEVsQzs7Ozs7O09BTUc7SUFDSCxZQUFtQixNQUFZLEVBQUUsSUFBYSxFQUFFLEtBQWtCO1FBQ2hFLG9HQUFvRztRQUNwRyxLQUFLLENBQUMsTUFBTyxFQUFFLElBQUssQ0FBQyxDQUFDO1FBekN4Qjs7OztXQUlHO1FBQ2EsbUJBQWMsR0FBNEMsRUFBRyxDQUFDO1FBWTlFOztXQUVHO1FBQ2Esb0JBQWUsR0FBb0IsRUFBRSxDQUFDO1FBT3REOztXQUVHO1FBQ2dCLGFBQVEsR0FBRyxJQUFJLENBQUM7UUFZakMsSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFeEMsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLHVCQUFVLENBQUMsS0FBSyxJQUFJLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLElBQUksbUNBQXNCLEVBQUUsQ0FBQyxDQUFDO1FBQ2xILElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQztJQUN0QixDQUFDO0lBdkZEOzs7O09BSUc7SUFDSSxNQUFNLENBQUMsSUFBSSxDQUFDLElBQWU7UUFDaEMsSUFBSSxJQUFJLEdBQTBCLElBQUksQ0FBQztRQUN2QyxPQUFPLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQzNDLElBQUksR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO1NBQ3BCO1FBRUQsSUFBSSxJQUFJ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QyxJQUFJLENBQUMsQ0FBQztJQUNuRCxJQUFJLE9BQU8sRUFBRTtRQUNYLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7S0FDcEI7SUFFRCxLQUFLLE1BQU0sS0FBSyxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7UUFDakMsYUFBYSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztLQUM1QjtJQUVELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQztBQUVEOztHQUVHO0FBQ0gsTUFBYSxHQUFJLFNBQVEsMENBQW1CO0lBQzFDLFlBQVksT0FBcUI7UUFDL0IsS0FBSyxDQUFDLEVBQUUsR0FBRyxFQUFFLE9BQU8sQ0FBQyxTQUFTLEVBQUUsRUFBRSxHQUFHLE9BQU8sQ0FBQyxTQUFTLE1BQU0sQ0FBQyxDQUFDO0lBQ2hFLENBQUM7Q0FDRjtBQUpELGtCQUlDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGN4YXBpID0gcmVxdWlyZSgnQGF3cy1jZGsvY3gtYXBpJyk7XG5pbXBvcnQgeyBBcHAgfSBmcm9tICcuLi9hcHAnO1xuaW1wb3J0IHsgQ29uc3RydWN0LCBQQVRIX1NFUCB9IGZyb20gJy4uL2NvcmUvY29uc3RydWN0JztcbmltcG9ydCB7IHJlc29sdmUsIFRva2VuIH0gZnJvbSAnLi4vY29yZS90b2tlbnMnO1xuaW1wb3J0IHsgRW52aXJvbm1lbnQgfSBmcm9tICcuLi9lbnZpcm9ubWVudCc7XG5pbXBvcnQgeyBDbG91ZEZvcm1hdGlvblRva2VuIH0gZnJvbSAnLi9jbG91ZGZvcm1hdGlvbi10b2tlbic7XG5pbXBvcnQgeyBIYXNoZWRBZGRyZXNzaW5nU2NoZW1lLCBJQWRkcmVzc2luZ1NjaGVtZSwgTG9naWNhbElEcyB9IGZyb20gJy4vbG9naWNhbC1pZCc7XG5pbXBvcnQgeyBSZXNvdXJjZSB9IGZyb20gJy4vcmVzb3VyY2UnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFN0YWNrUHJvcHMge1xuICAvKipcbiAgICogVGhlIEFXUyBlbnZpcm9ubWVudCAoYWNjb3VudC9yZWdpb24pIHdoZXJlIHRoaXMgc3RhY2sgd2lsbCBiZSBkZXBsb3llZC5cbiAgICpcbiAgICogSWYgbm90IHN1cHBsaWVkLCB0aGUgYGRlZmF1bHQtYWNjb3VudGAgYW5kIGBkZWZhdWx0LXJlZ2lvbmAgY29udGV4dCBwYXJhbWV0ZXJzIHdpbGwgYmVcbiAgICogdXNlZC4gSWYgdGhleSBhcmUgdW5kZWZpbmVkLCBpdCB3aWxsIG5vdCBiZSBwb3NzaWJsZSB0byBkZXBsb3kgdGhlIHN0YWNrLlxuICAgKi9cbiAgZW52PzogRW52aXJvbm1lbnQ7XG5cbiAgLyoqXG4gICAqIFN0cmF0ZWd5IGZvciBsb2dpY2FsIElEIGdlbmVyYXRpb25cbiAgICpcbiAgICogT3B0aW9uYWwuIElmIG5vdCBzdXBwbGllZCwgdGhlIEhhc2hlZE5hbWluZ1NjaGVtZSB3aWxsIGJlIHVzZWQuXG4gICAqL1xuICBuYW1pbmdTY2hlbWU/OiBJQWRkcmVzc2luZ1NjaGVtZTtcbn1cblxuLyoqXG4gKiBBIHJvb3QgY29uc3RydWN0IHdoaWNoIHJlcHJlc2VudHMgYSBzaW5nbGUgQ2xvdWRGb3JtYXRpb24gc3RhY2suXG4gKi9cbmV4cG9ydCBjbGFzcyBTdGFjayBleHRlbmRzIENvbnN0cnVjdCB7XG4gIC8qKlxuICAgKiBUcmF2ZXJzZXMgdGhlIHRyZWUgYW5kIGxvb2tzIHVwIGZvciB0aGUgU3RhY2sgcm9vdC5cbiAgICogQHBhcmFtIG5vZGUgQSBjb25zdHJ1Y3QgaW4gdGhlIHRyZWVcbiAgICogQHJldHVybnMgVGhlIFN0YWNrIG9iamVjdCAodGhyb3dzIGlmIHRoZSBub2RlIGlzIG5vdCBwYXJ0IG9mIGEgU3RhY2stcm9vdGVkIHRyZWUpXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZpbmQobm9kZTogQ29uc3RydWN0KTogU3RhY2sge1xuICAgIGxldCBjdXJyOiBDb25zdHJ1Y3QgfCB1bmRlZmluZWQgPSBub2RlO1xuICAgIHdoaWxlIChjdXJyICE9IG51bGwgJiYgIVN0YWNrLmlzU3RhY2soY3VycikpIHtcbiAgICAgIGN1cnIgPSBjdXJyLnBhcmVudDtcbiAgICB9XG5cbiAgICBpZiAoY3VyciA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBmaW5kIGEgU3RhY2sgcGFyZW50IGZvciAnJHtub2RlLnRvU3RyaW5nKCl9J2ApO1xuICAgIH1cbiAgICByZXR1cm4gY3VycjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgbWV0YWRhdGEgYW5ub3RhdGlvbiBcImF3czpjZGs6cGh5c2ljYWwtbmFtZVwiIHRvIHRoZSBjb25zdHJ1Y3QgaWYgcGh5c2ljYWxOYW1lXG4gICAqIGlzIG5vbi1udWxsLiBUaGlzIGNhbiBiZSB1c2VkIGxhdGVyIGJ5IHRvb2xzIGFuZCBhc3BlY3RzIHRvIGRldGVybWluZSBpZiByZXNvdXJjZXNcbiAgICogaGF2ZSBiZWVuIGNyZWF0ZWQgd2l0aCBwaHlzaWNhbCBuYW1lcy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYW5ub3RhdGVQaHlzaWNhbE5hbWUoY29uc3RydWN0OiBDb25zdHJ1Y3QsIHBoeXNpY2FsTmFtZT86IHN0cmluZykge1xuICAgIGlmIChwaHlzaWNhbE5hbWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdC5hZGRNZXRhZGF0YSgnYXdzOmNkazpwaHlzaWNhbC1uYW1lJywgcGh5c2ljYWxOYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgU3RhY2suXG4gICAqXG4gICAqIFdlIGRvIGF0dHJpYnV0ZSBkZXRlY3Rpb24gc2luY2Ugd2UgY2FuJ3QgcmVsaWFibHkgdXNlICdpbnN0YW5jZW9mJy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgaXNTdGFjayhjb25zdHJ1Y3Q6IENvbnN0cnVjdCk6IGNvbnN0cnVjdCBpcyBTdGFjayB7XG4gICAgcmV0dXJuIChjb25zdHJ1Y3QgYXMgYW55KS5faXNTdGFjaztcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IFZBTElEX1NUQUNLX05BTUVfUkVHRVggPSAvXltBLVphLXpdW0EtWmEtejAtOS1dKiQvO1xuXG4gIC8qKlxuICAgKiBMaXN0cyBhbGwgbWlzc2luZyBjb250ZXh0dWFsIGluZm9ybWF0aW9uLlxuICAgKiBUaGlzIGlzIHJldHVybmVkIHdoZW4gdGhlIHN0YWNrIGlzIHN5bnRoZXNpemVkIHVuZGVyIHRoZSAnbWlzc2luZycgYXR0cmlidXRlXG4gICAqIGFuZCBhbGxvd3MgdG9vbGluZyB0byBvYnRhaW4gdGhlIGNvbnRleHQgYW5kIHJlLXN5bnRoZXNpemUuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgbWlzc2luZ0NvbnRleHQ6IHsgW2tleTogc3RyaW5nXTogY3hhcGkuTWlzc2luZ0NvbnRleHQgfSA9IHsgfTtcblxuICAvKipcbiAgICogVGhlIGVudmlyb25tZW50IGluIHdoaWNoIHRoaXMgc3RhY2sgaXMgZGVwbG95ZWQuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgZW52OiBFbnZpcm9ubWVudDtcblxuICAvKipcbiAgICogTG9naWNhbCBJRCBnZW5lcmF0aW9uIHN0cmF0ZWd5XG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgbG9naWNhbElkczogTG9naWNhbElEcztcblxuICAvKipcbiAgICogT3B0aW9ucyBmb3IgQ2xvdWRGb3JtYXRpb24gdGVtcGxhdGUgKGxpa2UgdmVyc2lvbiwgdHJhbnNmb3JtLCBkZXNjcmlwdGlvbikuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgdGVtcGxhdGVPcHRpb25zOiBUZW1wbGF0ZU9wdGlvbnMgPSB7fTtcblxuICAvKipcbiAgICogVGhlIENsb3VkRm9ybWF0aW9uIHN0YWNrIG5hbWUuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGRldGVybWluZSBpZiB0aGlzIGNvbnN0cnVjdCBpcyBhIHN0YWNrLlxuICAgKi9cbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9pc1N0YWNrID0gdHJ1ZTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBzdGFjay5cbiAgICpcbiAgICogQHBhcmFtIHBhcmVudCBQYXJlbnQgb2YgdGhpcyBzdGFjaywgdXN1YWxseSBhIFByb2dyYW0gaW5zdGFuY2UuXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBDbG91ZEZvcm1hdGlvbiBzdGFjay4gRGVmYXVsdHMgdG8gXCJTdGFja1wiLlxuICAgKiBAcGFyYW0gcHJvcHMgU3RhY2sgcHJvcGVydGllcy5cbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihwYXJlbnQ/OiBBcHAsIG5hbWU/OiBzdHJpbmcsIHByb3BzPzogU3RhY2tQcm9wcykge1xuICAgIC8vIEZvciB1bml0IHRlc3QgY29udmVuaWVuY2UgcGFyZW50cyBhcmUgb3B0aW9uYWwsIHNvIGJ5cGFzcyB0aGUgdHlwZSBjaGVjayB3aGVuIGNhbGxpbmcgdGhlIHBhcmVudC5cbiAgICBzdXBlcihwYXJlbnQhLCBuYW1lISk7XG4gICAgdGhpcy5lbnYgPSB0aGlzLnBhcnNlRW52aXJvbm1lbnQocHJvcHMpO1xuXG4gICAgdGhpcy5sb2dpY2FsSWRzID0gbmV3IExvZ2ljYWxJRHMocHJvcHMgJiYgcHJvcHMubmFtaW5nU2NoZW1lID8gcHJvcHMubmFtaW5nU2NoZW1lIDogbmV3IEhhc2hlZEFkZHJlc3NpbmdTY2hlbWUoKSk7XG4gICAgdGhpcy5uYW1lID0gdGhpcy5pZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb29rcyB1cCBhIHJlc291cmNlIGJ5IHBhdGguXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBSZXNvdXJjZSBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kXG4gICAqL1xuICBwdWJsaWMgZmluZFJlc291cmNlKHBhdGg6IHN0cmluZyk6IFJlc291cmNlIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCByID0gdGhpcy5maW5kQ2hpbGQocGF0aCk7XG4gICAgaWYgKCFyKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cblxuICAgIC8vIGZvdW5kIGFuIGVsZW1lbnQsIGNoZWNrIGlmIGl0J3MgYSByZXNvdXJjZSAoZHVjay10eXBlKVxuICAgIGlmICghKCdyZXNvdXJjZVR5cGUnIGluIHIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvdW5kIGEgc3RhY2sgZWxlbWVudCBmb3IgJHtwYXRofSBidXQgaXQgaXMgbm90IGEgcmVzb3VyY2U6ICR7ci50b1N0cmluZygpfWApO1xuICAgIH1cblxuICAgIHJldHVybiByIGFzIFJlc291cmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlIGZvciB0aGlzIHN0YWNrIGJ5IHRyYXZlcnNpbmdcbiAgICogdGhlIHRyZWUgYW5kIGludm9raW5nIHRvQ2xvdWRGb3JtYXRpb24oKSBvbiBhbGwgRW50aXR5IG9iamVjdHMuXG4gICAqL1xuICBwdWJsaWMgdG9DbG91ZEZvcm1hdGlvbigpIHtcbiAgICAvLyBiZWZvcmUgd2UgYmVnaW4gc3ludGhlc2lzLCB3ZSBzaGFsbCBsb2NrIHRoaXMgc3RhY2ssIHNvIGNoaWxkcmVuIGNhbm5vdCBiZSBhZGRlZFxuICAgIHRoaXMubG9jaygpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRlbXBsYXRlOiBhbnkgPSB7XG4gICAgICAgIERlc2NyaXB0aW9uOiB0aGlzLnRlbXBsYXRlT3B0aW9ucy5kZXNjcmlwdGlvbixcbiAgICAgICAgVHJhbnNmb3JtOiB0aGlzLnRlbXBsYXRlT3B0aW9ucy50cmFuc2Zvcm0sXG4gICAgICAgIEFXU1RlbXBsYXRlRm9ybWF0VmVyc2lvbjogdGhpcy50ZW1wbGF0ZU9wdGlvbnMudGVtcGxhdGVGb3JtYXRWZXJzaW9uLFxuICAgICAgICBNZXRhZGF0YTogdGhpcy50ZW1wbGF0ZU9wdGlvbnMubWV0YWRhdGFcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gc3RhY2tFbGVtZW50cyh0aGlzKTtcbiAgICAgIGNvbnN0IGZyYWdtZW50cyA9IGVsZW1lbnRzLm1hcChlID0+IGUudG9DbG91ZEZvcm1hdGlvbigpKTtcblxuICAgICAgLy8gbWVyZ2UgaW4gYWxsIENsb3VkRm9ybWF0aW9uIGZyYWdtZW50cyBjb2xsZWN0ZWQgZnJvbSB0aGUgdHJlZVxuICAgICAgZm9yIChjb25zdCBmcmFnbWVudCBvZiBmcmFnbWVudHMpIHtcbiAgICAgICAgbWVyZ2UodGVtcGxhdGUsIGZyYWdtZW50KTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVzb2x2ZSBhbGwgdG9rZW5zIGFuZCByZW1vdmUgYWxsIGVtcHRpZXNcbiAgICAgIGNvbnN0IHJldCA9IHJlc29sdmUodGVtcGxhdGUpIHx8IHsgfTtcblxuICAgICAgdGhpcy5sb2dpY2FsSWRzLmFzc2VydEFsbFJlbmFtZXNBcHBsaWVkKCk7XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIGFsbG93IG11dGF0aW9ucyBhZnRlciBzeW50aGVzaXMgaXMgZmluaXNoZWQuXG4gICAgICB0aGlzLnVubG9jaygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gd2h5IG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgd2h5IHJlZ2lvbiBpcyByZXF1aXJlZC5cbiAgICogQHJldHVybnMgVGhlIHJlZ2lvbiBpbiB3aGljaCB0aGlzIHN0YWNrIGlzIGRlcGxveWVkLiBUaHJvd3MgaWYgcmVnaW9uIGlzIG5vdCBkZWZpbmVkLlxuICAgKi9cbiAgcHVibGljIHJlcXVpcmVSZWdpb24od2h5Pzogc3RyaW5nKSB7XG4gICAgaWYgKCF0aGlzLmVudi5yZWdpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt3aHkgPyB3aHkgKyAnLiAnIDogJyd9U3RhY2sgcmVxdWlyZXMgcmVnaW9uIGluZm9ybWF0aW9uLiBJdCBjYW4gYmUgZWl0aGVyIHN1cHBsaWVkIHZpYSB0aGUgXCJlbnZcIiBwcm9wZXJ0eSwgYCArXG4gICAgICAgICAgYHZpYSB0aGUgXCIke2N4YXBpLkRFRkFVTFRfUkVHSU9OX0NPTlRFWFRfS0VZfVwiIGNvbnRleHQgcGFyYW1ldGVycyBvciB1c2luZyBcImF3cyBjb25maWd1cmVcImApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmVudi5yZWdpb247XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgQVdTIGFjY291bnQgSUQgb2YgdGhpcyBTdGFjayxcbiAgICogb3IgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB0aGUgYWNjb3VudCBJRCBpcyBub3Qgc2V0IGluIHRoZSBlbnZpcm9ubWVudC5cbiAgICpcbiAgICogQHBhcmFtIHdoeSBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHdoeSBpcyB0aGUgYWNjb3VudCBJRCByZXF1aXJlZFxuICAgKiBAcmV0dXJucyB0aGUgQVdTIGFjY291bnQgSUQgb2YgdGhpcyBTdGFja1xuICAgKi9cbiAgcHVibGljIHJlcXVpcmVBY2NvdW50SWQod2h5Pzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAoIXRoaXMuZW52LmFjY291bnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt3aHkgPyB3aHkgKyAnLiAnIDogJyd9U3RhY2sgcmVxdWlyZXMgYWNjb3VudCBpbmZvcm1hdGlvbi4gYCArXG4gICAgICAgICdJdCBjYW4gYmUgc3VwcGxpZWQgZWl0aGVyIHZpYSB0aGUgXCJlbnZcIiBwcm9wZXJ0eSB3aGVuIGNyZWF0aW5nIHRoZSBTdGFjaywgb3IgYnkgdXNpbmcgXCJhd3MgY29uZmlndXJlXCInKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5lbnYuYWNjb3VudDtcbiAgfVxuXG4gIHB1YmxpYyBwYXJlbnRBcHAoKTogQXBwIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICByZXR1cm4gcGFyZW50IGluc3RhbmNlb2YgQXBwXG4gICAgICA/IHBhcmVudFxuICAgICAgOiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogSW5kaWNhdGUgdGhhdCBhIGNvbnRleHQga2V5IHdhcyBleHBlY3RlZFxuICAgKlxuICAgKiBDb250YWlucyBpbnN0cnVjdGlvbnMgb24gaG93IHRoZSBrZXkgc2hvdWxkIGJlIHN1cHBsaWVkLlxuICAgKiBAcGFyYW0ga2V5IEtleSB0aGF0IHVuaXF1ZWx5IGlkZW50aWZpZXMgdGhpcyBtaXNzaW5nIGNvbnRleHQuXG4gICAqIEBwYXJhbSBkZXRhaWxzIFRoZSBzZXQgb2YgcGFyYW1ldGVycyBuZWVkZWQgdG8gb2J0YWluIHRoZSBjb250ZXh0IChzcGVjaWZpYyB0byBjb250ZXh0IHByb3ZpZGVyKS5cbiAgICovXG4gIHB1YmxpYyByZXBvcnRNaXNzaW5nQ29udGV4dChrZXk6IHN0cmluZywgZGV0YWlsczogY3hhcGkuTWlzc2luZ0NvbnRleHQpIHtcbiAgICB0aGlzLm1pc3NpbmdDb250ZXh0W2tleV0gPSBkZXRhaWxzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmFtZSBhIGdlbmVyYXRlZCBsb2dpY2FsIGlkZW50aXRpZXNcbiAgICovXG4gIHB1YmxpYyByZW5hbWVMb2dpY2FsKG9sZElkOiBzdHJpbmcsIG5ld0lkOiBzdHJpbmcpIHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc29sZVxuICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFsbCByZW5hbWVzIG11c3QgYmUgc2V0IHVwIGJlZm9yZSBhZGRpbmcgZWxlbWVudHMgdG8gdGhlIHN0YWNrXCIpO1xuICAgIH1cblxuICAgIHRoaXMubG9naWNhbElkcy5yZW5hbWVMb2dpY2FsKG9sZElkLCBuZXdJZCk7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgc3RhY2sgbmFtZVxuICAgKlxuICAgKiBDbG91ZEZvcm1hdGlvbiBzdGFjayBuYW1lcyBjYW4gaW5jbHVkZSBkYXNoZXMgaW4gYWRkaXRpb24gdG8gdGhlIHJlZ3VsYXIgaWRlbnRpZmllclxuICAgKiBjaGFyYWN0ZXIgY2xhc3NlcywgYW5kIHdlIGRvbid0IGFsbG93IG9uZSBvZiB0aGUgbWFnaWMgbWFya2Vycy5cbiAgICovXG4gIHByb3RlY3RlZCBfdmFsaWRhdGVJZChuYW1lOiBzdHJpbmcpIHtcbiAgICBpZiAobmFtZSAmJiAhU3RhY2suVkFMSURfU1RBQ0tfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0YWNrIG5hbWUgbXVzdCBtYXRjaCB0aGUgcmVndWxhciBleHByZXNzaW9uOiAke1N0YWNrLlZBTElEX1NUQUNLX05BTUVfUkVHRVgudG9TdHJpbmcoKX0sIGdvdCAnJHtuYW1lfSdgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXBwbGllZCBkZWZhdWx0cyB0byBlbnZpcm9ubWVudCBhdHRyaWJ1dGVzLlxuICAgKi9cbiAgcHJpdmF0ZSBwYXJzZUVudmlyb25tZW50KHByb3BzPzogU3RhY2tQcm9wcykge1xuICAgIC8vIHN0YXJ0IHdpdGggYGVudmAuXG4gICAgY29uc3QgZW52OiBFbnZpcm9ubWVudCA9IChwcm9wcyAmJiBwcm9wcy5lbnYpIHx8IHsgfTtcblxuICAgIC8vIGlmIGFjY291bnQgaXMgbm90IHNwZWNpZmllZCwgYXR0ZW1wdCB0byByZWFkIGZyb20gY29udGV4dC5cbiAgICBpZiAoIWVudi5hY2NvdW50KSB7XG4gICAgICBlbnYuYWNjb3VudCA9IHRoaXMuZ2V0Q29udGV4dChjeGFwaS5ERUZBVUxUX0FDQ09VTlRfQ09OVEVYVF9LRVkpO1xuICAgIH1cblxuICAgIC8vIGlmIHJlZ2lvbiBpcyBub3Qgc3BlY2lmaWVkLCBhdHRlbXB0IHRvIHJlYWQgZnJvbSBjb250ZXh0LlxuICAgIGlmICghZW52LnJlZ2lvbikge1xuICAgICAgZW52LnJlZ2lvbiA9IHRoaXMuZ2V0Q29udGV4dChjeGFwaS5ERUZBVUxUX1JFR0lPTl9DT05URVhUX0tFWSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVudjtcbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZSh0ZW1wbGF0ZTogYW55LCBwYXJ0OiBhbnkpIHtcbiAgZm9yIChjb25zdCBzZWN0aW9uIG9mIE9iamVjdC5rZXlzKHBhcnQpKSB7XG4gICAgY29uc3Qgc3JjID0gcGFydFtzZWN0aW9uXTtcblxuICAgIC8vIGNyZWF0ZSB0b3AtbGV2ZWwgc2VjdGlvbiBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgbGV0IGRlc3QgPSB0ZW1wbGF0ZVtzZWN0aW9uXTtcbiAgICBpZiAoIWRlc3QpIHtcbiAgICAgIHRlbXBsYXRlW3NlY3Rpb25dID0gZGVzdCA9IHNyYztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYWRkIGFsbCBlbnRpdGllcyBmcm9tIHNvdXJjZSBzZWN0aW9uIHRvIGRlc3RpbmF0aW9uIHNlY3Rpb25cbiAgICAgIGZvciAoY29uc3QgaWQgb2YgT2JqZWN0LmtleXMoc3JjKSkge1xuICAgICAgICBpZiAoaWQgaW4gZGVzdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2VjdGlvbiAnJHtzZWN0aW9ufScgYWxyZWFkeSBjb250YWlucyAnJHtpZH0nYCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVzdFtpZF0gPSBzcmNbaWRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBMT0dJQ0FMX0lEX01EID0gJ2F3czpjZGs6bG9naWNhbElkJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY29uc3RydWN0IHRoYXQgY2FuIGJlIFwiZGVwZW5kZWQgb25cIiB2aWEgYGFkZERlcGVuZGVuY3lgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElEZXBlbmRhYmxlIHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNldCBvZiBhbGwgc3RhY2sgZWxlbWVudHMgKHJlc291cmNlcywgcGFyYW1ldGVycywgY29uZGl0aW9ucylcbiAgICogdGhhdCBzaG91bGQgYmUgYWRkZWQgd2hlbiBhIHJlc291cmNlIFwiZGVwZW5kcyBvblwiIHRoaXMgY29uc3RydWN0LlxuICAgKi9cbiAgcmVhZG9ubHkgZGVwZW5kZW5jeUVsZW1lbnRzOiBJRGVwZW5kYWJsZVtdO1xufVxuXG4vKipcbiAqIEFuIGVsZW1lbnQgb2YgYSBDbG91ZEZvcm1hdGlvbiBzdGFjay5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFN0YWNrRWxlbWVudCBleHRlbmRzIENvbnN0cnVjdCBpbXBsZW1lbnRzIElEZXBlbmRhYmxlIHtcbiAgLyoqXG4gICAqIFJldHVybnMgYHRydWVgIGlmIGEgY29uc3RydWN0IGlzIGEgc3RhY2sgZWxlbWVudCAoaS5lLiBwYXJ0IG9mIHRoZVxuICAgKiBzeW50aGVzaXplZCBjbG91ZGZvcm1hdGlvbiB0ZW1wbGF0ZSkuXG4gICAqXG4gICAqIFVzZXMgZHVjay10eXBpbmcgaW5zdGVhZCBvZiBgaW5zdGFuY2VvZmAgdG8gYWxsb3cgc3RhY2sgZWxlbWVudHMgZnJvbSBkaWZmZXJlbnRcbiAgICogdmVyc2lvbnMgb2YgdGhpcyBsaWJyYXJ5IHRvIGJlIGluY2x1ZGVkIGluIHRoZSBzYW1lIHN0YWNrLlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgY29uc3RydWN0IGFzIGEgc3RhY2sgZWxlbWVudCBvciB1bmRlZmluZWQgaWYgaXQgaXMgbm90IGEgc3RhY2sgZWxlbWVudC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgX2FzU3RhY2tFbGVtZW50KGNvbnN0cnVjdDogQ29uc3RydWN0KTogU3RhY2tFbGVtZW50IHwgdW5kZWZpbmVkIHtcbiAgICBpZiAoJ2xvZ2ljYWxJZCcgaW4gY29uc3RydWN0ICYmICd0b0Nsb3VkRm9ybWF0aW9uJyBpbiBjb25zdHJ1Y3QpIHtcbiAgICAgIHJldHVybiBjb25zdHJ1Y3QgYXMgU3RhY2tFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbG9naWNhbCBJRCBmb3IgdGhpcyBDbG91ZEZvcm1hdGlvbiBzdGFjayBlbGVtZW50XG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgbG9naWNhbElkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBzdGFjayB0aGlzIENvbnN0cnVjdCBoYXMgYmVlbiBtYWRlIGEgcGFydCBvZlxuICAgKi9cbiAgcHJvdGVjdGVkIHN0YWNrOiBTdGFjaztcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBlbnRpdHkgYW5kIGJpbmRzIGl0IHRvIGEgdHJlZS5cbiAgICogTm90ZSB0aGF0IHRoZSByb290IG9mIHRoZSB0cmVlIG11c3QgYmUgYSBTdGFjayBvYmplY3QgKG5vdCBqdXN0IGFueSBSb290KS5cbiAgICpcbiAgICogQHBhcmFtIHBhcmVudCBUaGUgcGFyZW50IGNvbnN0cnVjdFxuICAgKiBAcGFyYW0gcHJvcHMgQ29uc3RydWN0IHByb3BlcnRpZXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcmVudDogQ29uc3RydWN0LCBuYW1lOiBzdHJpbmcpIHtcbiAgICBzdXBlcihwYXJlbnQsIG5hbWUpO1xuICAgIGNvbnN0IHMgPSBTdGFjay5maW5kKHRoaXMpO1xuICAgIGlmICghcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdHJlZSByb290IG11c3QgYmUgZGVyaXZlZCBmcm9tIFwiU3RhY2tcIicpO1xuICAgIH1cbiAgICB0aGlzLnN0YWNrID0gcztcblxuICAgIHRoaXMuYWRkTWV0YWRhdGEoTE9HSUNBTF9JRF9NRCwgbmV3IFRva2VuKCgpID0+IHRoaXMubG9naWNhbElkKSwgdGhpcy5jb25zdHJ1Y3Rvcik7XG5cbiAgICB0aGlzLmxvZ2ljYWxJZCA9IHRoaXMuc3RhY2subG9naWNhbElkcy5nZXRMb2dpY2FsSWQodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgdGhlIHN0YWNrIHRyYWNlIG9mIHRoZSBwb2ludCB3aGVyZSB0aGlzIFJlc291cmNlIHdhcyBjcmVhdGVkIGZyb20sIHNvdXJjZWRcbiAgICogICAgICBmcm9tIHRoZSArbWV0YWRhdGErIGVudHJ5IHR5cGVkICthd3M6Y2RrOmxvZ2ljYWxJZCssIGFuZCB3aXRoIHRoZSBib3R0b20tbW9zdFxuICAgKiAgICAgIG5vZGUgK2ludGVybmFsKyBlbnRyaWVzIGZpbHRlcmVkLlxuICAgKi9cbiAgcHVibGljIGdldCBjcmVhdGlvblN0YWNrVHJhY2UoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBmaWx0ZXJTdGFja1RyYWNlKHRoaXMubWV0YWRhdGEuZmluZChtZCA9PiBtZC50eXBlID09PSBMT0dJQ0FMX0lEX01EKSEudHJhY2UpO1xuXG4gICAgZnVuY3Rpb24gZmlsdGVyU3RhY2tUcmFjZShzdGFjazogc3RyaW5nW10pOiBzdHJpbmdbXSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBBcnJheS5vZiguLi5zdGFjayk7XG4gICAgICB3aGlsZSAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgc2hvdWxkRmlsdGVyKHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIHJlc3VsdC5wb3AoKTtcbiAgICAgIH1cbiAgICAgIC8vIEl0J3Mgd2VpcmQgaWYgd2UgZmlsdGVyZWQgZXZlcnl0aGluZywgc28gcmV0dXJuIHRoZSB3aG9sZSBzdGFjay4uLlxuICAgICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPT09IDAgPyBzdGFjayA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG91bGRGaWx0ZXIoc3RyOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiBzdHIubWF0Y2goL1teKF0rXFwoaW50ZXJuYWxcXC8uKi8pICE9PSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHBhdGggd2l0aCByZXNwZWN0IHRvIHRoZSBzdGFja1xuICAgKi9cbiAgcHVibGljIGdldCBzdGFja1BhdGgoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5hbmNlc3RvcnModGhpcy5zdGFjaykubWFwKGMgPT4gYy5pZCkuam9pbihQQVRIX1NFUCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGRlcGVuZGVuY3lFbGVtZW50cygpOiBJRGVwZW5kYWJsZVtdIHtcbiAgICByZXR1cm4gWyB0aGlzIF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgQ2xvdWRGb3JtYXRpb24gJ3NuaXBwZXQnIGZvciB0aGlzIGVudGl0eS4gVGhlIHNuaXBwZXQgd2lsbCBvbmx5IGJlIG1lcmdlZFxuICAgKiBhdCB0aGUgcm9vdCBsZXZlbCB0byBlbnN1cmUgdGhlcmUgYXJlIG5vIGlkZW50aXR5IGNvbmZsaWN0cy5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIGEgUmVzb3VyY2UgY2xhc3Mgd2lsbCByZXR1cm4gc29tZXRoaW5nIGxpa2U6XG4gICAqIHtcbiAgICogICBSZXNvdXJjZXM6IHtcbiAgICogICAgIFt0aGlzLmxvZ2ljYWxJZF06IHtcbiAgICogICAgICAgVHlwZTogdGhpcy5yZXNvdXJjZVR5cGUsXG4gICAqICAgICAgIFByb3BlcnRpZXM6IHRoaXMucHJvcHMsXG4gICAqICAgICAgIENvbmRpdGlvbjogdGhpcy5jb25kaXRpb25cbiAgICogICAgIH1cbiAgICogICB9XG4gICAqIH1cbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCB0b0Nsb3VkRm9ybWF0aW9uKCk6IG9iamVjdDtcbn1cblxuLyoqXG4gKiBDbG91ZEZvcm1hdGlvbiB0ZW1wbGF0ZSBvcHRpb25zIGZvciBhIHN0YWNrLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRlbXBsYXRlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBHZXRzIG9yIHNldHMgdGhlIGRlc2NyaXB0aW9uIG9mIHRoaXMgc3RhY2suXG4gICAqIElmIHByb3ZpZGVkLCBpdCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBDbG91ZEZvcm1hdGlvbiB0ZW1wbGF0ZSdzIFwiRGVzY3JpcHRpb25cIiBhdHRyaWJ1dGUuXG4gICAqL1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcblxuICAvKipcbiAgICogR2V0cyBvciBzZXRzIHRoZSBBV1NUZW1wbGF0ZUZvcm1hdFZlcnNpb24gZmllbGQgb2YgdGhlIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlLlxuICAgKi9cbiAgdGVtcGxhdGVGb3JtYXRWZXJzaW9uPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBHZXRzIG9yIHNldHMgdGhlIHRvcC1sZXZlbCB0ZW1wbGF0ZSB0cmFuc2Zvcm0gZm9yIHRoaXMgc3RhY2sgKGUuZy4gXCJBV1M6OlNlcnZlcmxlc3MtMjAxNi0xMC0zMVwiKS5cbiAgICovXG4gIHRyYW5zZm9ybT86IHN0cmluZztcblxuICAvKipcbiAgICogTWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBDbG91ZEZvcm1hdGlvbiB0ZW1wbGF0ZS5cbiAgICovXG4gICBtZXRhZGF0YT86IHsgW2tleTogc3RyaW5nXTogYW55IH07XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgcmVmZXJlbmNlYWJsZSBDbG91ZEZvcm1hdGlvbiBjb25zdHJ1Y3RzIHdoaWNoIGFyZSBub3QgUmVzb3VyY2VzXG4gKlxuICogVGhlc2UgY29uc3RydWN0cyBhcmUgdGhpbmdzIGxpa2UgQ29uZGl0aW9ucyBhbmQgUGFyYW1ldGVycywgY2FuIGJlXG4gKiByZWZlcmVuY2VkIGJ5IHRha2luZyB0aGUgYC5yZWZgIGF0dHJpYnV0ZS5cbiAqXG4gKiBSZXNvdXJjZSBjb25zdHJ1Y3RzIGRvIG5vdCBpbmhlcml0IGZyb20gUmVmZXJlbmNlYWJsZSBiZWNhdXNlIHRoZXkgaGF2ZSB0aGVpclxuICogb3duLCBtb3JlIHNwZWNpZmljIHR5cGVzIHJldHVybmVkIGZyb20gdGhlIC5yZWYgYXR0cmlidXRlLiBBbHNvLCBzb21lXG4gKiByZXNvdXJjZXMgYXJlbid0IHJlZmVyZW5jZWFibGUgYXQgYWxsIChzdWNoIGFzIEJ1Y2tldFBvbGljaWVzIG9yIEdhdGV3YXlBdHRhY2htZW50cykuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBSZWZlcmVuY2VhYmxlIGV4dGVuZHMgU3RhY2tFbGVtZW50IHtcbiAgLyoqXG4gICAqIFJldHVybnMgYSB0b2tlbiB0byBhIENsb3VkRm9ybWF0aW9uIHsgUmVmIH0gdGhhdCByZWZlcmVuY2VzIHRoaXMgZW50aXR5IGJhc2VkIG9uIGl0J3MgbG9naWNhbCBJRC5cbiAgICovXG4gIHB1YmxpYyBnZXQgcmVmKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIG5ldyBSZWYodGhpcykudG9TdHJpbmcoKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbGxlY3QgYWxsIFN0YWNrRWxlbWVudHMgZnJvbSBhIGNvbnN0cnVjdFxuICpcbiAqIEBwYXJhbSBub2RlIFJvb3Qgbm9kZSB0byBjb2xsZWN0IGFsbCBTdGFja0VsZW1lbnRzIGZyb21cbiAqIEBwYXJhbSBpbnRvIEFycmF5IHRvIGFwcGVuZCBTdGFja0VsZW1lbnRzIHRvXG4gKiBAcmV0dXJucyBUaGUgc2FtZSBhcnJheSBhcyBpcyBiZWluZyBjb2xsZWN0ZWQgaW50b1xuICovXG5mdW5jdGlvbiBzdGFja0VsZW1lbnRzKG5vZGU6IENvbnN0cnVjdCwgaW50bzogU3RhY2tFbGVtZW50W10gPSBbXSk6IFN0YWNrRWxlbWVudFtdIHtcbiAgY29uc3QgZWxlbWVudCA9IFN0YWNrRWxlbWVudC5fYXNTdGFja0VsZW1lbnQobm9kZSk7XG4gIGlmIChlbGVtZW50KSB7XG4gICAgaW50by5wdXNoKGVsZW1lbnQpO1xuICB9XG5cbiAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgc3RhY2tFbGVtZW50cyhjaGlsZCwgaW50byk7XG4gIH1cblxuICByZXR1cm4gaW50bztcbn1cblxuLyoqXG4gKiBBIGdlbmVyaWMsIHVudHlwZWQgcmVmZXJlbmNlIHRvIGEgU3RhY2sgRWxlbWVudFxuICovXG5leHBvcnQgY2xhc3MgUmVmIGV4dGVuZHMgQ2xvdWRGb3JtYXRpb25Ub2tlbiB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IFN0YWNrRWxlbWVudCkge1xuICAgIHN1cGVyKHsgUmVmOiBlbGVtZW50LmxvZ2ljYWxJZCB9LCBgJHtlbGVtZW50LmxvZ2ljYWxJZH0uUmVmYCk7XG4gIH1cbn1cbiJdfQ==
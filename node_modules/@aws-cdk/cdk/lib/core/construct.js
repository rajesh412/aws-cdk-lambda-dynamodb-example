"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cxapi = require("@aws-cdk/cx-api");
const uniqueid_1 = require("../util/uniqueid");
exports.PATH_SEP = '/';
/**
 * Represents the building block of the construct graph.
 * When a construct is created, it is always added as a child
 */
class Construct {
    /**
     * Creates a new construct node.
     *
     * @param parent The parent construct
     * @param id The local logical ID of the construct. Must be unique amongst
     * siblings. If the ID includes a path separator (`/`), then it will be
     * replaced by double dash `--`.
     */
    constructor(parent, id) {
        /**
         * List of children and their names
         */
        this._children = {};
        this.context = {};
        this._metadata = new Array();
        /**
         * If this is set to 'true'. addChild() calls for this construct and any child
         * will fail. This is used to prevent tree mutations during synthesis.
         */
        this._locked = false;
        id = id || ''; // if undefined, convert to empty string
        this.id = id;
        this.parent = parent;
        // We say that parent is required, but some root constructs bypass the type checks and
        // actually pass in 'undefined'.
        if (parent != null) {
            if (id === '') {
                throw new Error('Only root constructs may have an empty name');
            }
            // Has side effect so must be very last thing in constructor
            parent.addChild(this, this.id);
        }
        else {
            // This is a root construct.
            this.id = id;
        }
        // escape any path separators so they don't wreck havoc
        this.id = this._escapePathSeparator(this.id);
        // allow derived classes to validate the construct id
        this._validateId(this.id);
        const components = this.rootPath().map(c => c.id);
        this.path = components.join(exports.PATH_SEP);
        this.uniqueId = components.length > 0 ? uniqueid_1.makeUniqueId(components) : '';
    }
    /**
     * Returns a string representation of this construct.
     */
    toString() {
        const path = this.path;
        return this.typename + (path.length > 0 ? ` [${path}]` : '');
    }
    /**
     * Returns a string with a tree representation of this construct and it's children.
     */
    toTreeString(depth = 0) {
        let out = '';
        for (let i = 0; i < depth; ++i) {
            out += '  ';
        }
        const name = this.id || '';
        out += `${this.typename}${name.length > 0 ? ' [' + name + ']' : ''}\n`;
        for (const child of this.children) {
            out += child.toTreeString(depth + 1);
        }
        return out;
    }
    /**
     * Return a descendant by path, or undefined
     *
     * Note that if the original ID of the construct you are looking for contained
     * a '/', then it would have been replaced by '--'.
     *
     * @param name Relative name of a direct or indirect child
     * @returns a child by path or undefined if not found.
     */
    tryFindChild(path) {
        // tslint:disable-next-line:no-console
        if (path.startsWith(exports.PATH_SEP)) {
            throw new Error('Path must be relative');
        }
        const parts = path.split(exports.PATH_SEP);
        let curr = this;
        while (curr != null && parts.length > 0) {
            curr = curr._children[parts.shift()];
        }
        return curr;
    }
    /**
     * Return a descendant by path
     *
     * Throws an exception if the descendant is not found.
     *
     * Note that if the original ID of the construct you are looking for contained
     * a '/', then it would have been replaced by '--'.
     *
     * @param name Relative name of a direct or indirect child
     * @returns Child with the given path.
     */
    findChild(path) {
        const ret = this.tryFindChild(path);
        if (!ret) {
            throw new Error(`No child with path: '${path}'`);
        }
        return ret;
    }
    /**
     * All direct children of this construct.
     */
    get children() {
        return Object.keys(this._children).map(k => this._children[k]);
    }
    /**
     * This can be used to set contextual values.
     * Context must be set before any children are added, since children may consult context info during construction.
     * If the key already exists, it will be overridden.
     * @param key The context key
     * @param value The context value
     */
    setContext(key, value) {
        if (this.children.length > 0) {
            const names = this.children.map(c => c.id);
            throw new Error('Cannot set context after children have been added: ' + names.join(','));
        }
        this.context[key] = value;
    }
    /**
     * Retrieves a value from tree context.
     *
     * Context is usually initialized at the root, but can be overridden at any point in the tree.
     *
     * @param key The context key
     * @returns The context value or undefined
     */
    getContext(key) {
        const value = this.context[key];
        if (value !== undefined) {
            return value;
        }
        return this.parent && this.parent.getContext(key);
    }
    /**
     * Retrieve a value from tree-global context
     *
     * It is an error if the context object is not available.
     */
    requireContext(key) {
        const value = this.getContext(key);
        if (value == null) {
            throw new Error(`You must supply a context value named '${key}'`);
        }
        return value;
    }
    /**
     * An array of metadata objects associated with this construct.
     * This can be used, for example, to implement support for deprecation notices, source mapping, etc.
     */
    get metadata() {
        return this._metadata;
    }
    /**
     * Adds a metadata entry to this construct.
     * Entries are arbitrary values and will also include a stack trace to allow tracing back to
     * the code location for when the entry was added. It can be used, for example, to include source
     * mapping in CloudFormation templates to improve diagnostics.
     *
     * @param type a string denoting the type of metadata
     * @param data the value of the metadata (can be a Token). If null/undefined, metadata will not be added.
     * @param from a function under which to restrict the metadata entry's stack trace (defaults to this.addMetadata)
     */
    addMetadata(type, data, from) {
        if (data == null) {
            return this;
        }
        const trace = createStackTrace(from || this.addMetadata);
        this._metadata.push({ type, data, trace });
        return this;
    }
    /**
     * Adds a { "aws:cdk:info": <message> } metadata entry to this construct.
     * The toolkit will display the info message when apps are synthesized.
     * @param message The info message.
     */
    addInfo(message) {
        return this.addMetadata(cxapi.INFO_METADATA_KEY, message);
    }
    /**
     * Adds a { warning: <message> } metadata entry to this construct.
     * The toolkit will display the warning when an app is synthesized, or fail
     * if run in --strict mode.
     * @param message The warning message.
     */
    addWarning(message) {
        return this.addMetadata(cxapi.WARNING_METADATA_KEY, message);
    }
    /**
     * Adds an { error: <message> } metadata entry to this construct.
     * The toolkit will fail synthesis when errors are reported.
     * @param message The error message.
     */
    addError(message) {
        return this.addMetadata(cxapi.ERROR_METADATA_KEY, message);
    }
    /**
     * This method can be implemented by derived constructs in order to perform
     * validation logic. It is called on all constructs before synthesis.
     *
     * @returns An array of validation error messages, or an empty array if there the construct is valid.
     */
    validate() {
        return [];
    }
    /**
     * Invokes 'validate' on all child constructs and then on this construct (depth-first).
     * @returns A list of validation errors. If the list is empty, all constructs are valid.
     */
    validateTree() {
        let errors = new Array();
        for (const child of this.children) {
            errors = errors.concat(child.validateTree());
        }
        const localErrors = this.validate();
        return errors.concat(localErrors.map(msg => new ValidationError(this, msg)));
    }
    /**
     * Return the ancestors (including self) of this Construct up until and excluding the indicated component
     *
     * @param to The construct to return the path components relative to, or
     * the entire list of ancestors (including root) if omitted.
     */
    ancestors(upTo) {
        const ret = new Array();
        let curr = this;
        while (curr && curr !== upTo) {
            ret.unshift(curr);
            curr = curr.parent;
        }
        return ret;
    }
    /**
     * Validate that the id of the construct legal.
     * Construct IDs can be any characters besides the path separator.
     */
    _validateId(_id) {
        // can be used by derived classes to customize ID validation.
    }
    /**
     * Throws if the `props` bag doesn't include the property `name`.
     * In the future we can add some type-checking here, maybe even auto-generate during compilation.
     * @param props The props bag.
     * @param name The name of the required property.
     *
     * @deprecated use ``requireProperty`` from ``@aws-cdk/runtime`` instead.
     */
    required(props, name) {
        if (!(name in props)) {
            throw new Error(`Construct of type ${this.typename} is missing required property: ${name}`);
        }
        const value = props[name];
        return value;
    }
    /**
     * @returns The type name of this node.
     */
    get typename() {
        const ctor = this.constructor;
        return ctor.name || 'Construct';
    }
    /**
     * Adds a child construct to this node.
     *
     * @param child The child construct
     * @param name The type name of the child construct.
     * @returns The resolved path part name of the child
     */
    addChild(child, childName) {
        if (this.locked) {
            // special error if root is locked
            if (!this.path) {
                throw new Error('Cannot add children during synthesis');
            }
            throw new Error(`Cannot add children to "${this.path}" during synthesis`);
        }
        if (childName in this._children) {
            throw new Error(`There is already a Construct with name '${childName}' in ${this.toString()}`);
        }
        this._children[childName] = child;
    }
    /**
     * Locks this construct from allowing more children to be added. After this
     * call, no more children can be added to this construct or to any children.
     */
    lock() {
        this._locked = true;
    }
    /**
     * Unlocks this costruct and allows mutations (adding children).
     */
    unlock() {
        this._locked = false;
    }
    /**
     * Return the path of components up to but excluding the root
     */
    rootPath() {
        const ancestors = this.ancestors();
        ancestors.shift();
        return ancestors;
    }
    /**
     * Returns true if this construct or any of it's parent constructs are
     * locked.
     */
    get locked() {
        if (this._locked) {
            return true;
        }
        if (this.parent && this.parent.locked) {
            return true;
        }
        return false;
    }
    /**
     * If the construct ID contains a path separator, it is replaced by double dash (`--`).
     */
    _escapePathSeparator(id) {
        if (!id) {
            return id;
        }
        return id.split(exports.PATH_SEP).join('--');
    }
}
exports.Construct = Construct;
/**
 * Represents the root of a construct tree.
 * No parent and no name.
 */
class Root extends Construct {
    constructor() {
        // Bypass type checks
        super(undefined, '');
    }
}
exports.Root = Root;
class ValidationError {
    constructor(source, message) {
        this.source = source;
        this.message = message;
    }
}
exports.ValidationError = ValidationError;
// tslint:disable-next-line:ban-types
function createStackTrace(below) {
    const object = { stack: '' };
    const previousLimit = Error.stackTraceLimit;
    try {
        Error.stackTraceLimit = Number.MAX_SAFE_INTEGER;
        Error.captureStackTrace(object, below);
    }
    finally {
        Error.stackTraceLimit = previousLimit;
    }
    if (!object.stack) {
        return [];
    }
    return object.stack.split('\n').slice(1).map(s => s.replace(/^\s*at\s+/, ''));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uc3RydWN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29uc3RydWN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEseUNBQTBDO0FBQzFDLCtDQUFnRDtBQUNuQyxRQUFBLFFBQVEsR0FBRyxHQUFHLENBQUM7QUFFNUI7OztHQUdHO0FBQ0gsTUFBYSxTQUFTO0lBc0NwQjs7Ozs7OztPQU9HO0lBQ0gsWUFBWSxNQUFpQixFQUFFLEVBQVU7UUFyQnpDOztXQUVHO1FBQ2MsY0FBUyxHQUFrQyxFQUFHLENBQUM7UUFDL0MsWUFBTyxHQUEyQixFQUFHLENBQUM7UUFDdEMsY0FBUyxHQUFHLElBQUksS0FBSyxFQUFpQixDQUFDO1FBRXhEOzs7V0FHRztRQUNLLFlBQU8sR0FBRyxLQUFLLENBQUM7UUFXdEIsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyx3Q0FBd0M7UUFFdkQsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUM7UUFDYixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUVyQixzRkFBc0Y7UUFDdEYsZ0NBQWdDO1FBQ2hDLElBQUksTUFBTSxJQUFJLElBQUksRUFBRTtZQUNsQixJQUFJLEVBQUUsS0FBSyxFQUFFLEVBQUU7Z0JBQ2IsTUFBTSxJQUFJLEtBQUssQ0FBQyw2Q0FBNkMsQ0FBQyxDQUFDO2FBQ2hFO1lBRUQsNERBQTREO1lBQzVELE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUNoQzthQUFNO1lBQ0wsNEJBQTRCO1lBQzVCLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDO1NBQ2Q7UUFFRCx1REFBdUQ7UUFDdkQsSUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRTdDLHFEQUFxRDtRQUNyRCxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxF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Q0FBQztDQUNGO0FBOVlELDhCQThZQztBQUVEOzs7R0FHRztBQUNILE1BQWEsSUFBSyxTQUFRLFNBQVM7SUFDakM7UUFDRSxxQkFBcUI7UUFDckIsS0FBSyxDQUFDLFNBQWdCLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDOUIsQ0FBQztDQUNGO0FBTEQsb0JBS0M7QUFzQkQsTUFBYSxlQUFlO0lBQzFCLFlBQTRCLE1BQWlCLEVBQWtCLE9BQWU7UUFBbEQsV0FBTSxHQUFOLE1BQU0sQ0FBVztRQUFrQixZQUFPLEdBQVAsT0FBTyxDQUFRO0lBRTlFLENBQUM7Q0FDRjtBQUpELDBDQUlDO0FBRUQscUNBQXFDO0FBQ3JDLFNBQVMsZ0JBQWdCLENBQUMsS0FBZTtJQUN2QyxNQUFNLE1BQU0sR0FBRyxFQUFFLEtBQUssRUFBRSxFQUFFLEVBQUUsQ0FBQztJQUM3QixNQUFNLGFBQWEsR0FBRyxLQUFLLENBQUMsZUFBZSxDQUFDO0lBQzVDLElBQUk7UUFDRixLQUFLLENBQUMsZUFBZSxHQUFHLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQztRQUNoRCxLQUFLLENBQUMsaUJBQWlCLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO0tBQ3hDO1lBQVM7UUFDUixLQUFLLENBQUMsZUFBZSxHQUFHLGFBQWEsQ0FBQztLQUN2QztJQUNELElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFO1FBQ2pCLE9BQU8sRUFBRSxDQUFDO0tBQ1g7SUFDRCxPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ2hGLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3hhcGkgPSByZXF1aXJlKCdAYXdzLWNkay9jeC1hcGknKTtcbmltcG9ydCB7IG1ha2VVbmlxdWVJZCB9IGZyb20gJy4uL3V0aWwvdW5pcXVlaWQnO1xuZXhwb3J0IGNvbnN0IFBBVEhfU0VQID0gJy8nO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGJ1aWxkaW5nIGJsb2NrIG9mIHRoZSBjb25zdHJ1Y3QgZ3JhcGguXG4gKiBXaGVuIGEgY29uc3RydWN0IGlzIGNyZWF0ZWQsIGl0IGlzIGFsd2F5cyBhZGRlZCBhcyBhIGNoaWxkXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25zdHJ1Y3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGFyZW50IG9mIHRoaXMgbm9kZSBvciB1bmRlZmluZWQgaWYgdGhpcyBpcyBhIHJvb3Qgbm9kZS5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBwYXJlbnQ/OiBDb25zdHJ1Y3Q7XG5cbiAgLyoqXG4gICAqIFRoZSBsb2NhbCBpZCBvZiB0aGUgY29uc3RydWN0LlxuICAgKiBUaGlzIGlkIGlzIHVuaXF1ZSBhbW9uZ3N0IGl0cyBzaWJsaW5ncy5cbiAgICogVG8gb2J0YWluIGEgdHJlZS1nbG9iYWwgdW5pcXVlIGlkIGZvciB0aGlzIGNvbnN0cnVjdCwgdXNlIGB1bmlxdWVJZGAuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGZ1bGwgcGF0aCBvZiB0aGlzIGNvbnN0cnVjdCBpbiB0aGUgdHJlZS5cbiAgICogQ29tcG9uZW50cyBhcmUgc2VwYXJhdGVkIGJ5ICcvJy5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBwYXRoOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgdHJlZS1nbG9iYWwgdW5pcXVlIGFscGhhbnVtZXJpYyBpZGVudGlmaWVyIGZvciB0aGlzIGNvbnN0cnVjdC5cbiAgICogSW5jbHVkZXMgYWxsIGNvbXBvbmVudHMgb2YgdGhlIHRyZWUuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgdW5pcXVlSWQ6IHN0cmluZztcblxuICAvKipcbiAgICogTGlzdCBvZiBjaGlsZHJlbiBhbmQgdGhlaXIgbmFtZXNcbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgX2NoaWxkcmVuOiB7IFtuYW1lOiBzdHJpbmddOiBDb25zdHJ1Y3QgfSA9IHsgfTtcbiAgcHJpdmF0ZSByZWFkb25seSBjb250ZXh0OiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0geyB9O1xuICBwcml2YXRlIHJlYWRvbmx5IF9tZXRhZGF0YSA9IG5ldyBBcnJheTxNZXRhZGF0YUVudHJ5PigpO1xuXG4gIC8qKlxuICAgKiBJZiB0aGlzIGlzIHNldCB0byAndHJ1ZScuIGFkZENoaWxkKCkgY2FsbHMgZm9yIHRoaXMgY29uc3RydWN0IGFuZCBhbnkgY2hpbGRcbiAgICogd2lsbCBmYWlsLiBUaGlzIGlzIHVzZWQgdG8gcHJldmVudCB0cmVlIG11dGF0aW9ucyBkdXJpbmcgc3ludGhlc2lzLlxuICAgKi9cbiAgcHJpdmF0ZSBfbG9ja2VkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY29uc3RydWN0IG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJlbnQgVGhlIHBhcmVudCBjb25zdHJ1Y3RcbiAgICogQHBhcmFtIGlkIFRoZSBsb2NhbCBsb2dpY2FsIElEIG9mIHRoZSBjb25zdHJ1Y3QuIE11c3QgYmUgdW5pcXVlIGFtb25nc3RcbiAgICogc2libGluZ3MuIElmIHRoZSBJRCBpbmNsdWRlcyBhIHBhdGggc2VwYXJhdG9yIChgL2ApLCB0aGVuIGl0IHdpbGwgYmVcbiAgICogcmVwbGFjZWQgYnkgZG91YmxlIGRhc2ggYC0tYC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcmVudDogQ29uc3RydWN0LCBpZDogc3RyaW5nKSB7XG4gICAgaWQgPSBpZCB8fCAnJzsgLy8gaWYgdW5kZWZpbmVkLCBjb252ZXJ0IHRvIGVtcHR5IHN0cmluZ1xuXG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuXG4gICAgLy8gV2Ugc2F5IHRoYXQgcGFyZW50IGlzIHJlcXVpcmVkLCBidXQgc29tZSByb290IGNvbnN0cnVjdHMgYnlwYXNzIHRoZSB0eXBlIGNoZWNrcyBhbmRcbiAgICAvLyBhY3R1YWxseSBwYXNzIGluICd1bmRlZmluZWQnLlxuICAgIGlmIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgaWYgKGlkID09PSAnJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgcm9vdCBjb25zdHJ1Y3RzIG1heSBoYXZlIGFuIGVtcHR5IG5hbWUnKTtcbiAgICAgIH1cblxuICAgICAgLy8gSGFzIHNpZGUgZWZmZWN0IHNvIG11c3QgYmUgdmVyeSBsYXN0IHRoaW5nIGluIGNvbnN0cnVjdG9yXG4gICAgICBwYXJlbnQuYWRkQ2hpbGQodGhpcywgdGhpcy5pZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSByb290IGNvbnN0cnVjdC5cbiAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICB9XG5cbiAgICAvLyBlc2NhcGUgYW55IHBhdGggc2VwYXJhdG9ycyBzbyB0aGV5IGRvbid0IHdyZWNrIGhhdm9jXG4gICAgdGhpcy5pZCA9IHRoaXMuX2VzY2FwZVBhdGhTZXBhcmF0b3IodGhpcy5pZCk7XG5cbiAgICAvLyBhbGxvdyBkZXJpdmVkIGNsYXNzZXMgdG8gdmFsaWRhdGUgdGhlIGNvbnN0cnVjdCBpZFxuICAgIHRoaXMuX3ZhbGlkYXRlSWQodGhpcy5pZCk7XG5cbiAgICBjb25zdCBjb21wb25lbnRzID0gdGhpcy5yb290UGF0aCgpLm1hcChjID0+IGMuaWQpO1xuICAgIHRoaXMucGF0aCA9IGNvbXBvbmVudHMuam9pbihQQVRIX1NFUCk7XG4gICAgdGhpcy51bmlxdWVJZCA9IGNvbXBvbmVudHMubGVuZ3RoID4gMCA/IG1ha2VVbmlxdWVJZChjb21wb25lbnRzKSA6ICcnO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb25zdHJ1Y3QuXG4gICAqL1xuICBwdWJsaWMgdG9TdHJpbmcoKSB7XG4gICAgY29uc3QgcGF0aCA9IHRoaXMucGF0aDtcbiAgICByZXR1cm4gdGhpcy50eXBlbmFtZSArIChwYXRoLmxlbmd0aCA+IDAgPyBgIFske3BhdGh9XWAgOiAnJyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyB3aXRoIGEgdHJlZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbnN0cnVjdCBhbmQgaXQncyBjaGlsZHJlbi5cbiAgICovXG4gIHB1YmxpYyB0b1RyZWVTdHJpbmcoZGVwdGggPSAwKSB7XG4gICAgbGV0IG91dCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwdGg7ICsraSkge1xuICAgICAgb3V0ICs9ICcgICc7XG4gICAgfVxuICAgIGNvbnN0IG5hbWUgPSB0aGlzLmlkIHx8ICcnO1xuICAgIG91dCArPSBgJHt0aGlzLnR5cGVuYW1lfSR7bmFtZS5sZW5ndGggPiAwID8gJyBbJyArIG5hbWUgKyAnXScgOiAnJ31cXG5gO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgb3V0ICs9IGNoaWxkLnRvVHJlZVN0cmluZyhkZXB0aCArIDEpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGRlc2NlbmRhbnQgYnkgcGF0aCwgb3IgdW5kZWZpbmVkXG4gICAqXG4gICAqIE5vdGUgdGhhdCBpZiB0aGUgb3JpZ2luYWwgSUQgb2YgdGhlIGNvbnN0cnVjdCB5b3UgYXJlIGxvb2tpbmcgZm9yIGNvbnRhaW5lZFxuICAgKiBhICcvJywgdGhlbiBpdCB3b3VsZCBoYXZlIGJlZW4gcmVwbGFjZWQgYnkgJy0tJy5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgUmVsYXRpdmUgbmFtZSBvZiBhIGRpcmVjdCBvciBpbmRpcmVjdCBjaGlsZFxuICAgKiBAcmV0dXJucyBhIGNoaWxkIGJ5IHBhdGggb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZC5cbiAgICovXG4gIHB1YmxpYyB0cnlGaW5kQ2hpbGQocGF0aDogc3RyaW5nKTogQ29uc3RydWN0IHwgdW5kZWZpbmVkIHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc29sZVxuICAgIGlmIChwYXRoLnN0YXJ0c1dpdGgoUEFUSF9TRVApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdGggbXVzdCBiZSByZWxhdGl2ZScpO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0cyA9IHBhdGguc3BsaXQoUEFUSF9TRVApO1xuXG4gICAgbGV0IGN1cnI6IENvbnN0cnVjdHx1bmRlZmluZWQgPSB0aGlzO1xuICAgIHdoaWxlIChjdXJyICE9IG51bGwgJiYgcGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgY3VyciA9IGN1cnIuX2NoaWxkcmVuW3BhcnRzLnNoaWZ0KCkhXTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnI7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgZGVzY2VuZGFudCBieSBwYXRoXG4gICAqXG4gICAqIFRocm93cyBhbiBleGNlcHRpb24gaWYgdGhlIGRlc2NlbmRhbnQgaXMgbm90IGZvdW5kLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgaWYgdGhlIG9yaWdpbmFsIElEIG9mIHRoZSBjb25zdHJ1Y3QgeW91IGFyZSBsb29raW5nIGZvciBjb250YWluZWRcbiAgICogYSAnLycsIHRoZW4gaXQgd291bGQgaGF2ZSBiZWVuIHJlcGxhY2VkIGJ5ICctLScuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIFJlbGF0aXZlIG5hbWUgb2YgYSBkaXJlY3Qgb3IgaW5kaXJlY3QgY2hpbGRcbiAgICogQHJldHVybnMgQ2hpbGQgd2l0aCB0aGUgZ2l2ZW4gcGF0aC5cbiAgICovXG4gIHB1YmxpYyBmaW5kQ2hpbGQocGF0aDogc3RyaW5nKTogQ29uc3RydWN0IHtcbiAgICBjb25zdCByZXQgPSB0aGlzLnRyeUZpbmRDaGlsZChwYXRoKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBjaGlsZCB3aXRoIHBhdGg6ICcke3BhdGh9J2ApO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbCBkaXJlY3QgY2hpbGRyZW4gb2YgdGhpcyBjb25zdHJ1Y3QuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGNoaWxkcmVuKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9jaGlsZHJlbikubWFwKGsgPT4gdGhpcy5fY2hpbGRyZW5ba10pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gc2V0IGNvbnRleHR1YWwgdmFsdWVzLlxuICAgKiBDb250ZXh0IG11c3QgYmUgc2V0IGJlZm9yZSBhbnkgY2hpbGRyZW4gYXJlIGFkZGVkLCBzaW5jZSBjaGlsZHJlbiBtYXkgY29uc3VsdCBjb250ZXh0IGluZm8gZHVyaW5nIGNvbnN0cnVjdGlvbi5cbiAgICogSWYgdGhlIGtleSBhbHJlYWR5IGV4aXN0cywgaXQgd2lsbCBiZSBvdmVycmlkZGVuLlxuICAgKiBAcGFyYW0ga2V5IFRoZSBjb250ZXh0IGtleVxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIGNvbnRleHQgdmFsdWVcbiAgICovXG4gIHB1YmxpYyBzZXRDb250ZXh0KGtleTogc3RyaW5nLCB2YWx1ZTogYW55KSB7XG4gICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbmFtZXMgPSB0aGlzLmNoaWxkcmVuLm1hcChjID0+IGMuaWQpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2V0IGNvbnRleHQgYWZ0ZXIgY2hpbGRyZW4gaGF2ZSBiZWVuIGFkZGVkOiAnICsgbmFtZXMuam9pbignLCcpKTtcbiAgICB9XG4gICAgdGhpcy5jb250ZXh0W2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSB2YWx1ZSBmcm9tIHRyZWUgY29udGV4dC5cbiAgICpcbiAgICogQ29udGV4dCBpcyB1c3VhbGx5IGluaXRpYWxpemVkIGF0IHRoZSByb290LCBidXQgY2FuIGJlIG92ZXJyaWRkZW4gYXQgYW55IHBvaW50IGluIHRoZSB0cmVlLlxuICAgKlxuICAgKiBAcGFyYW0ga2V5IFRoZSBjb250ZXh0IGtleVxuICAgKiBAcmV0dXJucyBUaGUgY29udGV4dCB2YWx1ZSBvciB1bmRlZmluZWRcbiAgICovXG4gIHB1YmxpYyBnZXRDb250ZXh0KGtleTogc3RyaW5nKTogYW55IHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuY29udGV4dFtrZXldO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7IHJldHVybiB2YWx1ZTsgfVxuXG4gICAgcmV0dXJuIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmdldENvbnRleHQoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBhIHZhbHVlIGZyb20gdHJlZS1nbG9iYWwgY29udGV4dFxuICAgKlxuICAgKiBJdCBpcyBhbiBlcnJvciBpZiB0aGUgY29udGV4dCBvYmplY3QgaXMgbm90IGF2YWlsYWJsZS5cbiAgICovXG4gIHB1YmxpYyByZXF1aXJlQ29udGV4dChrZXk6IHN0cmluZyk6IGFueSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldENvbnRleHQoa2V5KTtcblxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBtdXN0IHN1cHBseSBhIGNvbnRleHQgdmFsdWUgbmFtZWQgJyR7a2V5fSdgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQW4gYXJyYXkgb2YgbWV0YWRhdGEgb2JqZWN0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb25zdHJ1Y3QuXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQsIGZvciBleGFtcGxlLCB0byBpbXBsZW1lbnQgc3VwcG9ydCBmb3IgZGVwcmVjYXRpb24gbm90aWNlcywgc291cmNlIG1hcHBpbmcsIGV0Yy5cbiAgICovXG4gIHB1YmxpYyBnZXQgbWV0YWRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21ldGFkYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBtZXRhZGF0YSBlbnRyeSB0byB0aGlzIGNvbnN0cnVjdC5cbiAgICogRW50cmllcyBhcmUgYXJiaXRyYXJ5IHZhbHVlcyBhbmQgd2lsbCBhbHNvIGluY2x1ZGUgYSBzdGFjayB0cmFjZSB0byBhbGxvdyB0cmFjaW5nIGJhY2sgdG9cbiAgICogdGhlIGNvZGUgbG9jYXRpb24gZm9yIHdoZW4gdGhlIGVudHJ5IHdhcyBhZGRlZC4gSXQgY2FuIGJlIHVzZWQsIGZvciBleGFtcGxlLCB0byBpbmNsdWRlIHNvdXJjZVxuICAgKiBtYXBwaW5nIGluIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlcyB0byBpbXByb3ZlIGRpYWdub3N0aWNzLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSBhIHN0cmluZyBkZW5vdGluZyB0aGUgdHlwZSBvZiBtZXRhZGF0YVxuICAgKiBAcGFyYW0gZGF0YSB0aGUgdmFsdWUgb2YgdGhlIG1ldGFkYXRhIChjYW4gYmUgYSBUb2tlbikuIElmIG51bGwvdW5kZWZpbmVkLCBtZXRhZGF0YSB3aWxsIG5vdCBiZSBhZGRlZC5cbiAgICogQHBhcmFtIGZyb20gYSBmdW5jdGlvbiB1bmRlciB3aGljaCB0byByZXN0cmljdCB0aGUgbWV0YWRhdGEgZW50cnkncyBzdGFjayB0cmFjZSAoZGVmYXVsdHMgdG8gdGhpcy5hZGRNZXRhZGF0YSlcbiAgICovXG4gIHB1YmxpYyBhZGRNZXRhZGF0YSh0eXBlOiBzdHJpbmcsIGRhdGE6IGFueSwgZnJvbT86IGFueSk6IENvbnN0cnVjdCB7XG4gICAgaWYgKGRhdGEgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbnN0IHRyYWNlID0gY3JlYXRlU3RhY2tUcmFjZShmcm9tIHx8IHRoaXMuYWRkTWV0YWRhdGEpO1xuICAgIHRoaXMuX21ldGFkYXRhLnB1c2goeyB0eXBlLCBkYXRhLCB0cmFjZSB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgeyBcImF3czpjZGs6aW5mb1wiOiA8bWVzc2FnZT4gfSBtZXRhZGF0YSBlbnRyeSB0byB0aGlzIGNvbnN0cnVjdC5cbiAgICogVGhlIHRvb2xraXQgd2lsbCBkaXNwbGF5IHRoZSBpbmZvIG1lc3NhZ2Ugd2hlbiBhcHBzIGFyZSBzeW50aGVzaXplZC5cbiAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIGluZm8gbWVzc2FnZS5cbiAgICovXG4gIHB1YmxpYyBhZGRJbmZvKG1lc3NhZ2U6IHN0cmluZyk6IENvbnN0cnVjdCB7XG4gICAgcmV0dXJuIHRoaXMuYWRkTWV0YWRhdGEoY3hhcGkuSU5GT19NRVRBREFUQV9LRVksIG1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSB7IHdhcm5pbmc6IDxtZXNzYWdlPiB9IG1ldGFkYXRhIGVudHJ5IHRvIHRoaXMgY29uc3RydWN0LlxuICAgKiBUaGUgdG9vbGtpdCB3aWxsIGRpc3BsYXkgdGhlIHdhcm5pbmcgd2hlbiBhbiBhcHAgaXMgc3ludGhlc2l6ZWQsIG9yIGZhaWxcbiAgICogaWYgcnVuIGluIC0tc3RyaWN0IG1vZGUuXG4gICAqIEBwYXJhbSBtZXNzYWdlIFRoZSB3YXJuaW5nIG1lc3NhZ2UuXG4gICAqL1xuICBwdWJsaWMgYWRkV2FybmluZyhtZXNzYWdlOiBzdHJpbmcpOiBDb25zdHJ1Y3Qge1xuICAgIHJldHVybiB0aGlzLmFkZE1ldGFkYXRhKGN4YXBpLldBUk5JTkdfTUVUQURBVEFfS0VZLCBtZXNzYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGFuIHsgZXJyb3I6IDxtZXNzYWdlPiB9IG1ldGFkYXRhIGVudHJ5IHRvIHRoaXMgY29uc3RydWN0LlxuICAgKiBUaGUgdG9vbGtpdCB3aWxsIGZhaWwgc3ludGhlc2lzIHdoZW4gZXJyb3JzIGFyZSByZXBvcnRlZC5cbiAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gICAqL1xuICBwdWJsaWMgYWRkRXJyb3IobWVzc2FnZTogc3RyaW5nKTogQ29uc3RydWN0IHtcbiAgICByZXR1cm4gdGhpcy5hZGRNZXRhZGF0YShjeGFwaS5FUlJPUl9NRVRBREFUQV9LRVksIG1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGNhbiBiZSBpbXBsZW1lbnRlZCBieSBkZXJpdmVkIGNvbnN0cnVjdHMgaW4gb3JkZXIgdG8gcGVyZm9ybVxuICAgKiB2YWxpZGF0aW9uIGxvZ2ljLiBJdCBpcyBjYWxsZWQgb24gYWxsIGNvbnN0cnVjdHMgYmVmb3JlIHN5bnRoZXNpcy5cbiAgICpcbiAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgdmFsaWRhdGlvbiBlcnJvciBtZXNzYWdlcywgb3IgYW4gZW1wdHkgYXJyYXkgaWYgdGhlcmUgdGhlIGNvbnN0cnVjdCBpcyB2YWxpZC5cbiAgICovXG4gIHB1YmxpYyB2YWxpZGF0ZSgpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZXMgJ3ZhbGlkYXRlJyBvbiBhbGwgY2hpbGQgY29uc3RydWN0cyBhbmQgdGhlbiBvbiB0aGlzIGNvbnN0cnVjdCAoZGVwdGgtZmlyc3QpLlxuICAgKiBAcmV0dXJucyBBIGxpc3Qgb2YgdmFsaWRhdGlvbiBlcnJvcnMuIElmIHRoZSBsaXN0IGlzIGVtcHR5LCBhbGwgY29uc3RydWN0cyBhcmUgdmFsaWQuXG4gICAqL1xuICBwdWJsaWMgdmFsaWRhdGVUcmVlKCk6IFZhbGlkYXRpb25FcnJvcltdIHtcbiAgICBsZXQgZXJyb3JzID0gbmV3IEFycmF5PFZhbGlkYXRpb25FcnJvcj4oKTtcblxuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChjaGlsZC52YWxpZGF0ZVRyZWUoKSk7XG4gICAgfVxuXG4gICAgY29uc3QgbG9jYWxFcnJvcnMgPSB0aGlzLnZhbGlkYXRlKCk7XG4gICAgcmV0dXJuIGVycm9ycy5jb25jYXQobG9jYWxFcnJvcnMubWFwKG1zZyA9PiBuZXcgVmFsaWRhdGlvbkVycm9yKHRoaXMsIG1zZykpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGFuY2VzdG9ycyAoaW5jbHVkaW5nIHNlbGYpIG9mIHRoaXMgQ29uc3RydWN0IHVwIHVudGlsIGFuZCBleGNsdWRpbmcgdGhlIGluZGljYXRlZCBjb21wb25lbnRcbiAgICpcbiAgICogQHBhcmFtIHRvIFRoZSBjb25zdHJ1Y3QgdG8gcmV0dXJuIHRoZSBwYXRoIGNvbXBvbmVudHMgcmVsYXRpdmUgdG8sIG9yXG4gICAqIHRoZSBlbnRpcmUgbGlzdCBvZiBhbmNlc3RvcnMgKGluY2x1ZGluZyByb290KSBpZiBvbWl0dGVkLlxuICAgKi9cbiAgcHVibGljIGFuY2VzdG9ycyh1cFRvPzogQ29uc3RydWN0KTogQ29uc3RydWN0W10ge1xuICAgIGNvbnN0IHJldCA9IG5ldyBBcnJheTxDb25zdHJ1Y3Q+KCk7XG5cbiAgICBsZXQgY3VycjogQ29uc3RydWN0IHwgdW5kZWZpbmVkID0gdGhpcztcbiAgICB3aGlsZSAoY3VyciAmJiBjdXJyICE9PSB1cFRvKSB7XG4gICAgICByZXQudW5zaGlmdChjdXJyKTtcbiAgICAgIGN1cnIgPSBjdXJyLnBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIHRoYXQgdGhlIGlkIG9mIHRoZSBjb25zdHJ1Y3QgbGVnYWwuXG4gICAqIENvbnN0cnVjdCBJRHMgY2FuIGJlIGFueSBjaGFyYWN0ZXJzIGJlc2lkZXMgdGhlIHBhdGggc2VwYXJhdG9yLlxuICAgKi9cbiAgcHJvdGVjdGVkIF92YWxpZGF0ZUlkKF9pZDogc3RyaW5nKSB7XG4gICAgLy8gY2FuIGJlIHVzZWQgYnkgZGVyaXZlZCBjbGFzc2VzIHRvIGN1c3RvbWl6ZSBJRCB2YWxpZGF0aW9uLlxuICB9XG5cbiAgLyoqXG4gICAqIFRocm93cyBpZiB0aGUgYHByb3BzYCBiYWcgZG9lc24ndCBpbmNsdWRlIHRoZSBwcm9wZXJ0eSBgbmFtZWAuXG4gICAqIEluIHRoZSBmdXR1cmUgd2UgY2FuIGFkZCBzb21lIHR5cGUtY2hlY2tpbmcgaGVyZSwgbWF5YmUgZXZlbiBhdXRvLWdlbmVyYXRlIGR1cmluZyBjb21waWxhdGlvbi5cbiAgICogQHBhcmFtIHByb3BzIFRoZSBwcm9wcyBiYWcuXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSByZXF1aXJlZCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBgcmVxdWlyZVByb3BlcnR5YGAgZnJvbSBgYEBhd3MtY2RrL3J1bnRpbWVgYCBpbnN0ZWFkLlxuICAgKi9cbiAgcHJvdGVjdGVkIHJlcXVpcmVkKHByb3BzOiBhbnksIG5hbWU6IHN0cmluZyk6IGFueSB7XG4gICAgaWYgKCEobmFtZSBpbiBwcm9wcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ29uc3RydWN0IG9mIHR5cGUgJHt0aGlzLnR5cGVuYW1lfSBpcyBtaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5OiAke25hbWV9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsdWUgPSBwcm9wc1tuYW1lXTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgVGhlIHR5cGUgbmFtZSBvZiB0aGlzIG5vZGUuXG4gICAqL1xuICBwcml2YXRlIGdldCB0eXBlbmFtZSgpOiBzdHJpbmcge1xuICAgIGNvbnN0IGN0b3I6IGFueSA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3IubmFtZSB8fCAnQ29uc3RydWN0JztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgY2hpbGQgY29uc3RydWN0IHRvIHRoaXMgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIGNoaWxkIFRoZSBjaGlsZCBjb25zdHJ1Y3RcbiAgICogQHBhcmFtIG5hbWUgVGhlIHR5cGUgbmFtZSBvZiB0aGUgY2hpbGQgY29uc3RydWN0LlxuICAgKiBAcmV0dXJucyBUaGUgcmVzb2x2ZWQgcGF0aCBwYXJ0IG5hbWUgb2YgdGhlIGNoaWxkXG4gICAqL1xuICBwcm90ZWN0ZWQgYWRkQ2hpbGQoY2hpbGQ6IENvbnN0cnVjdCwgY2hpbGROYW1lOiBzdHJpbmcpIHtcbiAgICBpZiAodGhpcy5sb2NrZWQpIHtcblxuICAgICAgLy8gc3BlY2lhbCBlcnJvciBpZiByb290IGlzIGxvY2tlZFxuICAgICAgaWYgKCF0aGlzLnBhdGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYWRkIGNoaWxkcmVuIGR1cmluZyBzeW50aGVzaXMnKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgYWRkIGNoaWxkcmVuIHRvIFwiJHt0aGlzLnBhdGh9XCIgZHVyaW5nIHN5bnRoZXNpc2ApO1xuICAgIH1cblxuICAgIGlmIChjaGlsZE5hbWUgaW4gdGhpcy5fY2hpbGRyZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgaXMgYWxyZWFkeSBhIENvbnN0cnVjdCB3aXRoIG5hbWUgJyR7Y2hpbGROYW1lfScgaW4gJHt0aGlzLnRvU3RyaW5nKCl9YCk7XG4gICAgfVxuXG4gICAgdGhpcy5fY2hpbGRyZW5bY2hpbGROYW1lXSA9IGNoaWxkO1xuICB9XG5cbiAgLyoqXG4gICAqIExvY2tzIHRoaXMgY29uc3RydWN0IGZyb20gYWxsb3dpbmcgbW9yZSBjaGlsZHJlbiB0byBiZSBhZGRlZC4gQWZ0ZXIgdGhpc1xuICAgKiBjYWxsLCBubyBtb3JlIGNoaWxkcmVuIGNhbiBiZSBhZGRlZCB0byB0aGlzIGNvbnN0cnVjdCBvciB0byBhbnkgY2hpbGRyZW4uXG4gICAqL1xuICBwcm90ZWN0ZWQgbG9jaygpIHtcbiAgICB0aGlzLl9sb2NrZWQgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVubG9ja3MgdGhpcyBjb3N0cnVjdCBhbmQgYWxsb3dzIG11dGF0aW9ucyAoYWRkaW5nIGNoaWxkcmVuKS5cbiAgICovXG4gIHByb3RlY3RlZCB1bmxvY2soKSB7XG4gICAgdGhpcy5fbG9ja2VkID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBwYXRoIG9mIGNvbXBvbmVudHMgdXAgdG8gYnV0IGV4Y2x1ZGluZyB0aGUgcm9vdFxuICAgKi9cbiAgcHJpdmF0ZSByb290UGF0aCgpOiBDb25zdHJ1Y3RbXSB7XG4gICAgY29uc3QgYW5jZXN0b3JzID0gdGhpcy5hbmNlc3RvcnMoKTtcbiAgICBhbmNlc3RvcnMuc2hpZnQoKTtcbiAgICByZXR1cm4gYW5jZXN0b3JzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGNvbnN0cnVjdCBvciBhbnkgb2YgaXQncyBwYXJlbnQgY29uc3RydWN0cyBhcmVcbiAgICogbG9ja2VkLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldCBsb2NrZWQoKSB7XG4gICAgaWYgKHRoaXMuX2xvY2tlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmxvY2tlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoZSBjb25zdHJ1Y3QgSUQgY29udGFpbnMgYSBwYXRoIHNlcGFyYXRvciwgaXQgaXMgcmVwbGFjZWQgYnkgZG91YmxlIGRhc2ggKGAtLWApLlxuICAgKi9cbiAgcHJpdmF0ZSBfZXNjYXBlUGF0aFNlcGFyYXRvcihpZDogc3RyaW5nKSB7XG4gICAgaWYgKCFpZCkgeyByZXR1cm4gaWQ7IH1cbiAgICByZXR1cm4gaWQuc3BsaXQoUEFUSF9TRVApLmpvaW4oJy0tJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSByb290IG9mIGEgY29uc3RydWN0IHRyZWUuXG4gKiBObyBwYXJlbnQgYW5kIG5vIG5hbWUuXG4gKi9cbmV4cG9ydCBjbGFzcyBSb290IGV4dGVuZHMgQ29uc3RydWN0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLy8gQnlwYXNzIHR5cGUgY2hlY2tzXG4gICAgc3VwZXIodW5kZWZpbmVkIGFzIGFueSwgJycpO1xuICB9XG59XG5cbi8qKlxuICogQW4gbWV0YWRhdGEgZW50cnkgaW4gdGhlIGNvbnN0cnVjdC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNZXRhZGF0YUVudHJ5IHtcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRoZSBtZXRhZGF0YSBlbnRyeS5cbiAgICovXG4gIHR5cGU6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGRhdGEuXG4gICAqL1xuICBkYXRhPzogYW55O1xuXG4gIC8qKlxuICAgKiBBIHN0YWNrIHRyYWNlIGZvciB3aGVuIHRoZSBlbnRyeSB3YXMgY3JlYXRlZC5cbiAgICovXG4gIHRyYWNlOiBzdHJpbmdbXTtcbn1cblxuZXhwb3J0IGNsYXNzIFZhbGlkYXRpb25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBzb3VyY2U6IENvbnN0cnVjdCwgcHVibGljIHJlYWRvbmx5IG1lc3NhZ2U6IHN0cmluZykge1xuXG4gIH1cbn1cblxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmJhbi10eXBlc1xuZnVuY3Rpb24gY3JlYXRlU3RhY2tUcmFjZShiZWxvdzogRnVuY3Rpb24pOiBzdHJpbmdbXSB7XG4gIGNvbnN0IG9iamVjdCA9IHsgc3RhY2s6ICcnIH07XG4gIGNvbnN0IHByZXZpb3VzTGltaXQgPSBFcnJvci5zdGFja1RyYWNlTGltaXQ7XG4gIHRyeSB7XG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2Uob2JqZWN0LCBiZWxvdyk7XG4gIH0gZmluYWxseSB7XG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gcHJldmlvdXNMaW1pdDtcbiAgfVxuICBpZiAoIW9iamVjdC5zdGFjaykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gb2JqZWN0LnN0YWNrLnNwbGl0KCdcXG4nKS5zbGljZSgxKS5tYXAocyA9PiBzLnJlcGxhY2UoL15cXHMqYXRcXHMrLywgJycpKTtcbn1cbiJdfQ==